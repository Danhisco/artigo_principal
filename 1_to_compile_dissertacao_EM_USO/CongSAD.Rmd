---
title: "Validação empírica de MNEE e suas implicações para a estimatva de efeitos da paisagem"
output: 
  bookdown::word_document2: default
editor_options: 
  chunk_output_type: console
---

<!-- # Apêndice: Cong SAD (SI)  {-#CongSAD} -->

```{r setup4,include=TRUE,eval=TRUE,echo=FALSE,message = FALSE,warning = FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE,cache=TRUE,
                      fig.pos = "H", fig.show = "hold",dpi = 72)
# pacotes
library(gt)
library(gratia)
library(sads)
library(doMC)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(data.table)
library(plyr)
library(dplyr)
library(flextable)
source("source/nameModel.R")
source("source/GAMMtools.R")
source("source/general_tools.R")
f_z <- function(x) (x-mean(x))/sd(x)
f_label <- \(vn){
  gsub("1","M4",vn) %>% 
    gsub("s\\(k,by\\=land\\) \\+ \\(lat,long\\)","M1",.) %>% 
    gsub("s\\(k,by\\=land\\) - te\\(k,plot,by\\=land\\)","M3",.) %>% 
    gsub("s\\(k,by\\=land\\)","M2",.)
    
}
f_antilabel <- \(vn){
  gsub("M4","1",vn) %>% 
    gsub("M1","s\\(k,by\\=land\\) \\+ \\(lat,long\\)",.) %>% 
    gsub("M3","s\\(k,by\\=land\\) - te\\(k,plot,by\\=land\\)",.) %>% 
    gsub("M2","s\\(k,by\\=land\\)",.)
    
}
#
l_dfpred <- readRDS(file = "dados/csv_SoE/rds/l_dfpred_md_cong_absoluta.rds")
vsites105 <- l_dfpred$fixo_e_aleat$SiteCode %>% unique
#
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv") %>% 
  mutate(lat = ifelse(is.na(lat_correct),lat,lat_correct),
         long = ifelse(is.na(long_correct),long,long_correct),
         Sitecode = factor(SiteCode)) %>% 
  select(SiteCode,lat,long, forest_succession) %>% 
  filter(forest_succession!="capoeira",
         SiteCode %in% vsites105)
#
l_f <- list()
# modelo cheio: conectividade + proximidade geográfica
l_f$`s(k,by=land) + (lat,long)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(lat,long) + 
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem coordenadas: apenas conectividade
l_f$`s(k,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem conectividade como efeito aleatório
l_f$`s(k,by=land) - te(k,plot,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(SiteCode,bs="re")
# modelo sem conectividade como efeito fixo
l_f$`1` <- 
  cbind(nSAD,100-nSAD) ~ 
  1 +
  s(SiteCode,bs="re")
```


```{r sumarização dos resultados do teste KS, echo=FALSE,eval=FALSE}
f_summarise_SAD_MNEE <- \(df){
#@ df: df por site, k, e  land_type
#@ e.g. ddply(.,c("SiteCode","k","land_type"))
 cbind(df[1,c("SiteCode","k","land_type")],with(df,data.frame(
   nSAD = sum(p.KS>0.05),
   Smed = mean(S),
   Ssd = sd(S),
   Smin = min(S),
   Smax = max(S) )  )
  )
}
df_KSrep <- read_csv(file="dados/csv_SoE/df_KSrep.csv")
library(future.apply)  
library(parallel)      
plan(multisession, workers = 3)
groups <- do.call(paste, c(df_KSrep[c("SiteCode", "k", "land_type")], sep = "|"))
df_split <- split(df_KSrep, groups)
ldf <- future_lapply(df_split, \(subset_df){
  f_summarise_SAD_MNEE(subset_df)
  }, future.seed = TRUE)
df_ad <- data.table::rbindlist(ldf)
# inclusão das covariáveis
df_ad <- inner_join(df_ad,df_dados_disponiveis)
#
# write_csv(df_ad,file="dados/csv_SoE/df_congruencia_simulacao.csv")
```

```{r leitura de df_ad,echo=FALSE,include=TRUE,eval=TRUE}
df_ad <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") %>% 
  select(-(Smed:Smax)) %>%
  mutate(across(where(is.character), factor))
names(df_ad) <- gsub("\\_type","",names(df_ad)) %>% 
  gsub("forest\\_succession","class_pert",.)
```


```{r trackdown chunk SI, include=FALSE,eval=FALSE}
# pacotes
library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
# upload_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
#             gpath = "mestrado/artigo_principal/apendices/",
#             hide_code = TRUE)
update_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
            gpath = "mestrado/artigo_principal/apendices/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file = "secoes_texto/Resultados/Resultados.Rmd",
              gpath = "mestrado/artigo_principal/secoes_texto/")
```

<!-- # Validação empírica de MNEE e suas implicações para a estimatva de efeitos da paisagem {CongSAD} -->

# Descrição estatística da congruência com a SAD observada

<p>
A descrição estatística da probabilidade de uma SAD simulada ter boa congruência com a SAD observada por paisagem experimental (fragmentada - f, aglomerada - a, prístina - p) foi obtida por um modelo aditivo generalizado hierárquico (HGAM, @wood2017, @Pedersen2019). Esses modelos estatísticos permitem expressar a estrutura dos dados agregada por parcela de amostragem (@Pedersen2019) e descrever efeitos descritivos não lineares por splines e tensores de suas preditoras (@wood2017). Splines agem como "curvas ajustáveis" que se adaptam aos dados, controlando o grau de suavização para evitar sobreajuste através da penalização pela máxima verossimilhança restrita (@wood2017). O objetivo de splines e tensores é a descrição de qualquer relação contínua (@wood2017). Todas as análises estatísticas foram feitas usando linguagem R (@Rlang) e o pacote mgcv (REF).
</p>

<p>
Para a descrição da congruência com a SAD observada, a variável-resposta foi a proporções das 100 SADs simuladas classificadas como congruentes. A estrutura hierárquica do HGAM é dividida em duas: a variabilidade agrupada pela parcela amostrada que contém os splines do cenários de limitação de dispersão (k) por paisagens experimental (land), considerada aleatória; e a variabilidade relacionada com a população de todas as parcelas, que contem os splines dos efeitos médios de k por land, considerada fixa. Entre as preditoras da estrutura fixa também incluímos as coordenadas geográficas das parcelas amostradas, que possuem um spline para descrever a possível autocorrelação espacial entre as parcelas.
</p>

<p>Assim, a probabilidade de uma distribuição de abundância de espécies (SAD) simulada apresentar boa congruência com a SAD observada foi modelada utilizando 4 HGAM com diferentes níveis de complexidade. As formulas usadas para ajustar esses modelo estatísticos foram:

```{r modelos usados na descrição, eval=FALSE, echo=FALSE,include=FALSE}
library(mgcv)
f_gam <- \(vf,dfi){
  gam(formula=vf,
      family='binomial',
      data=dfi,
      method="REML")
}
l_f <- list()
# modelo cheio: conectividade + proximidade geográfica
l_f$`s(k,by=land) + (lat,long)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(lat,long) + 
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem coordenadas: apenas conectividade
l_f$`s(k,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem conectividade como efeito aleatório
l_f$`s(k,by=land) - te(k,plot,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(SiteCode,bs="re")
# modelo sem conectividade como efeito fixo
l_f$`1` <- 
  cbind(nSAD,100-nSAD) ~ 
  1 +
  s(SiteCode,bs="re")
l_md <- lapply(l_f,f_gam,dfi=df_ad)
saveRDS(l_md,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
```


```{r cap tab desc md,echo=FALSE,include=TRUE,eval=TRUE}
vcap <- paste(
      "Description of the four competing hierarchical generalized additive models (HGAMs) ",
      "used to explain the probability of shape congruence between empirical and simulated ",
      "species abundance distributions. In all models, k represents the smooth of dispersal ",
      "limitation (i.e., the fraction of propagules retained in the immediate neighborhood ",
      "of the progenitor), and land denotes the experimental landscape. Models differ in the ",
      "inclusion of plot-level random effects, landscape-specific connectivity responses, ",
      "and explicit geographic structure."
    )
```
```{r tabdescmd,echo=FALSE,include=TRUE,eval=TRUE}
library(flextable)
library(dplyr)
# Criar data.frame com a descrição conceitual dos modelos
tab_models <- tibble::tibble(
  Model = c("M1 (full)",
            "M2 (no spatial coords)",
            "M3 (no plot-specific connectivity)",
            "M4 (null)"),
  
  `Fixed effects (connectivity)` = c(
    "Interaction of k and land",
    "Interaction of k and land",
    "Interaction of k and land",
    "Intercept only"
  ),
  
  `Random effects (plot-level)` = c(
    "Plot-specific interaction of k and land",
    "Plot-specific interaction of k and land",
    "Random intercept for plot",
    "Random intercept for plot"
  ),
  
  `Spatial coordinates` = c(
    "Bivariate smooth of latitude and longitude",
    "None",
    "None",
    "None"
  ),
  
  `Ecological interpretation` = c(
    "Congruence is described by connectivity, emerging from the interaction between dispersal and the landscape configuration, and by spatial proximity among forest plots.",
    "Congruence is described by connectivity, independent of geographic proximity",
    "Congruence is described by average connectivity effects, ignoring plot-specific dispersal–landscape interactions",
    "Congruence varies only among plots, without effects of dispersal or landscape"
  )
)

# Criar flextable
ft_models <- flextable(tab_models)

# Ajustes de formatação
ft_models <- ft_models |>
  set_header_labels(
    Model = "Model",
    `Fixed effects (connectivity)` = "Fixed effects",
    `Random effects (plot-level)` = "Random effects",
    `Spatial coordinates` = "Geographic space",
    `Ecological interpretation` = "Ecological meaning"
  ) |>
  autofit() |>
  align(align = "left", part = "all") |>
  bold(part = "header") |>
  valign(valign = "top", part = "body") %>% 
  set_caption(
    caption = vcap
  )

# Visualizar
ft_models
```




Os HGAM foram comparados usando métricas derivadas do ‘Akaike Information Criteria’ para amostras pequenas (AICc), o delta AICc e o peso de evidência (@burnham1998practical). Também incluímos o ‘deviance explained’ que pode ser interpretado de forma análoga ao coeficiente de determinação (R2), como forma de descrever a variabilidade explicada pelo modelo estatístico. Para essas tarefas foram utilizadas funções dos pacotes 'mgcv' (@wood2011) e 'bblme' (@bbmle_package).</p>


## Teste de autocorrelação espacial global I de Moran

<p>Uma vez que os splines são ideais para descrever relações contínuas, a autocorrelação espacial negativa pode não ser bem descrita pelo modelo estatístico, assim, incluímos um teste bicaudal de autocorrelação espacial dos resíduos dos modelos estatísticos. Se houver autocorrelação espacial que não foi bem descrita pelo modelo estatístico, esperamos que a média, por parcela, dos resíduos do modelo apresentem a estatística I de Moran diferente de zero. A estatística I de Moran varia entre -1 e 1, ou seja, entre a autocorrelação espacial negativa e positiva, respectivamente. E possui um teste de hipótese associado que avalia se o valor é significativamente diferente de zero, se o p valor for próximo de zero então a hipótese de ausência de autocorrelação espacial possui pouco suporte. A estatística I de Moran requer que um parâmetro livre seja escolhido. Determinamos esse valor por uma análise de sensibilidade dos resíduos dos modelos ajustados. Para obter a estatística I de Moran e seu p valor associado utilizamos funções do pacote spdep (@bivand2020). A avaliação da sensibilidade desse parâmetro está na figura \@ref(fig:fig-moranI).</p> 


```{r criacao da analise de sensibilidade de lmoranI,echo=FALSE,include=FALSE,eval=FALSE}
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
lmoranI <- lapply(l_md,f_MoranTest_GAMM_severalK)
# saveRDS(lmoranI,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong_lMoranI.rds")
f_ggplot <- \(vname){
  dfi <- lmoranI[[vname]]
  dfi %>% 
    mutate(k=as.numeric(k),
           label=f_label(vname)) %>% 
    ggplot(aes(x=k)) +
    geom_hline(color="darkgray",yintercept = 0) +
    geom_hline(linetype=2,aes(color="significance threshold (0.05)",
                              yintercept = 0.05)) +
    geom_line(aes(color="p-value",y=pvalue)) +
    geom_line(aes(color="Moran's I",y=MoranI_stat_res)) +
    scale_color_manual("",values=c("significance threshold (0.05)"="red",
                                   "p-value"="black",
                                   "Moran's I"="green")) +
    scale_y_continuous(breaks=c(-0.07,0,0.05,0.25,0.50,0.75,1),
                       limits=c(-0.08,1.001),
                       expand = c(0,0.01)) +
    labs(x="n-nearest neighbors",y="") +
    theme_bw() +
    facet_wrap(~label) +
    theme(legend.position = "top") 
}
lp <- lapply(names(lmoranI),f_ggplot)
library(patchwork)
pfinal <- wrap_plots(lp, nrow = 2) +
  plot_layout(guides = "collect") +
  plot_annotation(
    title = "Assessment of spatial autocorrelation",
    subtitle = "two-sided Moran's I"
  ) & 
  theme(legend.position = "top",
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = 10, hjust = 0.5, face = "bold"),
        plot.margin = margin(2, 0, 2, 0)) 
saveRDS(pfinal,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_moranI_sensibilidade.rds")
```
```{r cap sensibilidade moran, eval=TRUE,echo=FALSE,include=TRUE}
vcap <- do.call(sprintf, c(list("Sensitivity analysis of Moran's I test for spatial autocorrelation in model residuals. Panels show two-tailed p-values of Moran's I statistic calculated for mean residuals from two statistical models (left: %s, middle: %s, right: %s), grouped by forest plots. The x-axis represents neighborhood size defined as the number of nearest neighbors (n), ranging from 1 to 100. The y-axis shows corresponding p-values, with a horizontal dashed line indicating the significance threshold (α = 0.05). The absence of p-values below 0.05 across the entire range of neighborhood sizes indicates no significant spatial autocorrelation in the residuals of either model, suggesting that spatial structure was adequately captured by the model formulations."), names(l_f)[1:4]))
```
```{r fig-moranI,echo=FALSE,eval=TRUE,include=TRUE,fig.cap=vcap,fig.width=6, fig.height=8}
pfinal <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_moranI_sensibilidade.rds")
pfinal
```


<p> <!-- texto explicando fig-moranI -->
texto explicando fig-moranI
</p>






## Tabela de comparação dos HGAM

```{r criacao da tabela final, include=FALSE,eval=FALSE,echo=FALSE}
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
df_tabsel <- f_TabSelGAMM(l_md,test_moranK = FALSE)
write_csv(df_tabsel,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv")
```

```{r}
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv") %>% 
  mutate(across(where(is.numeric), ~round(.x,2)),
         modelo=f_label(modelo))
f_flextable <- \(dfi){
  dfi %>% 
    flextable() %>%
    bg(bg = "white",part = "all") %>%
    theme_vanilla() %>% 
    set_header_labels(
      modelo = "HGAM",
      dAICc = "ΔAICc",
      df = "est. coef.",
      weight = "weight",
      dev.expl = "Dev. Exp.") %>%
    bold(part = "header") %>%
    colformat_num(digits = 2) %>% 
    align(align = "center", part = "all") %>% 
    autofit()
}
f_flextable(df_tabsel)
```


<p> <!-- texto interpretando a tabela  -->
texto interpretando a tabela de seleção
</p>


```{r criação da predição do mais plausível, eval=FALSE,include=FALSE,echo=FALSE}
# dados
df_ad <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") %>% 
  select(-(Smed:Smax)) %>%
  mutate(across(where(is.character), factor))
names(df_ad) <- gsub("\\_type","",names(df_ad)) %>% 
  gsub("forest\\_succession","class_pert",.)
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv") %>% 
  mutate(across(where(is.numeric), ~round(.x,2)),
         modelo=f_label(modelo))
# carregar 
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
vname <- sapply(df_tabsel$modelo,f_antilabel)
hgam <- l_md[[vname["M1"]]]
##--------------------------------------
##----------- o predito para o observado
##--------------------------------------
new_data <- expand.grid(
  k = unique(df_ad$k),
  land = unique(df_ad$land),
  lat = 0,
  long = 0,
  SiteCode = "SPigua1"  # Replace with a fixed value
)
# por parcela florestal
l_dfpred <- list()
l_dfpred$fixo_e_aleat <- hgam$model
l_dfpred$fixo_e_aleat[,1] <- l_dfpred$fixo_e_aleat[,1][,1]
names(l_dfpred$fixo_e_aleat)[c(1,3)] <- c("nSAD","k")
lpred <- predict(hgam,
                 type = "response", 
                 se.fit = TRUE)
l_dfpred$fixo_e_aleat$fit <- lpred$fit
l_dfpred$fixo_e_aleat$se <- lpred$se.fit
l_dfpred$fixo_e_aleat <- mutate(
  l_dfpred$fixo_e_aleat,
  lower = fit - 1.96 * se,
  upper = fit + 1.96 * se
)
# para a população de parcelas
l_dfpred$fixo <- expand.grid(
  k = unique(df_ad$k),
  land = unique(df_ad$land),
  lat = 0,
  long = 0,
  SiteCode = "SPigua1"
)
lpred <-  predict(hgam,
                  newdata=l_dfpred$fixo,
                  type = "response",
                  exclude=c("s(lat,long)",
                            "te(k,SiteCode):landcont",
                            "te(k,SiteCode):landideal",
                            "te(k,SiteCode):landnon_frag"),
                  se.fit = TRUE)
l_dfpred$fixo$fit <- lpred$fit
l_dfpred$fixo$se <- lpred$se.fit
l_dfpred$fixo <- mutate(
  l_dfpred$fixo,
  lower = fit - 1.96 * se,
  upper = fit + 1.96 * se
)
# padronização e salvamento
l_dfpred <- lapply(l_dfpred,\(dfi){
  mutate(dfi,across(fit:upper,~.x*100),
         land=factor(land,
                     levels=c("cont",
                              "non_frag",
                              "ideal"),
                     labels=c("fragmented",
                              "clumped",
                              "pristine"))
         ) %>% 
    select(-lat,-long)
})
saveRDS(l_dfpred,file = "dados/csv_SoE/rds/l_dfpred_md_cong_absoluta.rds")
```

## Interpretação pelo HGAM mais plausível

```{r criação da figCong, eval=FALSE,include=FALSE,echo=FALSE}
library(hexbin)
p <- l_dfpred$fixo_e_aleat %>% 
  ggplot(aes(x=k,y=nSAD)) +
  # geom_point(alpha=0.3) +
  geom_line(aes(y=fit,group = SiteCode),alpha=0.3) +
  # geom_boxplot(aes(group=k),alpha=0.6) +
  geom_ribbon(data=l_dfpred$fixo,
              aes(x=k,y=fit,ymin=lower,ymax=upper),
              color="blue",
              fill="lightblue") +
  geom_line(data=l_dfpred$fixo,
            aes(x=k,y=fit),
            color="darkred") +
  geom_hex(bins = 50,alpha=0.5) + 
  scale_fill_gradient("count",low = "gray", high = "black", na.value = NA) +
  scale_x_continuous(expand = c(0.01, 0)) +
  scale_y_continuous(expand = c(0.01, 0)) +
  labs(x="Fraction of propagules within the immediate neighborhood (k)",
       y="Number of congruent simulated SADs (goodness-of-fit)",
       title="Congruence of simulated SADs across experimental landscapes",
       subtitle="Congruence is best described by connectivity and spatial proximity among forest plots") +
  facet_wrap(~land) +
  theme_classic() +
  theme(strip.text = element_text(size=12, #margin=margin(),
                                  face="bold"))
saveRDS(p,file = "1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_interpretacao_cong.rds")
ggsave(filename="figuras/descricao_congruencia_absoluta.png",
       p,height = 7.33,width = 13.8)
library(magick)
img <- image_read("figuras/descricao_congruencia_absoluta.png") %>% 
  image_resize("50%") %>% 
  image_trim()
image_write(img,path = "figuras/descricao_congruencia_absoluta.png")
```
```{r captio figCong,eval=TRUE,echo=FALSE}
vcap <- "teste"
```
```{r figCong,fig.cap=vcap}
p <- readRDS(file = "1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_interpretacao_cong.rds")
p
```

Essa figura vai para o resultado principal

# Implicações para a estimativa de efeitos da paisagem

-> adicionar os gráficos que mostram a diferença entre os grupos de parcelas (usados nas próximas análises X os filtrados), incluindo o mapa

## As parcelas interpretadas não diferem de forma sistemática com as parcelas fora dos critérios de congruência

Das 105 parcelas florestais simuladas, em 67 delas MNEE apresentou boa congruência nas três paisagens experimentais quando a limitação de dispersão era moderada até muito limitada (k>=0.50).


```{r criacao da classificação das parcelas quanto à congruencia e suas implicacoes, echo=FALSE, eval=FALSE, include=FALSE}
# df_p
df_p <- read_csv("dados/df_p.csv")
#df_sítios simuláveis em MNEE contemporâneo
df_coord <- read_csv(file = "dados/df_dados_disponiveis.csv") %>% 
  mutate(lat = ifelse(is.na(lat_correct),lat,lat_correct),
         long = ifelse(is.na(long_correct),long,long_correct),
         Sitecode = factor(SiteCode)) %>% 
  select(SiteCode,lat,long, forest_succession) %>% 
  filter(forest_succession!="capoeira")

v_site <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") %>% 
  pull(SiteCode) |> unique()
v_site <- intersect(df_coord$SiteCode,v_site)
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv") %>% 
  filter(SiteCode %in% vsites105)
# quem são os não intepretados?
df_ad <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") 
summarise <- 
df_selected <- df_ad %>% 
  filter(k>=0.49999) %>%
  group_by(SiteCode) %>% 
  dplyr::summarise(selecionado = all(nSAD>=75))
#-------------------------------------------------------------
#--------------------------- gráficos ------------------------
#-------------------------------------------------------------
lp <- list()
# características das parcelas interpretadas e das outras
dfp <- inner_join(df_selected,select(df_dados_disponiveis,-forest_succession))
dfp <- inner_join(dfp, distinct( select(df_sim,-c(k:d)) ) )
dfp <- inner_join(dfp, df_p)
lp$cong_land <- select(dfp,-tif.path) %>% 
  pivot_longer(lat:p) %>% 
  mutate(name=factor(name,
                     levels=c("p","effort_ha","Ntotal","S_obs","lat","long"),
                     labels=c("%FL","plot area","N","S","lat","long")),
         legend_label = paste0(selecionado,
                              " (",
                              ifelse(selecionado,67,105-67),
                              ")")
         ) %>% 
  ggplot(aes(x=legend_label,y=value,color=legend_label)) +
  geom_boxplot() +
  geom_jitter() +
  scale_color_manual("selected",values=c("TRUE (67)"="green3","FALSE (38)"="red")) +
  facet_wrap(~name,nrow=2,scales="free") +
  theme_classic() +
  labs(x="",y="") +
  theme(legend.position = "bottom",
        plot.margin = margin(2, 2, 2, 2, "mm"),
        legend.margin = margin(0, 0, 0, 0),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
# mapa que descreve a localização
library(sf)
shp_FA <- read_sf("dados/shapefile/biome_border.shp")
sf_plot <- st_as_sf(dfp,coords = c("long", "lat"), crs = 4326)
sf_plot <- st_transform(sf_plot,crs=st_crs(shp_FA))
lp$mapa <- ggplot() +
  geom_sf(data=shp_FA,fill="darkgray",color="darkgreen") +
  geom_sf(data = sf_plot,aes(fill=selecionado,shape=selecionado, size=5,alpha=0.75)) +
  coord_sf(ylim = c(-32,-5),xlim = c(-56,-34),expand = FALSE) +
  scale_shape_manual(
    name = NULL,
    values = c("FALSE" = 25, "TRUE" = 24)
    ) +
  scale_fill_manual(
    name = NULL,
    values = c("FALSE" = "red", "TRUE" = "green3")
    ) +
  theme(
    legend.position = "none"
  ) +
  ggspatial::annotation_north_arrow(
    location = "br",                   # bottom right
    which_north = "true",
    height = unit(1.2, "cm"),
    width = unit(1.2, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  ggspatial::annotation_scale(
    location = "br",                    
    pad_x = unit(2.5, "cm"),
    pad_y = unit(0.5, "cm"),
    width_hint = 0.2,                   # largura relativa (20% do mapa)
    style = "bar"                       # estilo "bar" ou "ticks"
  ) 
saveRDS(lp,file = "1_to_compile_dissertacao_EM_USO/09_SI/RDS/lp_implicacoes_parcelas_selecionadas.rds")
```
```{r caption fig sem dif entre selecionadas e nao, echo=FALSE,eval=TRUE,include=TRUE}
vcap <- "Environmental and spatial characterization of plot selection in Atlantic Forest surveys. (A) Comparative analysis of six key operational variables: forest cover percentage (%FL; 0-100% scale), plot area (in hectares), stem density (N; number of individuals), species richness (S; number of species), latitude, and longitude (decimal degrees). Green boxplots represent selected plots (n = 67), red boxplots represent non-selected plots (n = 38). Boxes display interquartile ranges (IQR), horizontal lines indicate medians, whiskers extend to 1.5×IQR, and points show raw values. (B) Spatial context of sampling locations within the Atlantic Forest biome. Points represent plot centroids, overlaid on the official IBGE Atlantic Forest shapefile (gray polygon), which follows a conservative biome delimitation. The consistent color coding (green = selected, red = non-selected) allows direct comparison between environmental patterns and geographic distribution."
```
```{r fig-implicacoes-cong,fig.cap=vcap}
library(sf)
library(patchwork)
lp <- readRDS(file = "1_to_compile_dissertacao_EM_USO/09_SI/RDS/lp_implicacoes_parcelas_selecionadas.rds")
wrap_plots(plotlist=lp,ncol=2) +
  plot_annotation(
    title = "Operational variables show similar distributions in selected and non-selected plots",
    tag_levels = 'a',
    tag_prefix = '('
  ) &
  theme(
    plot.tag = element_text(size = 14, face = "bold"),
    plot.tag.position = c(0, 1),
    plot.title = element_text(
      size = 14,
      face = "bold",
      hjust = 0.5,  # centralizado
      margin = margin(b = 8, t = 5)
    )
  )
```




# Material suplementar do apêndice

## Mapas de cobertura florestal das parcelas selecionadas e das outras
```{r criacao dos mapas de cobertura florestal das parcelas selecionadas e das outras, echo=FALSE, eval=FALSE, include=FALSE}
# df_p
df_p <- read_csv("dados/df_p.csv")
#df_sítios simuláveis em MNEE contemporâneo
df_coord <- read_csv(file = "dados/df_dados_disponiveis.csv") %>% 
  mutate(lat = ifelse(is.na(lat_correct),lat,lat_correct),
         long = ifelse(is.na(long_correct),long,long_correct),
         Sitecode = factor(SiteCode)) %>% 
  select(SiteCode,lat,long, forest_succession) %>% 
  filter(forest_succession!="capoeira")

v_site <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") %>% 
  pull(SiteCode) |> unique()
v_site <- intersect(df_coord$SiteCode,v_site)
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv") %>% 
  filter(SiteCode %in% vsites105)
# quem são os não intepretados?
df_ad <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") 
summarise <- 
df_selected <- df_ad %>% 
  filter(k>=0.49999) %>%
  group_by(SiteCode) %>% 
  dplyr::summarise(selecionado = all(nSAD>=75))
#-------------------------------------------------------------
#--------------------------- gráficos ------------------------
#-------------------------------------------------------------
# características das parcelas interpretadas e das outras
dfp <- inner_join(df_selected,select(df_dados_disponiveis,-forest_succession))
dfp <- inner_join(dfp, distinct( select(df_sim,-c(k:d)) ) )
dfp <- inner_join(dfp, df_p)
# Supondo que você tenha:
library(raster)
library(magick)
library(patchwork)
library(dplyr)

# Função para carregar e plotar um mapa
plot_tif_map <- \(dfi, fill_color = "darkgreen") {
  # Carregar raster
  r <- raster::raster(dfi$tif.path)
  # Converter para data.frame para ggplot
  r_df <- as.data.frame(r, xy = TRUE)
  names(r_df)[3] <- "value"
  r_df$label <- dfi$SiteCode
  # Criar plot básico
  p <- ggplot() +
    geom_raster(data = r_df, aes(x = x, y = y, fill = value)) +
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0)) +
    scale_fill_gradient(low = "lightgray", high = fill_color, na.value = NA) +
    coord_equal() +
    theme_classic() +
    labs(x="",y="") +
    theme(
      legend.position = "none",
      strip.text = element_text(size=14,face="bold"),
      plot.margin = margin(2, 2, 2, 2, "mm"),
      plot.title = element_text(size = 8, hjust = 0.5, face = "bold",
                                margin = margin(b = 2))
    ) +
    facet_wrap(~label)
  #
  vpath <- tempfile(fileext = ".png")
  ggsave(filename = vpath,plot = p,
         width = ,
         height = ,
         dpi=200)
  #
  img_p <- image_read(vpath) %>% 
    image_trim()
  vpath <- paste0("1_to_compile_dissertacao_EM_USO/09_SI/figuras_SI/mapas_cobertura/",
                  dfi$SiteCode,".jpeg")
  image_write(img_p,
              path=vpath)
  return(vpath)
}
f_concatenar_img <- \(dfpi, ncol=6){
  #
  dfref <- dfpi %>%
    mutate(jpeg.path = paste0(
      "1_to_compile_dissertacao_EM_USO/09_SI/figuras_SI/mapas_cobertura/",
      SiteCode,".jpeg")
      ) %>% 
    arrange(p)
  #
  limg <- lapply(dfref$jpeg.path,image_read)
  limg0 <- limg
  #
  lfinal <- list()
  i <- 1
  while(length(limg)>0){
    li <- limg[1:6]
    f_append <- \(x,y) image_append(c(x, y), stack = TRUE)
    pf <- Reduce(f = f_append,x = li)
    lfinal[[i]] <- pf
    i <- i + 1
    limg[1:6] <- NULL
    rm(pf);gc()
  }
  #
  f_append <- \(x,y) image_append(c(x, y), stack = FALSE)
  lfinal[[1]] <- image_append(c(lfinal[[1]], lfinal[[12]]), stack = TRUE)   
  lfinal[[12]] <- NULL
  pfinal <- Reduce(f=f_append,x=lfinal)
  
}
#
dfp %>% 
  arrange(p) %>% 
  dplyr::mutate(id = row_number()) %>% 
  a_ply(.,1,plot_tif_map)
# composições por tipo de paisagem (selecionada ou não)
dfpi <- dfp %>% filter(selecionado)
lpaths <- dlply(dfp,"selecionado",f_concatenar_img)


```

### Parcelas selecionadas

```{r caption parcelas selecionadas}
vcap <- "Mapas de cobertura florestal da paisagem ao redor das parcelas selecionadas. Esses mapas são obtidos da coleção 6 do Mapbiomas e correspondem a um recorte de 16km x 16 km. Em verde a cobertura florestal e em cinza a não-cobertura florestal."
```
```{r fig-mapas-selecionados, fig.cap=vcap,fig.width=12}
p_selecionados <- readRDS(file = "1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_selecionadas.rds")
p_selecionados

```


### Parcelas não selecionadas

```{r caption parcelas nao selecionadas}
vcap <- "Mapas de cobertura florestal da paisagem ao redor das parcelas não selecionadas. Esses mapas são obtidos da coleção 6 do Mapbiomas e correspondem a um recorte de 16km x 16 km. Em verde a cobertura florestal e em cinza a não-cobertura florestal."
```
```{r fig-mapas-naoselecionados, fig.cap=vcap,fig.width=12}
p_naoselecionados <- readRDS(file ="1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_naoselecionadas.rds")
p_naoselecionados
```

## Diagnostico HGAM mais plausivel

### Tabela do HGAM

```{r criacao da tabela do modelo mais plausivel,echo=FALSE,include=FALSE,eval=FALSE}
f_gsub <- \(vchar){
  gsub("ideal","_pristine",vchar) %>% 
    gsub("non_frag","_clumped",.) %>% 
    gsub("cont","_frag",.)
}
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv")
hgam <- l_md[[df_tabsel$modelo[1]]]
tab_todisp <- as_flextable(hgam) %>% bg(., bg = "white", part = "all")
tosav <- tab_todisp %>% 
  set_formatter(Term = f_gsub) %>% 
  set_caption(caption = "Summary of the Generalized Additive Model (M1) coefficients and approximate significance of smooth terms.") %>% 
  autofit()
saveRDS(tosav,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabmd_cong.rds")
```
```{r tabsel}
tosav <- 
  readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabmd_cong.rds")
tosav
```


### Gráficos Diagnóstico do HGAM

```{r gráfico diagnóstico padrão, echo=FALSE,include=TRUE,eval=TRUE}
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv") %>% 
  mutate(across(where(is.numeric), ~round(.x,2)),
         modelo=f_label(modelo))
# carregar 
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
vname <- sapply(df_tabsel$modelo,f_antilabel)
hgam <- l_md[[vname["M1"]]]
appraise(hgam)
```

