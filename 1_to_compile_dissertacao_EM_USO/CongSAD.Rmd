---
title: "Validação empírica de MNEE e suas implicações para a estimatva de efeitos da paisagem"
output: 
  bookdown::word_document2: default
editor_options: 
  chunk_output_type: console
---

<!-- # Apêndice: Cong SAD (SI)  {-#CongSAD} -->

```{r setup4,include=TRUE,eval=TRUE,echo=FALSE,message = FALSE,warning = FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE,cache=TRUE,
                      fig.pos = "H", fig.show = "hold",dpi = 72)
# pacotes
library(gt)
library(gratia)
library(sads)
library(doMC)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(data.table)
library(plyr)
library(dplyr)
library(flextable)
source("source/nameModel.R")
source("source/GAMMtools.R")
source("source/general_tools.R")
f_z <- function(x) (x-mean(x))/sd(x)
f_label <- \(vn){
  gsub("1","M4",vn) %>% 
    gsub("s\\(k,by\\=land\\) \\+ \\(lat,long\\)","M1",.) %>% 
    gsub("s\\(k,by\\=land\\) - te\\(k,plot,by\\=land\\)","M3",.) %>% 
    gsub("s\\(k,by\\=land\\)","M2",.)
    
}
f_antilabel <- \(vn){
  gsub("M4","1",vn) %>% 
    gsub("M1","s\\(k,by\\=land\\) \\+ \\(lat,long\\)",.) %>% 
    gsub("M3","s\\(k,by\\=land\\) - te\\(k,plot,by\\=land\\)",.) %>% 
    gsub("M2","s\\(k,by\\=land\\)",.)
    
}
#
l_dfpred <- readRDS(file = "dados/csv_SoE/rds/l_dfpred_md_cong_absoluta.rds")
vsites105 <- l_dfpred$fixo_e_aleat$SiteCode %>% unique
#
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv") %>% 
  mutate(lat = ifelse(is.na(lat_correct),lat,lat_correct),
         long = ifelse(is.na(long_correct),long,long_correct),
         Sitecode = factor(SiteCode)) %>% 
  select(SiteCode,lat,long, forest_succession) %>% 
  filter(forest_succession!="capoeira",
         SiteCode %in% vsites105)
#
l_f <- list()
# modelo cheio: conectividade + proximidade geográfica
l_f$`s(k,by=land) + (lat,long)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(lat,long) + 
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem coordenadas: apenas conectividade
l_f$`s(k,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem conectividade como efeito aleatório
l_f$`s(k,by=land) - te(k,plot,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(SiteCode,bs="re")
# modelo sem conectividade como efeito fixo
l_f$`1` <- 
  cbind(nSAD,100-nSAD) ~ 
  1 +
  s(SiteCode,bs="re")
```


```{r sumarização dos resultados do teste KS, echo=FALSE,eval=FALSE}
f_summarise_SAD_MNEE <- \(df){
#@ df: df por site, k, e  land_type
#@ e.g. ddply(.,c("SiteCode","k","land_type"))
 cbind(df[1,c("SiteCode","k","land_type")],with(df,data.frame(
   nSAD = sum(p.KS>0.05),
   Smed = mean(S),
   Ssd = sd(S),
   Smin = min(S),
   Smax = max(S) )  )
  )
}
df_KSrep <- read_csv(file="dados/csv_SoE/df_KSrep.csv")
library(future.apply)  
library(parallel)      
plan(multisession, workers = 3)
groups <- do.call(paste, c(df_KSrep[c("SiteCode", "k", "land_type")], sep = "|"))
df_split <- split(df_KSrep, groups)
ldf <- future_lapply(df_split, \(subset_df){
  f_summarise_SAD_MNEE(subset_df)
  }, future.seed = TRUE)
df_ad <- data.table::rbindlist(ldf)
# inclusão das covariáveis
df_ad <- inner_join(df_ad,df_dados_disponiveis)
#
# write_csv(df_ad,file="dados/csv_SoE/df_congruencia_simulacao.csv")
```

```{r leitura de df_ad,echo=FALSE,include=TRUE,eval=TRUE}
df_ad <- read_csv(file="dados/csv_SoE/df_congruencia_simulacao.csv") %>% 
  select(-(Smed:Smax)) %>%
  mutate(across(where(is.character), factor))
names(df_ad) <- gsub("\\_type","",names(df_ad)) %>% 
  gsub("forest\\_succession","class_pert",.)
```


```{r trackdown chunk SI, include=FALSE,eval=FALSE}
# pacotes
library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
# upload_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
#             gpath = "mestrado/artigo_principal/apendices/",
#             hide_code = TRUE)
update_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
            gpath = "mestrado/artigo_principal/apendices/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file = "secoes_texto/Resultados/Resultados.Rmd",
              gpath = "mestrado/artigo_principal/secoes_texto/")
```

<!-- # Validação empírica de MNEE e suas implicações para a estimatva de efeitos da paisagem {CongSAD} -->

# Descrição estatística da congruência com a SAD observada

<p>
A descrição estatística da probabilidade de uma SAD simulada ter boa congruência com a SAD observada por paisagem experimental (fragmentada - f, aglomerada - a, prístina - p) foi obtida por um modelo aditivo generalizado hierárquico (HGAM, @wood2017, @Pedersen2019). Esses modelos estatísticos permitem expressar a estrutura dos dados agregada por parcela de amostragem (@Pedersen2019) e descrever efeitos descritivos não lineares por splines e tensores de suas preditoras (@wood2017). Splines agem como "curvas ajustáveis" que se adaptam aos dados, controlando o grau de suavização para evitar sobreajuste através da penalização pela máxima verossimilhança restrita (@wood2017). O objetivo de splines e tensores é a descrição de qualquer relação contínua (@wood2017). Todas as análises estatísticas foram feitas usando linguagem R (@Rlang) e o pacote mgcv (REF).
</p>

<p>
Para a descrição da congruência com a SAD observada, a variável-resposta foi a proporções das 100 SADs simuladas classificadas como congruentes. A estrutura hierárquica do HGAM é dividida em duas: a variabilidade agrupada pela parcela amostrada que contém os splines do cenários de limitação de dispersão (k) por paisagens experimental (land), considerada aleatória; e a variabilidade relacionada com a população de todas as parcelas, que contem os splines dos efeitos médios de k por land, considerada fixa. Entre as preditoras da estrutura fixa também incluímos as coordenadas geográficas das parcelas amostradas, que possuem um spline para descrever a possível autocorrelação espacial entre as parcelas.
</p>

<p>Assim, a probabilidade de uma distribuição de abundância de espécies (SAD) simulada apresentar boa congruência com a SAD observada foi modelada utilizando 4 HGAM com diferentes níveis de complexidade. As formulas usadas para ajustar esses modelo estatísticos foram:

```{r modelos usados na descrição, eval=FALSE, echo=FALSE,include=FALSE}
library(mgcv)
f_gam <- \(vf,dfi){
  gam(formula=vf,
      family='binomial',
      data=dfi,
      method="REML")
}
l_f <- list()
# modelo cheio: conectividade + proximidade geográfica
l_f$`s(k,by=land) + (lat,long)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(lat,long) + 
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem coordenadas: apenas conectividade
l_f$`s(k,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  te(k,SiteCode,bs=c("cr","re"),by=land,id="random")
# modelo sem conectividade como efeito aleatório
l_f$`s(k,by=land) - te(k,plot,by=land)` <- 
  cbind(nSAD,100-nSAD) ~ 
  land +
  s(k,by=land,bs="cr",id="fixo") +
  s(SiteCode,bs="re")
# modelo sem conectividade como efeito fixo
l_f$`1` <- 
  cbind(nSAD,100-nSAD) ~ 
  1 +
  s(SiteCode,bs="re")
l_md <- lapply(l_f,f_gam,dfi=df_ad)
saveRDS(l_md,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
```


```{r cap tab desc md,echo=FALSE,include=TRUE,eval=TRUE}
vcap <- paste(
      "Description of the four competing hierarchical generalized additive models (HGAMs) ",
      "used to explain the probability of shape congruence between empirical and simulated ",
      "species abundance distributions. In all models, k represents the smooth of dispersal ",
      "limitation (i.e., the fraction of propagules retained in the immediate neighborhood ",
      "of the progenitor), and land denotes the experimental landscape. Models differ in the ",
      "inclusion of plot-level random effects, landscape-specific connectivity responses, ",
      "and explicit geographic structure."
    )
```
```{r tabdescmd,echo=FALSE,include=TRUE,eval=TRUE}
library(flextable)
library(dplyr)
# Criar data.frame com a descrição conceitual dos modelos
tab_models <- tibble::tibble(
  Model = c("M1 (full)",
            "M2 (no spatial coords)",
            "M3 (no plot-specific connectivity)",
            "M4 (null)"),
  
  `Fixed effects (connectivity)` = c(
    "Interaction of k and land",
    "Interaction of k and land",
    "Interaction of k and land",
    "Intercept only"
  ),
  
  `Random effects (plot-level)` = c(
    "Plot-specific interaction of k and land",
    "Plot-specific interaction of k and land",
    "Random intercept for plot",
    "Random intercept for plot"
  ),
  
  `Spatial coordinates` = c(
    "Bivariate smooth of latitude and longitude",
    "None",
    "None",
    "None"
  ),
  
  `Ecological interpretation` = c(
    "Congruence is described by connectivity, emerging from the interaction between dispersal and the landscape configuration, and by spatial proximity among forest plots.",
    "Congruence is described by connectivity, independent of geographic proximity",
    "Congruence is described by average connectivity effects, ignoring plot-specific dispersal–landscape interactions",
    "Congruence varies only among plots, without effects of dispersal or landscape"
  )
)

# Criar flextable
ft_models <- flextable(tab_models)

# Ajustes de formatação
ft_models <- ft_models |>
  set_header_labels(
    Model = "Model",
    `Fixed effects (connectivity)` = "Fixed effects",
    `Random effects (plot-level)` = "Random effects",
    `Spatial coordinates` = "Geographic space",
    `Ecological interpretation` = "Ecological meaning"
  ) |>
  autofit() |>
  align(align = "left", part = "all") |>
  bold(part = "header") |>
  valign(valign = "top", part = "body") %>% 
  set_caption(
    caption = vcap
  )

# Visualizar
ft_models
```




Os HGAM foram comparados usando métricas derivadas do ‘Akaike Information Criteria’ para amostras pequenas (AICc), o delta AICc e o peso de evidência (@burnham1998practical). Também incluímos o ‘deviance explained’ que pode ser interpretado de forma análoga ao coeficiente de determinação (R2), como forma de descrever a variabilidade explicada pelo modelo estatístico. Para essas tarefas foram utilizadas funções dos pacotes 'mgcv' (@wood2011) e 'bblme' (@bbmle_package).</p>


## Teste de autocorrelação espacial global I de Moran

<p>Uma vez que os splines são ideais para descrever relações contínuas, a autocorrelação espacial negativa pode não ser bem descrita pelo modelo estatístico, assim, incluímos um teste bicaudal de autocorrelação espacial dos resíduos dos modelos estatísticos. Se houver autocorrelação espacial que não foi bem descrita pelo modelo estatístico, esperamos que a média, por parcela, dos resíduos do modelo apresentem a estatística I de Moran diferente de zero. A estatística I de Moran varia entre -1 e 1, ou seja, entre a autocorrelação espacial negativa e positiva, respectivamente. E possui um teste de hipótese associado que avalia se o valor é significativamente diferente de zero, se o p valor for próximo de zero então a hipótese de ausência de autocorrelação espacial possui pouco suporte. A estatística I de Moran requer que um parâmetro livre seja escolhido. Determinamos esse valor por uma análise de sensibilidade dos resíduos dos modelos ajustados. Para obter a estatística I de Moran e seu p valor associado utilizamos funções do pacote spdep (@bivand2020). A avaliação da sensibilidade desse parâmetro está na figura \@ref(fig:fig-moranI).</p> 


```{r criacao da analise de sensibilidade de lmoranI,echo=FALSE,include=FALSE,eval=FALSE}
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
lmoranI <- lapply(l_md,f_MoranTest_GAMM_severalK)
# saveRDS(lmoranI,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong_lMoranI.rds")
f_ggplot <- \(vname){
  dfi <- lmoranI[[vname]]
  dfi %>% 
    mutate(k=as.numeric(k),
           label=f_label(vname)) %>% 
    ggplot(aes(x=k)) +
    geom_hline(color="darkgray",yintercept = 0) +
    geom_hline(linetype=2,aes(color="significance threshold (0.05)",
                              yintercept = 0.05)) +
    geom_line(aes(color="p-value",y=pvalue)) +
    geom_line(aes(color="Moran's I",y=MoranI_stat_res)) +
    scale_color_manual("",values=c("significance threshold (0.05)"="red",
                                   "p-value"="black",
                                   "Moran's I"="green")) +
    scale_y_continuous(breaks=c(-0.07,0,0.05,0.25,0.50,0.75,1),
                       limits=c(-0.08,1.001),
                       expand = c(0,0.01)) +
    labs(x="n-nearest neighbors",y="") +
    theme_bw() +
    facet_wrap(~label) +
    theme(legend.position = "top") 
}
lp <- lapply(names(lmoranI),f_ggplot)
library(patchwork)
pfinal <- wrap_plots(lp, nrow = 2) +
  plot_layout(guides = "collect") +
  plot_annotation(
    title = "Assessment of spatial autocorrelation",
    subtitle = "two-sided Moran's I"
  ) & 
  theme(legend.position = "top",
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = 10, hjust = 0.5, face = "bold"),
        plot.margin = margin(2, 0, 2, 0)) 
saveRDS(pfinal,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_moranI_sensibilidade.rds")
```
```{r cap sensibilidade moran, eval=TRUE,echo=FALSE,include=TRUE}
vcap <- do.call(sprintf, c(list("Sensitivity analysis of Moran's I test for spatial autocorrelation in model residuals. Panels show two-tailed p-values of Moran's I statistic calculated for mean residuals from two statistical models (left: %s, middle: %s, right: %s), grouped by forest plots. The x-axis represents neighborhood size defined as the number of nearest neighbors (n), ranging from 1 to 100. The y-axis shows corresponding p-values, with a horizontal dashed line indicating the significance threshold (α = 0.05). The absence of p-values below 0.05 across the entire range of neighborhood sizes indicates no significant spatial autocorrelation in the residuals of either model, suggesting that spatial structure was adequately captured by the model formulations."), names(l_f)[1:4]))
```
```{r fig-moranI,echo=FALSE,eval=TRUE,include=TRUE,fig.cap=vcap,fig.width=6, fig.height=8}
pfinal <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/p_moranI_sensibilidade.rds")
pfinal
```

## Tabela de comparação dos HGAM

```{r criacao da tabela final, include=FALSE,eval=FALSE,echo=FALSE}
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
df_tabsel <- f_TabSelGAMM(l_md,test_moranK = FALSE)
write_csv(df_tabsel,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv")
```

```{r}
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv") %>% 
  mutate(across(where(is.numeric), ~round(.x,2)),
         modelo=f_label(modelo))
f_flextable <- \(dfi){
  dfi %>% 
    flextable() %>%
    bg(bg = "white",part = "all") %>%
    theme_vanilla() %>% 
    set_header_labels(
      modelo = "HGAM",
      dAICc = "ΔAICc",
      df = "est. coef.",
      weight = "weight",
      dev.expl = "Dev. Exp.") %>%
    bold(part = "header") %>%
    colformat_num(digits = 2) %>% 
    align(align = "center", part = "all") %>% 
    autofit()
}
f_flextable(df_tabsel)
```

## Diagnostico HGAM mais plausivel

### Tabela do HGAM

```{r criacao da tabela do modelo mais plausivel,echo=FALSE,include=FALSE,eval=FALSE}
f_gsub <- \(vchar){
  gsub("ideal","_pristine",vchar) %>% 
    gsub("non_frag","_clumped",.) %>% 
    gsub("cont","_frag",.)
}
df_tabsel <- read_csv(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabsel_cong.csv")
hgam <- l_md[[df_tabsel$modelo[1]]]
tab_todisp <- as_flextable(hgam) %>% bg(., bg = "white", part = "all")
tosav <- tab_todisp %>% 
  set_formatter(Term = f_gsub) %>% 
  set_caption(caption = "Summary of the Generalized Additive Model (M1) coefficients and approximate significance of smooth terms.") %>% 
  autofit()
saveRDS(tosav,file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabmd_cong.rds")
```
```{r tabsel,}
tosav <- 
  readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/tabmd_cong.rds")
tosav
```

### Gráficos Diagnóstico do HGAM

```{r criação do diagnostico, eval=FALSE,include=FALSE,echo=FALSE}
l_md <- readRDS(file="1_to_compile_dissertacao_EM_USO/09_SI/RDS/lmd_cong.rds")
vname <- sapply(df_tabsel$modelo,f_antilabel)
hgam <- l_md[[vname["M1"]]]
new_data <- expand.grid(
  k = unique(df_ad$k),
  land = unique(df_ad$land),
  forest_succession = unique(df_ad$forest_succession),
  lat = 0,
  long = 0,
  SiteCode = "SPigua1"  # Replace with a fixed value
)
#
l_dfpred <- list()
l_dfpred$fixo_e_aleat <- md_sumario$model
l_dfpred$fixo_e_aleat[,1] <- l_dfpred$fixo_e_aleat[,1][,1]
names(l_dfpred$fixo_e_aleat)[c(1,3)] <- c("nSAD","forest_succession")
lpred <- predict(md_sumario,
                 type = "response", 
                 se.fit = TRUE)
l_dfpred$fixo_e_aleat$fit <- lpred$fit
l_dfpred$fixo_e_aleat$se <- lpred$se.fit
l_dfpred$fixo_e_aleat <- mutate(
  l_dfpred$fixo_e_aleat,
  lower = fit - 1.96 * se,
  upper = fit + 1.96 * se,
  forest_succession = gsub("cont.","",forest_succession) %>% 
    gsub("ideal.","",.) %>% gsub("non_frag.","",.)
)
#
l_dfpred$fixo <- expand.grid(
  k = unique(df_ad$k),
  land = unique(df_ad$land),
  forest_succession = unique(df_ad$forest_succession),
  lat = 0,
  long = 0,
  SiteCode = "SPigua1"
)
lpred <-  predict(md_sumario,
                  newdata=l_dfpred$fixo,
                  type = "response",
                  exclude=c("s(lat,long)",
                            "te(k,SiteCode):landcont",
                            "te(k,SiteCode):landideal",
                            "te(k,SiteCode):landnon_frag"),
                  se.fit = TRUE)
l_dfpred$fixo$fit <- lpred$fit
l_dfpred$fixo$se <- lpred$se.fit
l_dfpred$fixo <- mutate(
  l_dfpred$fixo,
  lower = fit - 1.96 * se,
  upper = fit + 1.96 * se
)
#######
l_dfpred <- lapply(l_dfpred,\(dfi){
  mutate(dfi,across(fit:upper,~.x*100),
         land=factor(land,
                     levels=c("cont",
                              "non_frag",
                              "ideal"),
                     labels=c("fragmentada",
                              "aglomerada",
                              "prístina")),
         pert_class = factor(forest_succession,
                             levels=c("primary",
                                      "primary/secondary",
                                      "secondary"),
                             labels=c("baixa",
                                      "mediana",
                                      "alta"))
         ) %>% 
    select(-forest_succession,-lat,-long) %>% 
    relocate(pert_class,.after="k")
})
saveRDS(l_dfpred,file = "dados/csv_SoE/rds/l_dfpred_md_cong_absoluta.rds")
library(hexbin)
p <- l_dfpred$fixo_e_aleat %>% 
  ggplot(aes(x=k,y=nSAD)) +
  # geom_point(alpha=0.3) +
  geom_line(aes(y=fit,group = SiteCode),alpha=0.3) +
  # geom_boxplot(aes(group=k),alpha=0.6) +
  geom_ribbon(data=l_dfpred$fixo,
              aes(x=k,y=fit,ymin=lower,ymax=upper),
              color="blue",
              fill="lightblue") +
  geom_line(data=l_dfpred$fixo,
            aes(x=k,y=fit),
            color="darkred") +
  geom_hex(bins = 50,alpha=0.5) + 
  scale_fill_gradient("contagem",low = "gray", high = "black", na.value = NA) +
  scale_x_continuous(expand = c(0.01, 0)) +
  scale_y_continuous(expand = c(0.01, 0)) +
  labs(x="Proporção de propágulos na vizinhança imediata (k)",
       y="número de SAD simuladas com boa congruência com o observado (nSAD)",
       title="Descrição da congruência absoluta da SAD simulada nas paisagens hipotéticas",
       subtitle="HGAM: nSAD ~ s(k,by=interaction(paisagem hipotética, classe de perturbação) + s(lat,long) + te(k,Sítio,by=paisagem hipotética)") +
  facet_grid(pert_class ~ land) +
  theme(strip.text = element_text(size=12, #margin=margin(),
                                  face="bold"))
ggsave(filename="figuras/descricao_congruencia_absoluta.png",
       p,height = 7.33,width = 13.8)
library(magick)
img <- image_read("figuras/descricao_congruencia_absoluta.png") %>% 
  image_resize("50%") %>% 
  image_trim()
image_write(img,path = "figuras/descricao_congruencia_absoluta.png")
```


## Interpretação pelo HGAM mais plausível

# Implicações para a estimativa de efeitos da paisagem


