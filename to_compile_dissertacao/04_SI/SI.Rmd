
```{r setup4,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE,cache=TRUE)
# pacotes
library(dagitty)
library(ggdag)
library(gt)
library(gratia)
library(sads)
library(doMC)
library(metR)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(MuMIn)
library(AICcmodavg)
library(insight)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(data.table)
library(plyr)
library(dplyr)
source("source/nameModel.R")
source("source/GAMMtools.R")
source("source/general_tools.R")
figHeight=28
figWidth=40
# dados
# df_dados_disponiveis
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv")
# df_p
df_p <- read_csv("dados/df_p.csv")
# df_resultMNEE
df_resultados <- read_csv("dados/csv/resultados_MN/df_resultados.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv")
# df_Urep
df_Urep <- list.files(path = "dados/csv/taxaU/MNEE", pattern = ".csv",recursive = T,full.names = T) %>%  
  adply(.,1,data.table::fread,.id=NULL) %>% na.omit()
# df_U
df_U <- data.table::fread("dados/csv/taxaU/df_U.csv")
# df_contrastes
df_contrastes <- fread("dados/csv/taxaU/df_contrastes.csv")
# df_ad: dados completos, com todos os logOR e as proporções observadas para os 3 e as preditoras
f_z <- function(x) (x-mean(x))/sd(x)
df_ad <- df_resultados |>
  arrange(p) |> 
  inner_join(distinct(select(df_sim,SiteCode,Ntotal:S_obs)),"SiteCode") |> 
  mutate(diffS = (Smed - S_obs)/S_obs)
# df_contrastes: contrastes por sítio e grau de limitação de dispersão
df_contrastes <- fread(file="dados/csv/taxaU/df_contrastes.csv") |> 
  inner_join(df_sim |> select(SiteCode,Ntotal:S_obs) |> distinct(),
             by="SiteCode") |> 
  rename(N=Ntotal,S=S_obs) |> 
  mutate(across(N:S,log,.names="log.{.col}"),
         across(c(p,k,log.N:log.S),f_z,.names = "{.col}_z"),
         SiteCode = factor(SiteCode)) |> 
  select(-c(N:log.S))
# df_md: dados necessários 
df_md <- df_ad |> 
  inner_join(df_contrastes |> 
               select(SiteCode:efeito_conf) |> 
               mutate(across(.cols=c(p,k,contains("efeito")),f_z,.names="{.col}_z")) |> 
               select(-c(p,efeito_area:efeito_conf)) |> 
               pivot_longer(starts_with("efeito_"),names_to="logOR_pair",values_to="contraste_z") |> 
               mutate(logOR_pair = case_when(logOR_pair == "efeito_area_z" ~ "non_frag.ideal",
                                             logOR_pair == "efeito_frag_z" ~ "cont.non_frag",
                                             TRUE ~ "cont.ideal")),
             by=c("SiteCode","k","logOR_pair")) |> 
  mutate(SiteCode = factor(SiteCode),
         land_hyp = factor(land_type),
         contrasteSAD_z = f(logOR_value)) |> 
  select(-land_type) |> 
  rename(nCong=nCongKS)
  # df_newdata
fwrite(df_md,"dados/csv/df_md_logOR.csv")
df_newpred <- fread(file="dados/csv/df_newpred.csv") |> 
  select(-starts_with("log_"))
# df_pred
# df_pred <- read_csv("dados/csv/resultados_MN/MNEE/df_pred.csv")
# df_newdat <- expand.grid(p_z = seq(min(df_ad$p_z),max(df_ad$p_z), length=150),
#                          k_cont_z = seq(min(df_ad$k_cont_z),max(df_ad$k_cont_z), length=150))
# df_newdat <- adply(df_newdat,1,.fun = \(x) cbind(x,distinct(select(df_ad,SiteCode,log_S_obs_z,log_Ntotal_z))))
# write_csv(df_newdat,"dados/csv/df_newdataSADs.csv")
#
# df_intePred_contrastes.csv
df_intPred <- fread("dados/csv/df_intePred_contrastes.csv")
# df_congContrastetsREP.cvs
df_congContrastes <- fread("dados/csv/resultados_MN/df_congContrastes.csv") |> 
  inner_join(df_md |> 
               select(SiteCode,p,k,logOR_pair,contraste_z),
             by=c("SiteCode","k","pair" = "logOR_pair")) |> 
  arrange(p) |> 
  relocate(p,.after=k) |> 
  mutate(SiteCode = factor(SiteCode))
# loads
# load("dados/Rdata/l_md.contrastes.Rdata")
# load("dados/Rdata/md_frag_area.Rdata")
# load("dados/Rdata/l_md_congContrastes.Rdata")
# load("dados/Rdata/l_md_PrCong.Rdata")
df_plot <- df_md |> select(SiteCode:nCong,p_z:k_z) |> 
  inner_join(df_p) |> 
  inner_join(df_dados_disponiveis |> 
               filter(forest_succession != "capoeira") %>% 
               select(SiteCode, forest_succession)) %>% 
  arrange(p) |> 
  mutate(succession = case_when(forest_succession == "primary" ~ "1°",
                                forest_succession == "secondary" ~ "2°",
                                forest_succession == "primary/secondary" ~ "1.5°"),
         label = paste0(SiteCode,", p=",round(p,2)," ,suc=",succession),
         k_f=factor(round(k,2))) %>% 
  select(-succession)
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
#
df_tif_txt <- read.csv(file="./dados/csv/df_txt_tif_landscape_paths.csv")
```

```{r trackdown chunk SI, include=FALSE,eval=FALSE}
# pacotes
library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
# upload_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
#             gpath = "mestrado/artigo_principal/apendices/",
#             hide_code = TRUE)
update_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
            gpath = "mestrado/artigo_principal/apendices/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file = "secoes_texto/Resultados/Resultados.Rmd",
              gpath = "mestrado/artigo_principal/secoes_texto/")
```


<!-- # Texto e tabelas -->

<!-- Todas as análises dos dados foram feitas em R (REF). -->

<!-- ## GLMM binomial -->

<!-- Utilizamos funções do pacote lme4 (REF) para ajustar os GLMM binomiais. O modelo com estrutura aleatória mais complexa, com 1 intercepto e 1 inclinação no grau de limitação de dispersão por sítio de amostragem e tipo de paisagem hipotética, teve alerta de não convergência e mesmo depois de ajustar com outros otimizadores o alerta permaneceu. Como era um modelo que demorava muito para ajustar não fiz mais explorações com ele. Outro modelo explorado e descartado foi o modelo cheio que interpretava o grau de limitação de dispersão como variável categórica. Esse modelo demorou muito para rodar e sua execução foi interrompida antes de terminar a estimativa dos coeficientes. -->
<!-- A tabela de seleção, com o delta AICc e peso de evidência, foi obtida usando a função AICctab do pacote bbmle (REF) e os coeficientes de determinação foram obtidos usando a função r.squaredGLMM do pacote MuMIn (REF). -->
<!-- Avaliamos a qualidade de ajuste do modelo explorando os resíduos quantílicos (FIGURA A2 REF) usados no pacote DHARMa (REF). Também plotamos o predito e o observado (FIGURA A2 REF). -->

<!-- # Figuras  -->



## Paisagens Contemporâneas
```{r caption 2}
cap <- "Paisagens contemporâneas (4x4 km2) aos eventos de amostragem da SAD na área amostrada. Mapas de cobertura da coleção 6 do mapbiomas."
```
```{r fig-contempLandscape,fig.cap=cap,fig.pos="H",fig.width=figWidth,fig.height=figHeight}
v_pngfiles <- list.files(path="./dados/paisagens/png_land_sim/",pattern=".png",full.names = TRUE)
l_p <- v_pngfiles %>% ll_ggpng()
grid.arrange(grobs=l_p,ncol=10)
```


\newpage

```{r preditoras empiricas criacao codigo,eval=FALSE,include=FALSE}
# ajuste dos modelos
df_md <- df_plot %>% select(SiteCode,forest_succession,p) %>% distinct() %>% 
  mutate(logit_p = car::logit(p=p))
l_md <- list()
l_md[[1]] <- lm(formula = logit_p ~ forest_succession,data = df_md)
l_md[[2]] <- lm(formula = logit_p ~ 1,data = df_md)
names(l_md) <- c("~forest suscession","~1")
# construção dos dados
## tabela de seleção
df_AICctab <- AICctab(l_md,weights=TRUE) %>% as.data.frame()
df_AICctab$modelo <- row.names(df_AICctab)
md_p_fsc <- l_md[[row.names(df_AICctab)[1]]]
row.names(df_AICctab) <- NULL
df_AICctab$R2 <- sapply(l_md,\(x) summary(x)$adj.r.squared)
df_AICctab <- df_AICctab %>% relocate(modelo) %>% mutate(across(2:5,\(x) round(x,digits=3)),
                                                         R2 = R2*100) %>% 
  rename(`R2(%)`=R2)
## tabela do modelo mais plausível
df_plot1 <- broom::tidy(md_p_fsc) %>% 
  mutate(`IC upp` = estimate + std.error,`IC low` = estimate - std.error) %>% 
  select(-c(std.error:p.value)) %>% 
  mutate(across(c(-term),\(x) exp(x)/(1+exp(x)))) %>% 
  pivot_longer(-term) %>% 
  rename(forest_succession = term) %>%
  mutate(forest_succession = case_when(forest_succession == "(Intercept)" ~ "primary",
                                       forest_succession == "forest_successionprimary/secondary" ~ "primary/secondary",
                                       TRUE ~ "secondary"))
df_table <- broom::tidy(md_p_fsc) %>% 
  mutate(`IC upp` = estimate + std.error,`IC low` = estimate - std.error) %>% 
  select(-c(std.error:statistic)) %>%
  mutate(across(c(-term,-p.value),\(x) exp(x)/(1+exp(x)))) %>% 
  rename(`forest succession` = term) %>%
  relocate(p.value,.after = last_col()) %>% 
  mutate(`forest succession` = case_when(`forest succession` == "(Intercept)" ~ "primary",
                                         `forest succession` == "forest_successionprimary/secondary" ~ "primary/secondary",
                                          TRUE ~ "secondary")) %>% 
  mutate(across(2:4,\(x) round(x,3)))
df_p2 <- data.frame(x = rep(1:3,1),
                    y_0 = df_plot1 %>% filter(name=="IC low") %>% pull(value),
                    y_1 = df_plot1 %>% filter(name=="IC upp") %>% pull(value))
# obj para ggplot2
v_colors <- c("black",rep("darkred",2))
names(v_colors) <- df_plot1$name %>% unique()
# gráficos
library("ggpmisc")
l_p <- list()
l_p[[1]] <- ggplot() + theme_void() + annotate(geom="table",x=1,y=1,label = list(df_AICctab)) + 
  labs(title="Seleção de Modelos",subtitle = "~N(logit(p),sd)") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 0),
        plot.subtitle = element_text(hjust = 0.5, vjust = 0))
l_p[[2]] <- df_plot %>% 
  ggplot(aes(x=forest_succession,y=p)) +
  geom_jitter(alpha=0.6) +
  geom_point(data=df_plot1,aes(x=forest_succession,y=value,color=name),shape="_",size=15) +
  geom_segment(data = df_p2,aes(x=x,xend=x,y=y_0,yend=y_1,group=x)) +
  scale_color_manual(values=v_colors) +
  geom_vline(xintercept = c(1.5,2.5)) + 
  theme(legend.title = element_blank(),
        legend.position = "top",
        legend.margin = margin(0, 0, 0, 0),
        legend.box.spacing = unit(0, "pt"),
        plot.title = element_text(hjust = 0.5, vjust = -1),
        axis.title.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(size=1))) +
  labs(x="classe de sucessão",title="Modelo mais plausível")
l_p[[3]] <- ggplot() +
  theme_void() +
  annotate(geom = "table",
           x = 1,
           y = 1,
           label = list(df_table)) + labs(title="Coef. modelo mais plausível") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 0))
save(l_p,file="./figuras/figSI2_relacaoPredEmp_normal_logit_p.Rdata")
load(file="./figuras/figSI2_relacaoPredEmp_normal_logit_p.Rdata")
grid.arrange(grobs=l_p,layout_matrix=rbind(c(1,3,3),
                                           c(2,2,2),
                                           c(2,2,2),
                                           c(2,2,2),
                                           c(2,2,2)),
             top="PREDITORAS EMPÍRICAS")
```
```{r caption preditoras empiricas}
cap <- "Modelos Lineares Gaussianos da relação entre as preditoras empíricas (p e classe de sucessão). A estimativa da média de p diferem entre as classes de sucessão. Para ajustar os modelo normais p foi transformada usando a função logito."
```
```{r preditoras-empiricas-SI,fig.cap=cap,fig.pos="H"}
p <- ll_ggpng("./figuras/figSI_2.png")[[1]]
p
```


\newpage

## Predito para o contraste na taxa U entre paisagens

```{r ip contrastes ~ p k 2,fig.height=figHeight,fig.width=figWidth,eval=FALSE,include=FALSE}
df_plot <- df_intPred |> 
  mutate(p = p_z*sd(df_ad$p) + mean(df_ad$p),
         k = k_z*sd(df_ad$k) + mean(df_ad$k),
         name=factor(name,levels=paste0("efeito_",c("area","frag","contemp")))) |> 
  select(-contains("_z"),-predito) |> 
  pivot_longer(starts_with("Q_0."),values_to = "pred",names_to = "label")
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label)[c(3,2,4,1,5)])
# gráficos
v_range <- range(df_plot$pred)
v_breaks1 <- c(-0.2,0,0.2,0.5,1)
f_plot <- function(df){
  f_ggplot <- function(df,facets=2){
  ggplot(df,aes(x=p,y=k,z=pred,fill=pred)) +
    geom_raster() +
    geom_contour(aes(z=pred),
                 size=0.5,color="darkblue",
                 breaks=v_breaks1) +
    geom_text_contour(aes(z=pred),
                      breaks=v_breaks1,
                      label.placer = label_placer_flattest()) +
    scale_fill_gradient2(low="green",
                         mid="red",
                         high="black",
                         midpoint = 0.5,
                         limits=v_range,
                         # round(seq(v_range[1],v_range[2],length.out = 5)[1:4],2)
                         breaks=v_breaks1) +
    scale_y_reverse() +
    theme_classic() +
    guides(fill = guide_colourbar(title = gsub("efeito_","",df$name[1]))) +
    coord_cartesian(expand = FALSE) +
    labs(fill=df$name[1]) +
    facet_wrap(~label,ncol = facets,scales="free")
  }
  l_p <- list()
  l_p[[1]] <- df |> 
    filter(label == "Q_0.5") |>
    f_ggplot() + labs(x="")
  l_p[[2]] <- df |> 
    filter(label != "Q_0.5") |>
    f_ggplot()
  ggpubr::ggarrange(plotlist = l_p,nrow=2, common.legend = TRUE, legend="top")
}
l_plot <- dlply(df_plot,"name",f_plot)
p <- grid.arrange(grobs=l_plot,ncol=3)
ggsave("figuras/FigFinal_contrastes.png",p,
       width = 13,
       height = 9)
```
```{r}
cap <- "Predito para os contrastes na taxa U entre paisagens hipotéticas. Para cada sítio e grau de limitação de dispersão foi calculada a diferença entre a média da taxa U entre pares de paisagens hipotéticas e então dividido pela média na paisagem idealizada. Os contrastes são: área (sem fragmentação -  idealizado); fragmentação per se (contemporâneo - sem fragmentação); contemporaneidade (contemporâneo - idealizado). Um GAMM com distribuição normal foi ajustado aos contrastes observados (com splines indivíduais para p e k, tensor entre p e k, e com splines aleatórios de k para cada sítio de amostragem), o intervalo de predição foi construído pressupondo que os coeficientes do GAMM podem ser bem aproximados por uma normal multivariada e então 10 mil sorteios foram feitos dessa normal multivariada e para cada uma foi obtido uma predição. Na figura há os quantis da distribuição de predições."
```
```{r contrastes-taxaU,fig.cap=cap}
p <- ll_ggpng("figuras/FigFinal_contrastes.png")[[1]]
p
```




<!-- antigo -->

```{r include=FALSE,eval=FALSE}
cap <- "Gráficos diagnósticos"
```
```{r fig-DHARMaResidual,fig.cap=cap,fig.pos="H",include=FALSE,eval=FALSE}
oname <- load(file="./dados/Rdata/glmm_nCong_selecionado.Rdata",verbose = TRUE)
l_md_e_start <- get(oname)
p_plot <- simulateResiduals(l_md_e_start$modelo,n = 1000)
plot(p_plot)
```

```{r caption 3,include=FALSE,eval=FALSE}
cap <- "Observado e predito para o número de SADs simuladas congruentes com a SAD observada."
```
```{r fig-preditoObs,fig.cap=cap,fig.pos="H",include=FALSE,eval=FALSE}
oname <- load(file="./dados/Rdata/glmm_nCong_selecionado.Rdata",verbose = TRUE)
l_md_e_start <- get(oname)
df_obs <- l_md_e_start$modelo@frame[,-1]
df_obs$nCong <- l_md_e_start$modelo@frame[,1][,1]
df_obs$predito <- predict(l_md_e_start$modelo,type="response")*sum(l_md_e_start$modelo@frame[,1][1,])
df_obs %>% 
  ggplot(aes(x=nCong,y=predito,group=SiteCode)) +
  geom_line(alpha=0.4) +
  geom_point(alpha=0.4) +
  geom_abline(intercept = 0,slope=1,color="red")+
  facet_grid(land_hyp~forest_succession)
```
