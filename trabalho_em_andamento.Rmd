---
title: "Trabalho em Andamento"
author: "Danilo Pereira Mori"
date: "2024-02-26"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# 13ago2024

```{r}
library(dagitty)
library(ggdag)
library(ggplot2)
library(dplyr)

# Create the DAG
cov_dag_with_coords <- dagify(
  local ~ paisagem + biogeo + preservacao_local,
  paisagem ~ biogeo + U,
  preservacao_local ~ U,
  labels = c(
    "local" = "biodiv. local",
    "paisagem" = "efeito paisagem",
    "preservacao_local" = "preserv. local",
    "biogeo" = "Reg. biogeo.",
    "U" =  "unobs. cov."
  ),
  latent = "U",
  exposure = "paisagem",
  outcome = "local",
  coords = list(
    x = c(paisagem = 1, biogeo = 3, preservacao_local = 1.5, local = 2, U = 2.5),
    y = c(paisagem = 2, biogeo = 2, preservacao_local = 3, local = 1, U = 3)
  )
)
tidy_cov_dag <- tidy_dagitty(cov_dag)
p <- ggdag_adjustment_set(tidy_cov_dag, shadow = TRUE,text = FALSE,
                     exposure = "paisagem", 
                     outcome = "local",node = FALSE,
                     use_labels = NULL) +
  geom_dag_point(aes(fill = label, color=label), size = 10) + 
  # geom_dag_edges() +
  geom_dag_text(aes(label = label), color = "black", size = 5) +  # Display labels on the plot
  scale_fill_manual(values = c(
    "efeito paisagem" = "red", 
    "biodiv. local" = "green", 
    "unobs. cov." = "gray",
    "Reg. biogeo." = "skyblue",
    "preserv. local" = "skyblue")) +
  scale_color_manual(values = c(
    "efeito paisagem" = "red", 
    "biodiv. local" = "green", 
    "unobs. cov." = "gray",
    "Reg.biogeo." = "skyblue",
    "preserv. local" = "skyblue"))




ggdag(cov_dag_with_coords, text = FALSE, use_labels = "label") +
  geom_dag_point(aes(fill = status), size = 10) +
  geom_dag_edges() +  # Automatically use coordinates from the DAG
  geom_dag_text(aes(label = label), color = "black", size = 5) +
  scale_fill_manual(values = c("exposure" = "red", "outcome" = "green", "adjusted" = "skyblue", "unadjusted" = "lightgray", NA = "white")) +
  scale_color_manual(values = c("exposure" = "darkred", "outcome" = "darkgreen", "adjusted" = "blue", "unadjusted" = "gray", NA = "white")) +
  theme_dag()

ggdag_adjustment_set(tidy_cov_dag,shadow = TRUE,
                     exposure = "paisagem", outcome = "local",
                     use_labels = c(
                       "local" = "biodiv. local",
                       "paisagem" = "efeito paisagem",
                       "preservacao_local" = "preserv. local",
                       "biogeo" = "Reg.biogeo.",
                       "U" =  "unobs. cov."
                     ))


p <- ggdag_status(tidy_cov_dag, exposure = "paisagem", outcome = "local")
p$data <- p$data %>% 
  mutate(status = as.character(status),
         status = ifelse(is.na(status), "adjusted", status),
         status = factor(status, levels = c("exposure", "outcome", "latent", "adjusted")))
p + 
  geom_dag_point(aes(fill = status), size = 10) +  # Use 'status' in fill, not 'label'
  geom_dag_edges() +
  geom_dag_text(aes(label = label), color = "black", size = 5) +
  scale_fill_manual(
    values = c(
      "exposure" = "red", 
      "outcome" = "green", 
      "latent" = "gray",
      "adjusted" = "skyblue"
    ),
    breaks = c("exposure", "outcome", "latent", "adjusted")  # Ensure all levels appear
  ) +
  guides(fill = guide_legend(override.aes = list(shape = 21)))
dag_data <- ggplot_build(p)$data
dag_data <- p$data
# head(dag_data)


ggdag_status(tidy_cov_dag, exposure = "paisagem", outcome = "local")  +
  geom_dag_point(aes(fill = label), size = 10) +
  geom_dag_edges() +
  geom_dag_text(aes(label = label), color = "black", size = 5) +  # Add labels for nodes
  scale_fill_manual(values = c(
    "exposure" = "red", 
    "outcome" = "green", 
    "adjusted" = "skyblue", 
    "unadjusted" = "lightgray")) +
  scale_color_manual(values = c(
    "exposure" = "darkred", 
    "outcome" = "darkgreen", 
    "adjusted" = "blue", 
    "unadjusted" = "gray")) +
  theme_dag()

```



# 9ago2024

SCORE:
-> BUROCRACIAS MESTRADO
- agilização do 3o comitê: o que apresentar?
Entendo que podemos dividir o argumento em duas partes: da introdução até os resultados e da discussão até a conclusão. Então gostaria de que o terceiro comitê fosse sobre esse ponto de contato entre essas duas partes.
Me proponho a apresentar o suficiente da introdução para que os resultados sejam compreendidos e então gostaria de conversar sobre os caminhos que penso para a discussão. 



-> TRABALHO DE VERDADE NA DISSERTAÇÃO
- finalização dos resultados: 
a) criação de figuras e tabelas
1) Qual o status dos resultados?
2) 

b) texto explicando os resultados




# 1ago2024

Apresentação das tabelas:
Esquema proposto



# 31/07/2024

Por algum motivo não foi possível utilizar o output de predict.gam informando novos coeficientes, vou tentar utilizar


# 27 jul 2024

```{r}
coef_samples <- MASS::mvrnorm(n=nsim, mu=coef(gamm), Sigma=vcov(gamm))
predictions <- matrix(NA, nrow=nsim, ncol=nrow(data))
f_adply <- \(i){
  coef_i <- coef_samples[i,]
  predictions[i,] <- 
    predict(gamm, newdata=data, type="link", se.fit=FALSE, new.coef=coef_i,exclude=v_exclude)
  return(predictions)
}
predictions <- adply(1:nrow(predictions),1,f_adply,.parallel = TRUE)

df_pred <- apply(predictions,2,\(X) quantile(X,probs = quantiles)) %>% 
    as.data.frame()
  names(df_pred) <- paste0("Q_",quantiles)
  cbind(data,df_pred)
# exemplo do chatgpt
prediction_median <- apply(predictions, 2, median)
prediction_lower <- apply(predictions, 2, function(x) quantile(x, 0.025))
prediction_upper <- apply(predictions, 2, function(x) quantile(x, 0.975))

to_exclude = c("s(lat,long)",
               "s(data_year)")

nsim <- 100
for (i in 1:nsim) {
    coef_i <- coef_samples[i,]
    predictions[i,] <- predict(gamm, newdata=data, type="link", se.fit=FALSE, new.coef=coef_i)
}


dfmd <- gamm$model
dfmd$lat <- 0
dfmd$long <- 0

# Predict using the modified data frame
predictions <- predict.gam(gamm,
                           newdata = dfmd,
                           type = "link",
                           se.fit = TRUE)

# Check the predictions
print(predictions)
```
```{r}
df_newpred$pred <- 
      predict.gam(gamm, 
              newdata=df_newpred, 
              type="link", se.fit=FALSE, exclude=to_exclude)


matrix_lprediction <- predict(gamm,
                              type="lpmatrix",
                              exclude = to_exclude,
                              newdata= df_newpred,
                              newdata.guaranteed=TRUE)   
predict_link <- matrix_lprediction %*% t(coef_samples)
  df_pred <- t(apply(predict_link,1,\(X) quantile(X,probs = quantiles))) %>% 
    as.data.frame()
  names(df_pred) <- paste0("Q_",quantiles)
  cbind(data,df_pred)
```



# 25 jul 2024

Como plotar os efeitos parciais aleatórios? Melhor forma acredito que é fazer a predição a posteriori. Dúvida,
É possível fazer a predição a posterior dos efeitos aleatórios da paisagem? Acredito que se for pelo método gi certamente, agora se for pelo método gs eu já não sei dizer mesmo.

Quais são as CPF?
- fazer a tabela de seleção da 2a parte da análise de dados 



# 14 jul 2024

Moran test for spatial autocorrelation


```{r}
library(spdep)

# Example data
set.seed(123)
data <- data.frame(
  latitude = runif(100, -90, 90),
  longitude = runif(100, -180, 180),
  residuals = rnorm(100)
)

# Create coordinates matrix
coordinates <- as.matrix(data[, c("latitude", "longitude")])

# Define a range of k values (must be positive integers)
k_values <- 1:50
moran_results <- data.frame(k = k_values, Moran_I = NA, p_value = NA)

# Loop through k values and compute Moran's I
for (i in seq_along(k_values)) {
  k <- k_values[i]
  nb <- knn2nb(knearneigh(coordinates, k = k))
  listw <- nb2listw(nb)
  moran_test <- moran.test(data$residuals, listw)
  moran_results$Moran_I[i] <- moran_test$estimate[["Moran I statistic"]]
  moran_results$p_value[i] <- moran_test$p.value
}

# Plot the results
library(ggplot2)
ggplot(moran_results, aes(x = p_value, y = Moran_I,color=k)) +
  geom_line() +
  geom_point() +
  # labs(title = "Moran's I vs. k", x = "Number of Nearest Neighbors (k)", y = "Moran's I") +
  theme_minimal()

```

```{r}
library(spdep)
dfmd <- md$model
dfmd$residuals <- residuals(md)
dfmd_avgbySite <- dfmd %>% 
  group_by(SiteCode) %>% 
  summarise(mean_res = mean(residuals),
            lat = first(lat),
            long = first(long)) %>% 
  ungroup()
# Prepare spatial data
coordinates <- dfmd_avgbySite[, c("lat","long")]
coordinates <- as.matrix(coordinates)
nb <- knn2nb(knearneigh(coordinates, k=4))  
listw <- nb2listw(nb)
# Calculate Moran's I for residuals
moran_output <- moran.test(dfmd_avgbySite$mean_res, listw)
data.frame(
  Statistic = c(
    "Moran I statistic", 
    "Expectation", 
    "Variance", 
    "Standard Deviate", 
    "p-value"
    ),
  Value = c(
    moran_output$estimate[["Moran I statistic"]], 
    moran_output$estimate[["Expectation"]], 
    moran_output$estimate[["Variance"]], 
    moran_output$statistic, 
    moran_output$p.value
    )
) %>% pivot_wider(names_from=Statistic,values_from = Value)
```




# 21jun2024

```{r}
df_aud <- df_contrastes %>%
  select(SiteCode:p, contains("_logratio")) %>% 
  mutate(across(-SiteCode,f_z,.names = "{.col}_z"))
l_p <- list()
l_p$padrao <- 
  df_aud %>% 
  ggplot(aes(x=area_logratio_z,y=frag.total_logratio_z)) +
  geom_point() +
  labs(title="Escala Padrão") +
  geom_abline(slope=1,intercept = 0,color="darkred") +
  theme(aspect.ratio = 1)
l_p$z <- 
  df_aud %>% 
  ggplot(aes(x=area_logratio_z,y=frag.total_logratio_z)) +
  geom_point() +
  labs(title="z transformada") +
  geom_abline(slope=1,intercept = 0,color="darkred") +
  theme(aspect.ratio = 1)
grid.arrange(grobs=l_p,nrow=1)
df_aud %>% 
  select(area_logratio,frag.total_logratio) %>% 
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(x=name,y=value)) +
  geom_boxplot() +
  geom_jitter()

```



# 20jun2024

```{r}
df_logOR %>% 
  select(-matches("^k|^p(!pristine)")) %>% 
  pivot_longer(cols = c("itself","pristine","numerator","denominator"),
               values_to="logOR",
               names_to="taxaU") %>% 
  mutate(taxaU = factor(taxaU,
                        levels=c("itself","pristine","numerator","denominator"))) %>% 
  ggplot(aes(x=Uefeito,y=logOR,color=taxaU,group=SiteCode)) +
  geom_hline(yintercept = 0,color="gray") +
  geom_vline(xintercept = 0,color="gray") +
  geom_line(alpha=0.2) +
  geom_point(alpha=0.2) +
  scale_color_manual(values=c("darkred","darkgreen","darkblue","darkorange")) +
  facet_grid(taxaU~contraste)
```



# 17/jun/2024

Os modelos para descrever os GAMMS pareciam precisar de maior grau de liberdade para descrever os padrões por sítios de amostragem. Interpretei que os dados sugerem que no caso 




# 15/06/2024

```{r}
v_num_itself <- dfi[dfi$taxaU==unname(cpair["numerador"]),
    c("SiteCode","k",cpair["numerador"],"taxaU")] %>% pull(contemp)
v_deno_itself <- dfi[dfi$taxaU==unname(cpair["denominador"]),
    c("SiteCode","k",cpair["denominador"],"taxaU")] %>% pull(ideal)
v_itself <- v_num_itself - v_deno_itself


dfi %>% head
dfi %>% filter(taxaU==uname(cpair["ideal"])) %>% pull(contemp)


```




# 4 mar 2024

Revisão dos resultados para avaliação da adequação


# 27fev2024




# 26fev2024

Anteriormente, 
simulei as SADs preditas nas paisagens contemporâneas e aglomeradas. Agora irei continuar as análises das SADs preditas nas paisagens contemporânea e aglomerada com o U prístino. 

Ontem fiz o pedido de prorrogação por conta da influência da pandemia.