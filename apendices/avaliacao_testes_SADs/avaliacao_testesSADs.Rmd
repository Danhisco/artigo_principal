---
title: "SADs neutras"
author: "Mori, Danilo"
date: "19/11/2022"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = FALSE,message = FALSE,warning = FALSE)
# pacotes
library(twosamples)
library(sads)
library(doMC)
library(ggpmisc)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(insight)
library(bbmle)
library(DHARMa)
library(lme4)
library(plyr)
library(dplyr)
# dados
# df_p
df_p <- read_csv("dados/df_p.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv") |> 
  select(-(tif.path:d)) |> distinct()
# df_SADrep
df_SADrep <- mutate(data.frame(
  SADrep.path = list.files(path = "dados/csv/SADs_neutras/MNEE",
                           pattern = ".csv",full.names = T)),
  SiteCode = str_extract(SADrep.path,"(?<=EE\\/).*?(?=.csv)")) |> 
  inner_join(df_sim,by="SiteCode") |> 
  inner_join(df_p,by="SiteCode")
```

# Introdução

Os testes calculam o valor p, a probabilidade de obter um valor da estatística de interesse tão extremo quanto aquela observada dado que a hipótese nula é verdadeira. A hipótese nula afirma que as SADs são amostras de uma mesma distribuição teóricas. Para as SADs réplicas de uma mesma bateria de simulações a hipótese nula é verdadeira, portanto, essas SADs podem ser usadas para avaliar se os possíveis vieses dos testes usados, KS e DTS, com relação às possíveis variáveis de interesse: Ntotal, p, S máxima do par, diffS do par de SADs amostradas. A expectativa é que todo par de SADs replicas de uma mesma bateria de simulação sempre tenha probabilidade próxima de 1 de ter um valor p>0.05. 

# Métodos

Obtenção dos dados. Para cada bateria de simulações, formei 200 pares únicos entre réplicas e comparei usando o teste KS e o teste DTS. A formação dos pares únicos seguiu o protocolo: selecionar as SADs réplicas com indices de 1 até 20, então para cada uma foram sorteadas 10 indices acima de seu próprio indice. Contabilizei o número de comparações em que o valor p > 0.05 por bateria de simulações.



```{r obtencao dos dados,echo=TRUE}
f_comparacao_testesSAD <- function(df,repo="dados/csv/avaliacao_testesSADs/"){
  m_SADrep <- read_csv(df$SADrep.path)
  df_comparacao <- adply(1:10,1,function(X) data.frame(y=sample((X+1):100,size = 10,replace = F)),.expand = F,.id="x") |> 
    mutate(x = as.numeric(as.character(x)))
  f_k <- function(df_bateria){
    f_rep <- function(df_i,df_SADbateria=df_bateria){
    v_x <- unname(sort(table(as.matrix(df_SADbateria[df_i$x,-(1:2)]))))
    v_y <- unname(sort(table(as.matrix(df_SADbateria[df_i$y,-(1:2)]))))
    p.KS <- ks_test(a=v_x,b=v_y,nboots = 1000)[2]
    p.DTS <- dts_test(a=v_x,b=v_y,nboots = 1000,keep.boots = F)[2]
    S_x <- length(v_x)
    S_y <- length(v_y)
    data.frame(p.KS,p.DTS,S_x,S_y,row.names = "")
    }
    adply(df_comparacao,1,f_rep)
  }
  df_write <- ddply(m_SADrep,"k",f_k)
  write_csv(cbind(SiteCode = df$SiteCode, df_write),file = paste0(repo,df$SiteCode,"_1.csv"))
}
registerDoMC(3)
a_ply(df_SADrep[sample(1:nrow(df_SADrep),30,replace = F),],1,f_comparacao_testesSAD,.parallel = TRUE)
```

```{r sintese dos dados}
# dados
df_rep <- list.files(path="dados/csv/avaliacao_testesSADs",full.names = T) |> 
  map_df(~read_csv(.))
df_testeSADs <- df_rep |> 
  mutate(diffS = S_x - S_y) |> 
  group_by(SiteCode,k) |> 
  summarise(nCongKS = sum(p.KS>0.05),
            nCongDTS = sum(p.KS>0.05),
            diffSmed = mean(diffS),
            diffSsd = sd(diffS)) |> 
  inner_join(x=df_sim,by="SiteCode") |> 
  inner_join(x=df_p,by="SiteCode")
# gráficos
# df_rep |> 
#   ggplot(aes(p.KS,p.DTS)) +
#   geom_point() +
#   geom_smooth()

df_testeSADs |> 
  pivot_longer(cols = nCongKS:nCongDTS,names_to="respostas",values_to="v_resp") |> 
  ggplot(aes(x=v_resp)) +
  geom_density() +
  facet_wrap(~respostas,ncol = 2)

df_testeSADs |> 
  ggplot(aes(nCongKS,nCongDTS)) +
  geom_point() +
  geom_smooth()
summary(lm(nCongKS ~ nCongDTS, data=df_testeSADs))


df_testeSADs |> 
  select(-effort_ha,-S_obs,-diffSsd) |> 
  pivot_longer(cols = c(p,Ntotal,diffSmed),names_to="preditoras",values_to="v_pred") |>
  pivot_longer(cols = nCongKS:nCongDTS,names_to="respostas",values_to="v_resp") |> 
  ggplot(aes(x=v_pred,y=v_resp,color=respostas)) +
  geom_point(alpha=0.4) +
  # geom_smooth() +
  facet_grid(respostas~preditoras,scales="free_x")
  
```

### Segundo testes: comparação quando a hipótese nula não é verdadeira

```{r comparacao onde a hipotese nula nao e igual}
f_comparacao2 <- function(df,repo="dados/csv/avaliacao_testesSADs/"){
  m_SADrep <- read_csv(df$SADrep.path)
  df_x <- m_SADrep |> filter(k==0.99) |> sample_n(size=10)
  df_y <- m_SADrep |> filter(k==0.05) |> sample_n(size=10)
  f_rep <- function(df_i){
    v_x <- unname(sort(table(as.matrix(df_i[,-(1:2)]))))
    f_testes <- function(df_y.i){
      v_y <- unname(sort(table(as.matrix(df_y.i[,-(1:2)]))))
      v_p.KS<- ks_test(a=v_x,b=v_y,nboots = 1000)[2]
      v_p.DTS <- dts_test(a=v_x,b=v_y,nboots = 1000)[2]
      v_S.x <- length(v_x)
      v_S.y <- length(v_y)
      data.frame(v_p.KS,v_p.DTS,v_S.x,v_S.y,row.names = "")
    }
    adply(df_y,1,f_testes,.expand = F,.id = "k005")
  }
  df_write <- adply(df_x,1,f_rep,.expand = F,.id = "k099")
  write_csv(cbind(SiteCode = df$SiteCode,df_write),
            file = paste0(repo,df$SiteCode,"_2.csv"))
}
registerDoMC(3)
a_ply(sample_n(df_SADrep,size=30),1,f_comparacao2,.parallel = T)
```

```{r graficos comparacao 2}
df_comp2 <- list.files("dados/csv/avaliacao_testesSADs",pattern = "_2.csv",full.names = T) |> 
  map_df(~read_csv(.))
df_comp2 <- df_comp2 |> 
  mutate(diffS = v_S.x - v_S.y) |> 
  group_by(SiteCode) |> 
  summarise(nCongKS = sum(v_p.KS>0.05),
            nCongDTS = sum(v_p.DTS>0.05),
            diffSmed = mean(diffS),
            diffSsd = sd(diffS)) |> 
  inner_join(x=df_sim,by="SiteCode")
l_p <- list()
l_p[[1]] <- df_comp2 |>
  pivot_longer(nCongKS:nCongDTS) |> 
  ggplot(aes(x=name,y=value)) +
  geom_boxplot() +
  geom_jitter() +
  labs(x="",y="# SADs congruentes")
l_p[[2]] <- df_comp2 |> 
  ggplot(aes(x=nCongKS,y=nCongDTS)) +
  geom_point() +
  geom_abline(slope=1,intercept = 0,color="red") +
  geom_smooth(method = "lm",se=F) +
  scale_y_continuous(limits=c(0,100))
l_p[[3]] <- df_comp2 |> 
  pivot_longer(Ntotal:S_obs) |> 
  ggplot(aes(x=value,y=nCongKS)) +
  geom_point() +
  labs(x="") +
  facet_wrap(~name,ncol=2,scales="free_x",strip.position = "bottom") +
  theme(strip.placement = "outside",strip.background = element_blank())
sum(df_comp2$nCongDTS)/(nrow(df_comp2)*100)
grid.arrange(grobs=l_p,layout_matrix=rbind(c(1,2),c(3,3)),top="")
```

