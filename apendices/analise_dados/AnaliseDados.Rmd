---
title: "Análise Dados"
author: "Mori, Danilo"
date: "19/11/2022"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = FALSE,message = FALSE,warning = FALSE)
# pacotes
library(sads)
library(doMC)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(MuMIn)
library(AICcmodavg)
library(insight)
library(bbmle)
library(DHARMa)
library(lme4)
library(plyr)
library(dplyr)
# dados
# df_resultMNEE
df_resultMNEE <- read_csv("dados/csv/resultados_MN/MNEE/df_resultMNEE.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv")
# df_ad
f_z <- function(x) (x-mean(x))/sd(x)
df_ad <- inner_join(x=select(df_resultMNEE,-(Ssd:Smax)),
                    y=select(df_sim,-tif.path),
                    by=c("SiteCode","k")) |>
  mutate(d.Lplot = d / sqrt(10000*effort_ha),
         k_cont = k,
         k = factor(round(k,2),levels=round(k,2)[20:1]),
         across(Ntotal:d.Lplot,log,.names="log_{.col}"),
         across(c(p,k_cont,Ntotal:log_d.Lplot),f_z,.names = "{.col}_z")) |> 
  select(-(d.Lplot:log_d.Lplot))
```

# MNEE com mapas contemporaneos

### Qual a relação entre o número de SADs congruentes segundo o teste KS e o teste DTS?

```{r figura 1 DTS e KS diffS,eval=T}
# df_ad |> 
#   ggplot(aes(x=nCongKS,y=nCongDTS,group=SiteCode)) +
#   geom_smooth(method = "lm",se=F,color="blue",alpha=0.4,formula = "y~x") +
#   geom_point(alpha=0.1) +
#   geom_line(alpha=0.1) +
#   geom_abline(slope = 1,intercept = 0,color="red")
# df_ad |> 
#   select(SiteCode:nCongDTS) |> 
#   pivot_longer(cols=nCongDTS:nCongKS,names_to = "variaveis",values_to = "nCong") |> 
#   ggplot(aes(x=variaveis,y=nCong)) +
#   geom_jitter() +
#   geom_boxplot()
v_labels <- c("nCongDTS" = "DTS: sum(p>0.05)",
              "nCongKS" = "KS: sum(p>0.05)")
df_ad |> 
  mutate(diffS = (S_obs - Smed) / S_obs ) |> 
  pivot_longer(cols=nCongKS:nCongDTS,names_to = "variaveis",values_to = "nCong") |> 
  ggplot(aes(x=diffS,y=nCong)) +
  geom_point(alpha=0.4) +
  geom_smooth(se=F) +
  labs(x="dif. com a riqueza observada",
       y="número de SADs congruentes") + 
  facet_wrap(~variaveis,ncol=2,labeller = as_labeller(v_labels))
# ggsave("figuras/MNEE-nCong_diffS.png")
# df_ad |> 
#   mutate(diffTestes = nCongKS - nCongDTS) |> 
#   ggplot(aes(x=S_obs,y=diffTestes)) +
#   geom_point() +
#   geom_smooth() +
#   labs(y="KS: sum(p value>0.05) - DTS: sum(p value>0.05)")
```

<p> __Figura 1__ Número de SADs congruentes (y) em função da diferença da riqueza da réplica e da SAD observada ( (Sobs - Srep )/ Sobs) por tipo de teste (DTS e KS). </p>


<p> DECISÕES: </p>
<p> 1) ambos os testes apresentam erro pequeno quando a hipótese nula é verdadeira (comparação de réplicas de uma mesma bateria de simulação). </p>
<p> 2) o teste DTS apresenta um erro maior quando a hipótese nula é falsa (comparação de réplicas de um mesmo sítio quando k=0.99 e k=0.05), porém o teste KS apresenta um erro de 47%; ainda vou mostrar para o PI esses resultados, talvez precise complementar essa segunda comparação. 
<p> CONCLUSÃO) Minha decisão é continuar com o teste KS pois no visual ele se sai melhor, apesar de ambos apresentarem problemas. </p>

### Gráficos Exploratórios

```{r figura 2 nCongKS d SiteCode,fig.width=10, fig.height=27,eval=TRUE}
df_plot <- df_ad |> mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) |>  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d,y=nCongKS)) +
  geom_line(alpha=0.6) +
  geom_point(alpha=0.7) +
  theme_classic() + 
  scale_x_continuous(trans = "log10") +
  labs(x="d(metros)",y="# SADs congruentes (p-value>0.05)") +
  facet_wrap(~title,ncol=8,scales="free_x")
```

__Figura 2__ Número de SADs congruentes (p-value>0.05) pela desvio padrão da função de dispersão (metros) por sítio de amostragem. Os paineis estão organizados pela proporção de cobertura vegetal (p).

Notas:
  
    
1) em PEmata2 a melhora na congruência em cenários de limitação mais brandos pode ser considerada um erro dos testes, na verdade pode ser considerado que existe uma piora? Lembre-se que pelo artigo do teste DTS a maior variabilidade existe justamente nos valores intermediários.
  
2) em outros casos acontece o mesmo tipo de erro: nas áreas que mais chama a atenção é aquela em que pode existir maior variabilidade. Penso se isso não deveria aumentar o número de SADs réplicas. 

```{r graf exp MNEE,eval=T,fig.height=12}
l_p <- list()
l_p[[1]] <- df_ad |> 
  ggplot(aes(x=p,y=nCongKS)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~k,ncol=4) +
  labs(subtitle="~ p +(~k)")
l_p[[2]] <- df_ad |> 
  mutate(p_class = cut(p,12)) |> 
  ggplot(aes(x=d,y=nCongKS)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~p_class,ncol=3) +
  labs(subtitle="~ d +(~p_cut)")
grid.arrange(grobs=l_p,ncol=1)
```

__Figura 3__ gráficos exploratórios efeitos fixos


### Seleção da estrutura aleatória e variável de dispersão

```{r selecao estrutura aleatoria}
df_md <- df_ad |> select(SiteCode,k,nCongKS,p_z:log_d.Lplot_z)
f_randomEffects <- function(disp_var,df=df_md){
  if(disp_var == "k"){
    l_md <- list()
    l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * k + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * poly(k_cont_z,2,raw=T) + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(k_cont_z,2,raw=T) + (poly(k_cont_z,2,raw=T)|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    names(l_md) <- c("k + 1|Site","k_cont^2 + 1|Site","k_cont^2 + k_cont^2|Site")
  } else if(disp_var == "d"){
    l_md <- list()
    l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * poly(d_z,2,raw=T) + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(d_z,2,raw=T) + (poly(d_z,2,raw=T)|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    names(l_md) <- c("d^2 + 1|Site", "d^2 + d^2|Site")
  } else if(disp_var == "d.Lplot"){
    l_md <- list()
    l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(d.Lplot_z,2,raw=T) + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(d.Lplot_z,2,raw=T) + (poly(d.Lplot_z,2,raw=T)|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    names(l_md) <- c("d.Lplot^2 + 1|Site", "d.Lplot^2 + d.Lplot^2|Site")
  } else if(disp_var == "log(d)"){
    l_md <- list()
    l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * poly(log_d_z,2,raw=T) + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(log_d_z,2,raw=T) + (poly(log_d_z,2,raw=T)|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    names(l_md) <- c("log(d)^2 + 1|Site", "log(d)^2 + log(d)^2|Site")
  } else if(disp_var == "log(d.Lplot)"){
    l_md <- list()
    l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * poly(log_d.Lplot_z,2,raw=T) + (1|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                         poly(p_z,2,raw=T) * poly(log_d.Lplot_z,2,raw=T) + (poly(log_d.Lplot_z,2,raw=T)|SiteCode),
          data=df, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    names(l_md) <- c("log(d.Lplot)^2 + 1|Site", "log(d.Lplot)^2 + log(d.Lplot)^2|Site")
  }
  return(l_md)
}
registerDoMC(3)
l_md <- alply(c("k","d","d.Lplot","log(d)","log(d.Lplot)"),1,f_randomEffects,.parallel = T,.expand = F)
# l_md <- f_randomEffects(disp_var = "k")
# l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2) * k + (1|SiteCode),
#           data=df_md, family = "binomial",
#           control=glmerControl(optimizer="Nelder_Mead",optCtrl=list(maxfun=2e9)))
l_md_RE_MNEE <- unlist(unname(l_md),recursive = F)
# l_md_RE_MNEE <- unlist(l_md,recursive = F)
save(l_md_RE_MNEE,file = "dados/Rdata/l_md_RE_MNEE.Rdata")
```

```{r auditoria dos modelos ajustados l_md_RE_MNEE}
v_reFit <- lapply(l_md[sapply(l_md, is, "merMod")],
                  function(x) !is.null(x@optinfo$conv$lme4$messages)) |> 
  unlist()
# registerDoMC(3)
l_md_allFit <- llply(l_md[v_reFit],allFit,.parallel = F)
l <- unlist(l_md_allFit,recursive = F)
f_aud_l_md <- function(l){
  v_aud <- lapply(l[sapply(l, is, "merMod")], 
                  \(x) x@optinfo$conv$lme4$messages) |> 
    unlist()
  l[v_aud]
} 
```

__Tabela 1__ Peso de evidência dos modelos cheios

```{r AICctab md_MNEE_RE, eval=TRUE}
load("dados/Rdata/l_md_RE_MNEE.Rdata")
AICctab(l_md_RE_MNEE,weights=T)
```


```{r dHARMa residuos md_MNEE_RE,eval=TRUE,cache=TRUE}
p_plot <- DHARMa::simulateResiduals(l_md_RE_MNEE[[5]],n=1000)
plot(p_plot)
```

__Figura 4__ Resíduos Quantílicos modelo cheio selecionado MNEE nCongKS

```{r Quantile-quantile plot random effects,eval=TRUE}
df_ranef <- ranef(l_md_RE_MNEE[[5]])$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef |> 
  pivot_longer(-SiteCode) |>
  ggplot(aes(sample=value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~name,scales="free",ncol=3)
```

__Figura 5__ Resíduos Quantílicos modelo cheio selecionado MNEE nCongKS


```{r figura 6 observado e predito pelo modelo médio de nCongKS MNEE, eval=T,fig.height=4}
# dados
df_md <- l_md_RE_MNEE[[5]]@frame
df_md$nCong_observado <- df_md$`cbind(nCongKS, 100 - nCongKS)`[,1]
df_md$nCong_predito <- predict(l_md_RE_MNEE[[5]],type="response") * 100
# graficos
ggplot(df_md,aes(x=nCong_observado,y=nCong_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) +
  labs(x="sum(p-value>0.05) observado",
       y="sum(p-value>0.05) predito",
       subtitle="Modelo Cheio") +
  coord_cartesian(expand = F)
```

__Figura 6__ Observado e predito pelo modelo cheio selecionado 

__Tabela 1__ Coeficiente de determinação marginal e condicional do modelo cheio selecionado para nCongKS de MNEE

```{r R2m e R2c md_MNEE_RE,cache=TRUE,eval=TRUE}
md_MNEE <- glmer(cbind(nCongKS,100-nCongKS) ~ poly(p_z,2,raw=T) * poly(d_z,2,raw=T) + (poly(d_z,2,raw=T)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
df_R2_RE_MNEE <- MuMIn::r.squaredGLMM(md_MNEE)
kableExtra::kable(df_R2_RE_MNEE)
```


### Predição Modelo Médio MNEE RE nCongKS

```{r modelo médio MNEE RE nCongKS}
# todas as combinações de modelo do modelo cheio
registerDoMC(3)
l_md.dredge_nCongKS_MNEE <- llply(dredge(md_MNEE,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
save(l_md.dredge_nCongKS_MNEE,file = "dados/Rdata/l_md_dredge_nCongKS_MNEE.Rdata")
```

__tabela 2__ Sub modelos derivados do modelo cheio com maior peso de evidência 

```{r tabela 2 peso de evidência dos modelos em ordem decrescente,results='hide' }
load("dados/Rdata/l_md_dredge_nCongKS_MNEE.Rdata")
# AICctab
df_tableGLMM <- print(AICctab(l_md.dredge_nCongKS_MNEE,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$model_code <- row.names(df_tableGLMM)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```


```{r model averaging MNEE  MuMIn e AICcmodavg}
# Model Averaging for SiteCode predictions
mdAvg_nCongMNEE_MuMIn <- model.avg(l_md.dredge_nCongKS_MNEE)
save(mdAvg_nCongMNEE_MuMIn,file="dados/Rdata/mdAvg_nCongMNEE_MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=unique(df_ad$SiteCode)[1],
                       d_z=seq(min(df_ad$d_z),max(df_ad$d_z),length=40),
                       p_z=seq(min(df_ad$p_z),max(df_ad$p_z),length=200))
mdAvg_nCongMNEE_AICcmodavg <- modavgPred(l_md.dredge_nCongKS_MNEE,newdata = df_pred,type="link") %>%
  cbind(df_pred)
save(mdAvg_nCongMNEE_AICcmodavg,file="dados/Rdata/mdAvg_nCongMNEE_AICcmodavg.Rdata")
```

```{r dados para novo conjunto de dados que interpola e extrapola os valores observados}
load("dados/Rdata/mdAvg_nCongMNEE_AICcmodavg.Rdata")
df_plot <- mdAvg_nCongMNEE_AICcmodavg |> 
  select(mod.avg.pred,lower.CL:upper.CL,d_z:p_z) |> 
  mutate(across(mod.avg.pred:upper.CL,\(x) exp(x)/(1+exp(x))),
         p = p_z*sd(df_ad$p) + mean(df_ad$p),
         d = d_z*sd(df_ad$d) + mean(df_ad$d))
df_plot |> 
  ggplot(aes(x=p,y=d,fill=mod.avg.pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral")
```


