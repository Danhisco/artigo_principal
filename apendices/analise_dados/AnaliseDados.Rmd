---
title: "Análise Dados"
author: "Mori, Danilo"
date: "19/11/2022"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = FALSE,message = FALSE,warning = FALSE)
# pacotes
library(sads)
library(doMC)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(MuMIn)
library(AICcmodavg)
library(insight)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(plyr)
library(dplyr)
# objetos
load("dados/Rdata/md_MNEE.Rdata")
polyK=3
source("source/nameModel.R")
# dados
# df_resultMNEE
df_resultMNEE <- read_csv("dados/csv/resultados_MN/MNEE/df_resultMNEE.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv")
# df_ad
f_z <- function(x) (x-mean(x))/sd(x)
df_ad <- inner_join(x=distinct(select(df_resultMNEE,-(Ssd:Smax))),
                    y=distinct(select(df_sim,-tif.path)),
                    by=c("SiteCode","k"),multiple="all") |>
  # escolhi remover depois do ajuste, para obter um melhor ajuste e depois excluir os valores
  # filter(k > 0.20) |> # figuras 5 e 6 apêndice Efeito de Escala
  mutate(k_cont = round(k,2),
         k = factor(round(k,2),levels=round(k,2)[20:1]), 
         across(Ntotal:S_obs,log,.names="log_{.col}"),
         log_S.N = log_S_obs - log_Ntotal,
         across(c(p,k_cont,log_Ntotal:log_S.N),f_z,.names = "{.col}_z")) |>
  select(-c(nCongDTS,effort_ha, Ntotal:S_obs))
# df_newdata
df_newdat <- read_csv("dados/csv/df_newdataSADs.csv")
# df_newdat <- expand.grid(p_z = seq(min(df_ad$p_z),max(df_ad$p_z), length=150),
#                          k_cont_z = seq(min(df_ad$k_cont_z),max(df_ad$k_cont_z), length=150))
# df_newdat <- adply(df_newdat,1,.fun = \(x) cbind(x,distinct(select(df_ad,SiteCode,log_S_obs_z,log_Ntotal_z))))
# write_csv(df_newdat,"dados/csv/df_newdataSADs.csv")
```

# MNEE 

## mapas contemporaneos

### Gráficos Exploratórios

```{r fig 1 - GE congruencia MNEE por p e k}
l_p <- list()
df_plot <- df_ad 
# |> filter(k_cont>0.20)
l_p[[1]] <- df_plot |> 
  ggplot(aes(x=p,y=nCongKS)) +
  geom_point() +
  geom_smooth(method = "loess",se=F) +
  labs(title="a) p, proporção de cobertura vegetal (~k)",
       y="número de SADs réplicas congruentes") +
  theme_bw() +
  facet_wrap(~k,ncol=5)
l_p[[2]] <- df_plot |> 
  mutate(p_cut = cut(p,20)) |> 
  ggplot(aes(x=k_cont,y=nCongKS)) +
  geom_point(alpha=0.4) +
  geom_line(alpha=0.4,aes(group=SiteCode)) +
  geom_smooth(method = "loess",se=F) +
  labs(title="b) k, prop. propágulos até a vizinhança (~cut(p, 20))",
       y="número de SADs réplicas congruentes",
       x="k") +
  theme_bw() +
  scale_x_reverse() +
  facet_wrap(~p_cut,ncol=5)
p <- grid.arrange(grobs=l_p,ncol=1,top="Congruência de MNEE")
ggsave("apendices/analise_dados/figuras/fig1_cong_p_k.png",
       width = 10.2,
       height = 10.7,
       plot = p)
```
  
    
__Figura 1__ Congruência de SADs MNEE por: a) proporção de cobertura vegetal; e b) k, grau de limitação de dispersão.
  
    
```{r fig 2 - congruencia de MNEE por k_cont e sitio de amostragem}
df_plot <- df_ad |> 
  mutate(label = paste0(SiteCode,", p=",round(p,2))) |>
  arrange(p)  
# |> filter(k_cont>0.20)
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |> 
  ggplot(aes(x=k_cont,y=nCongKS)) +
  geom_smooth(method = "loess",se=F) +
  geom_point() +
  # labs(title="b) k, prop. propágulos até a vizinhança (~cut(p, 20))",
  #      y="número de SADs réplicas congruentes",
  #      x="k") +
  theme_bw() +
  scale_x_reverse() +
  facet_wrap(~label,ncol=6)
ggsave("apendices/analise_dados/figuras/fig2_cong_k_SiteCode.png",
       width = 10,
       height = 17.7)
```

__Figura 2__ Congruência de SADs MNEE grau de limitação de dispersão e sítio de amostragem.

```{r fig 3 - congruência por logs de N e S}
df_plot <- df_ad |> 
  mutate(log_S.N = log_S_obs - log_Ntotal) 
# df_plot |> 
#   filter(log_S.N >= -3.75) |>
#   ggplot(aes(x=p,y=log_S.N)) +
#   geom_point() +
#   geom_smooth() +
#   labs(y="S / N")
# df_plot |> 
#   filter(log_S.N >= -3.75) |> 
#   ggplot(aes(x=log_S.N,y=nCongKS)) +
#   geom_point(aes(color=p)) +
#   geom_smooth(se=F) +
#   facet_wrap(~k,ncol = 5)
# df_plot |> 
#   ggplot(aes(x=p,y=log_Ntotal)) +
#   geom_point() +
#   geom_smooth()
# summary(lm(log_S.N ~ poly(p,1,raw = T), filter(df_plot,log_S.N >= -3.75)))
#
f_ggplot <- function(df){
  ggplot(df,aes(x=value,y=nCongKS)) +
  geom_point() +
  geom_smooth(se=F,method = "lm") +
  labs(x=unique(df$name),y="") +
  facet_wrap(~k_cont,ncol=5)
}
l_p <- dlply(pivot_longer(df_plot,log_Ntotal:log_S_obs),"name",f_ggplot)
grid.arrange(grobs=l_p,ncol=2,top="# SAD congruentes em função dos log de N e S")  
```

__Figura 3__ Congruência de SADs MNEE por: log do número de indivíduos (esquerda); e log do número de espécies por

```{r investigacao de log S N, eval=F}
df_ad |> 
  ggplot(aes(x=p,y=log_S.N)) +
  geom_point() +
  geom_hline(yintercept = mean(df_ad$log_S.N),color="red") +
  geom_smooth(method = "lm")
```


### GLMM Binomial

#### Modelo Cheio

```{r selecao modelo cheio N S p k, echo=T,eval=T,cache=TRUE}
l_md <- list()
l_md[[1]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                     log_Ntotal_z * log_S_obs_z * poly(k_cont_z,3,raw=TRUE) * poly(p_z,3,raw=TRUE) + 
                     (poly(k_cont_z,3,raw=TRUE)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
l_md[[2]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                     log_Ntotal_z * log_S_obs_z * poly(k_cont_z,3,raw=TRUE) +
                     poly(p_z,3,raw=TRUE) * poly(k_cont_z,3,raw=TRUE) + 
                     (poly(k_cont_z,3,raw=TRUE)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
l_md[[3]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                     log_Ntotal_z * log_S_obs_z +
                     poly(p_z,3,raw=TRUE) * poly(k_cont_z,3,raw=TRUE) + 
                     (poly(k_cont_z,3,raw=TRUE)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
l_md[[4]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                     log_Ntotal_z + log_S_obs_z +
                     poly(p_z,3,raw=TRUE) * poly(k_cont_z,3,raw=TRUE) + 
                     (poly(k_cont_z,3,raw=TRUE)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
l_md[[5]] <- glmer(cbind(nCongKS,100-nCongKS) ~ 
                     poly(p_z,3,raw=TRUE) * poly(k_cont_z,3,raw=TRUE) + 
                     (poly(k_cont_z,3,raw=TRUE)|SiteCode),
          data=df_ad, family = "binomial",
          control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
names(l_md) <- c("N * S * k * p","N * S * k","N * S", "N + S","1")
(df_aictab <- AICctab(l_md,weights=T) |> as.data.frame())
md_MNEE <- l_md[[row.names(df_aictab)[1]]]
```

```{r resíduos quantilicos do modelo cheio mais plausivel}
p_plot <- DHARMa::simulateResiduals(md_MNEE,n=1000)
plot(p_plot)
```


__Figura 4__ Resíduos Quantílicos modelo cheio selecionado MNEE nCongKS

```{r opcoes de graf exprotarios dos coef da estr aleat, eval=TRUE}
df_ranef <- ranef(md_MNEE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_p <- df_ranef |> 
  pivot_longer(-SiteCode) |> 
  inner_join(df_ad |> select(SiteCode,p) |> distinct(),by="SiteCode")
df_p |> 
  ggplot(aes(sample=value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  labs(title="qqnorm dos coef. por SiteCode") +
  facet_wrap(~name,scales="free",ncol=3)
df_p |>
  ggplot(aes(x=p,y=value)) +
  geom_hline(yintercept = 0,color="red") +
  geom_point() +
  geom_smooth() +
  facet_wrap(~name,ncol=2) +
  labs(title="Coef. por SiteCode ~ p") +
  theme_bw()
```

__Figura 5__ Resíduos Quantílicos modelo cheio selecionado MNEE nCongKS


```{r figura 6 observado e predito pelo modelo cheio de nCongKS MNEE, eval=T,fig.height=4}
# dados
df_md <- md_MNEE@frame
df_md$nCong_observado <- df_md$`cbind(nCongKS, 100 - nCongKS)`[,1]
df_md$nCong_predito <- predict(md_MNEE,type="response") * 100
# graficos
ggplot(df_md,aes(x=nCong_observado,y=nCong_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) +
  labs(x="nSADcong observado",
       y="nSADcong predito",
       title="Modelo Cheio",
       subtitle="predito ~ observado") +
  coord_cartesian(expand = F)
summary(lm(nCong_observado ~ nCong_predito,df_md))
```

__Figura 6__ Observado e predito pelo modelo cheio selecionado 


__Tabela 1__ Coeficiente de determinação marginal e condicional do modelo cheio selecionado para nCongKS de MNEE

```{r R2m e R2c do modelo cheio mais plausivel,cache=TRUE}
# md_MNEE <- glmer(cbind(nCongKS,100-nCongKS) ~ 
#                    log_Ntotal_z * log_S_obs_z *
#                    poly(p_z,polyK,raw=T) * poly(k_cont_z,polyK,raw=T) + 
#                    (poly(k_cont_z,polyK,raw=T)|SiteCode),
#           data=df_ad, family = "binomial",
#           control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),na.action = "na.fail")
(df_R2_RE_MNEE <- MuMIn::r.squaredGLMM(md_MNEE))
# kableExtra::kable(df_R2_RE_MNEE)
```

##### Predito pelo modelo cheio para novo conjunto de dados

NOTA:
df_newdat é um data frame com a interpolação de p e k, e para cada par único de p e k há todos os sítios.

```{r bootstrap do modelo cheio mais plausível MNEE - df_newdat2,echo=T}
#new data
df_newdat2 <- df_newdat |> filter(SiteCode == "BAlenc4") |> select(p_z:SiteCode)
## Passo 2: crie as função que devem ser calculadas dos modelos a cada simulação
## Previstos por efeitos fixos e aleatórios
f1 <- function(.) predict(., newdata=df_newdat2)
## Previstos por efeitos fixos (argumento re.form=~0)
f2 <- function(.) predict(., newdata=df_newdat2, re.form=~0)
## Os dois bootstraps. Ajuste o argumento ncpus para o numero de cores de seu computador
b3 <- bootMer(md_MNEE, FUN = f1, nsim=1000, parallel="multicore", ncpus=2)
b4 <- bootMer(md_MNEE, FUN = f2, nsim=1000, parallel="multicore", ncpus=2)
## calcula as médias e intervalos de confiança quantílicos para cada combinação de preditoras
## no novo conjunto de dados
df_newdat2$mean <- apply(b3$t,2,mean)
df_newdat2$IC.low <- apply(b3$t,2,quantile, 0.025)
df_newdat2$IC.upp <- apply(b3$t,2,quantile, 0.975)
df_newdat2$mean.fixed <- apply(b4$t,2,mean)
df_newdat2$IC.low.fixed <- apply(b4$t,2,quantile, 0.025)
df_newdat2$IC.upp.fixed <- apply(b4$t,2,quantile, 0.975)
write_csv(x=df_newdat2,file = "dados/csv/resultados_MN/MNEE/df_newdata.csv")
```

```{r predito pelo modelo cheio para novo conjunto de dados - df_newdat,eval=T}
# função para summarizar 
f_summarise <- function(x,probs = c(0.05,0.25, 0.5, 0.75,0.95)){
  tibble(pred = unname(quantile(x,probs)),prob = probs)
}
#
df_newdat$pred <- predict(md_MNEE,newdata=df_newdat,type="response")
df_plot <- df_newdat |> 
  reframe(across(pred,f_summarise,.unpack=TRUE),.by=c(p_z,k_cont_z)) |> 
  rename_with(~str_remove(.,"pred_")) |> 
  mutate(label = paste0("Quant = ",prob),
         p = p_z*sd(df_ad$p) + mean(df_ad$p),
         k = k_cont_z*sd(df_ad$k_cont) + mean(df_ad$k_cont))
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label)[c(3,2,4,1,5)])
# gráficos
f_ggplot2 <- function(df,facets=2){
  ggplot(df,aes(x=p,y=k,fill=pred)) +
    geom_tile() +
    scale_fill_distiller(palette = "Spectral",limits=c(0,1)) +
    scale_y_reverse() +
    theme_classic() +
    coord_cartesian(expand = FALSE) +
    labs(fill="Pr(Cong)") +
    facet_wrap(~label,ncol = facets)
}
l_p <- list()
l_p[[1]] <- df_plot |> 
  filter(prob == 0.5) |> 
  f_ggplot2() + labs(x="")
l_p[[2]] <- df_plot |> 
  filter(prob != 0.5) |>
  f_ggplot2()
ggpubr::ggarrange(plotlist = l_p,nrow=2, common.legend = TRUE, legend="top")
```


#### Modelo Médio


```{r códigos para rodar o modelo médio,echo=T}
# todas as combinações de modelo do modelo cheio
registerDoMC(3)
l_md.dredge_MNEE <- llply(dredge(md_MNEE,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for SiteCode predictions
mdAvg_MNEE__MuMIn <- model.avg(l_md.dredge_MNEE)
# Model Averaging for new data predictions
mdAvg_MNEE__AICcmodavg <- modavgPred(l_md.dredge_MNEE,newdata = df_newdat,type="link") %>%
  cbind(df_pred)
# saves
save(l_md.dredge_MNEE,file="dados/Rdata/l_md.dredge_MNEE.Rdata") # lista c todas as combinações de modelo
save(mdAvg_MNEE__MuMIn,file="dados/Rdata/mdAvg_MNEE__MuMIn.Rdata") # predição do modelo médio para os dados observados
save(mdAvg_MNEE__AICcmodavg,file="dados/Rdata/mdAvg_MNEE__AICcmodavg.Rdata") # predição do modelo médio para novo conjunto de dados 
```

__tabela X__ Tabela de Seleção com os submodelos mais plausíveis. 

```{r head tabela dos submodelos do modelo cheio}
load("dados/Rdata/l_md.dredge_MNEE.Rdata")
df_AICctabMNEE <- model.sel(l_md.dredge_MNEE)
```


```{r  observado e predito modelo medio, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="dados/Rdata/mdAvg_MNEE__MuMIn.Rdata")
# Predição
df_md <- df_ad |> 
  mutate(label=paste0(SiteCode,", p=",round(p,3)),
         pred_modCheio = predict(md_MNEE,type="response") * 100,
         pred_modMedio = predict(mdAvg_MNEE__MuMIn,type="response")*100) |> 
  arrange(p)
df_md$label <- factor(df_md$label,levels = unique(df_md$label))
v_cols <- c("md médio" = "red", "md cheio" = "blue")

(p <- df_md |> 
  # pivot_longer(pred_modCheio:pred_modMedio) |>
  ggplot(aes(x=k_cont,y=nCongKS)) +
  # geom_line(aes(y=pred_modCheio),color="blue") +
  geom_line(aes(y=pred_modMedio),color="red",alpha=0.4) +
  geom_point() +
  theme_bw() +
  scale_x_reverse() +
  labs(x="k",y="# SADs congruentes",title="Predito pelo modelo médio (azul) e cheio (vermelho) são iguais") +
  facet_wrap(~label,ncol=6))
ggsave("apendices/analise_dados/figuras/fig6b_PredObs_k_Site.png",p,
       width = 10,
       height = 17.7)

```


```{r comparacao modelo medio e modelo cheio para novo conjunto de dados - df_newdat2}
df_newdat2$pred_mdMedio <- predict(mdAvg_MNEE__MuMIn,type="response",newdata=df_newdat2)*100
df_newdat2$pred_mdCheio <- predict(md_MNEE,type="response",newdata=df_newdat2)*100
df_newdat2 |>
  mutate(p = p_z*sd(df_ad$p) + mean(df_ad$p),
         k = k_cont_z*sd(df_ad$k_cont) + mean(df_ad$k_cont)) |> 
  pivot_longer(starts_with("pred_")) |> 
  ggplot(aes(x=p,y=k,fill=value)) +
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  scale_y_reverse() +
  theme_classic() +
  facet_wrap(~name,ncol=2)
```

### GAMM

```{r}
f_ggplot <- function(){
  list(
    geom_point(),
    geom_smooth(se=F,method = "lm"),
    geom_smooth(se=F,method = "loess"),
    geom_smooth(se=F),
    theme_bw()
  )
}
l_p <- list()
l_p[[1]] <- df_ad |> 
  ggplot(aes(p,log_S.N)) +
  f_ggplot() +
  labs(title="log(S/N) ~ p",y="log(S/N)")
l_p[[2]] <- df_ad |> 
  ggplot(aes(log_Ntotal,log_S_obs)) +
  f_ggplot() +
  labs(title="log(S) ~ log(N)",
       x="log(N)",y="log(S)")
v_labels <- c(log_Ntotal="log(N)",log_S_obs="log(S)")
l_p[[3]] <- df_ad |> 
  pivot_longer(log_Ntotal:log_S_obs) |> 
  ggplot(aes(p,value)) +
  f_ggplot() +
  labs(title="log(S) e log(N) ~ p") +
  facet_wrap(~name,ncol=2,scales="free",strip.position = "left",labeller = labeller(name=v_labels)) +
  theme(strip.background = element_blank(),
        strip.placement = "outside",
        strip.text.y.left = element_text(size=11),
        axis.title.y = element_blank(),
        plot.title = element_text(hjust = 0.5))
grid.arrange(grobs=l_p,layout_matrix = rbind(c(1,2),c(3,3)))
# plot(lm(log_S.N ~ p,df_ad))
```



Objetivo:
Melhorar a regressão das estatísticas resumo em função de p e k.


Parametrização adequada segundo Gavin Simpson em vídeo do Ecological Forecasting:

A lógica de parametrização é:
i) deixar k grande suficiente
ii) pois a penalização do overfitting 

```{r GAMM binomial MNEE contemporaneo}
df_md <- df_ad |> 
  mutate(SiteCode = factor(SiteCode))
l_md <- list()
l_md[[1]] <- gam(cbind(nCongKS,100-nCongKS)  ~ 
                 te(log_Ntotal_z,log_S_obs_z) + s(k_cont_z) + s(p_z) +
                 s(k_cont_z, SiteCode, bs="fs", k=10, m=2),
                data = df_md, family="binomial", method = "REML")
l_md[[2]] <- gam(cbind(nCongKS,100-nCongKS)  ~ 
                   s(log_Ntotal_z) + s(log_S_obs_z) + s(k_cont_z) + s(p_z) +
                   ti(log_Ntotal_z,log_S_obs_z) + ti(k_cont_z,p_z) +
                   s(k_cont_z, SiteCode, bs="fs", k=10, m=2),
                 data = df_md, family="binomial", method = "REML")
l_md[[3]] <- gam(cbind(nCongKS,100-nCongKS)  ~ 
                   s(log_Ntotal_z) + s(log_S_obs_z) + s(k_cont_z) + s(p_z) +
                   ti(log_Ntotal_z,log_S_obs_z,k_cont_z) +
                   s(k_cont_z, SiteCode, bs="fs", k=10, m=2),
                 data = df_md, family="binomial", method = "REML")
# não roda:::
# l_md[[4]] <- gam(cbind(nCongKS,100-nCongKS)  ~ 
#                    s(log_Ntotal_z) + s(log_S_obs_z) + s(k_cont_z) + s(p_z) +
#                    ti(log_Ntotal_z,log_S_obs_z,k_cont_z,p_z) +
#                    s(k_cont_z, SiteCode, bs="fs", k=10, m=2),
#                  data = df_md, family="binomial", method = "REML")
l_md[[4]] <- gam(cbind(nCongKS,100-nCongKS)  ~ 
                   s(log_Ntotal_z) + s(log_S_obs_z) + s(k_cont_z) + s(p_z) +
                   ti(log_Ntotal_z,log_S_obs_z,k_cont_z) + ti(log_Ntotal_z,log_S_obs_z,p_z) +
                   s(k_cont_z, SiteCode, bs="fs", k=10, m=2),
                 data = df_md, family="binomial", method = "REML")
names(l_md) <- c("te(N,S) + s(k) + s(p)",
                 "s + ti(N,S) + ti(k,p)",
                 "s + ti(N,S,k)",
                 #"s + ti(N,S,k,p)",
                 "s + ti(N,S,k) + ti(N,S,p)")
l_md_GAMM <- l_md
save(l_md_GAMM,file="dados/Rdata/l_md_GAMM.Rdata")
```
```{r}
load("dados/Rdata/l_md_GAMM.Rdata")
(df_aicctab <- AICctab(l_md_GAMM,weights=TRUE) |> as.data.frame())
gamm_MNEE <- l_md_GAMM[[row.names(df_aicctab)[1]]]
gratia::appraise(gamm_MNEE)
summary(gamm_MNEE)
gratia::draw(gamm_MNEE)
```

