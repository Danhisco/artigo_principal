---
title: "Apêndice 2: Figuras e Tabelas"
author: "Mori, Danilo"
date: "19/11/2022"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE,cache=TRUE)
# pacotes
library(dagitty)
library(ggdag)
library(gratia)
library(sads)
library(doMC)
library(metR)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(MuMIn)
library(AICcmodavg)
library(insight)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(gamm4)
library(plyr)
library(dplyr)
source("source/nameModel.R")
source("source/GAMMtools.R")
# dados
# df_dados_disponiveis
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv")
# df_p
df_p <- read_csv("dados/df_p.csv")
# df_resultMNEE
df_resultados <- read_csv("dados/csv/resultados_MN/df_resultados.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv")
# df_Urep
df_Urep <- list.files(path = "dados/csv/taxaU/MNEE", pattern = ".csv",recursive = T,full.names = T) |> 
  purrr::map_df(~read_csv(.)) |> na.omit()
# df_U
df_U <- read_csv("dados/csv/taxaU/df_U.csv")
# df_contrastes
df_contrastes <- read_csv("dados/csv/taxaU/df_contrastes.csv")
# df_ad: dados completos, com todos os logOR e as proporções observadas para os 3 e as preditoras
f_z <- function(x) (x-mean(x))/sd(x)
df_ad <- df_resultados |>
  arrange(p) |> 
  inner_join(distinct(select(df_sim,SiteCode,Ntotal:S_obs)),"SiteCode") |> 
  mutate(diffS = (Smed - S_obs)/S_obs)
# df_contrastes: contrastes por sítio e grau de limitação de dispersão
df_contrastes <- read_csv(file="dados/csv/taxaU/df_contrastes.csv") |> 
  inner_join(df_sim |> select(SiteCode,Ntotal:S_obs) |> distinct(),
             by="SiteCode") |> 
  rename(N=Ntotal,S=S_obs) |> 
  mutate(across(N:S,log,.names="log.{.col}"),
         across(c(p,k,log.N:log.S),f_z,.names = "{.col}_z"),
         SiteCode = factor(SiteCode)) |> 
  select(-c(N:log.S))
# df_md: dados necessários 
df_md <- df_ad |> 
  inner_join(df_contrastes |> 
               select(SiteCode:efeito_conf) |> 
               mutate(across(.cols=c(p,k,contains("efeito")),f_z,.names="{.col}_z")) |> 
               select(-c(p,efeito_area:efeito_conf)) |> 
               pivot_longer(starts_with("efeito_"),names_to="logOR_pair",values_to="contraste_z") |> 
               mutate(logOR_pair = case_when(logOR_pair == "efeito_area_z" ~ "non_frag.ideal",
                                             logOR_pair == "efeito_frag_z" ~ "cont.non_frag",
                                             TRUE ~ "cont.ideal")),
             by=c("SiteCode","k","logOR_pair")) |> 
  mutate(SiteCode = factor(SiteCode),
         land_hyp = factor(land_type),
         contrasteSAD_z = f(logOR_value)) |> 
  select(-land_type) |> 
  rename(nCong=nCongKS)
  # df_newdata
write_csv(df_md,"dados/csv/df_md_logOR.csv")
df_newpred <- read_csv(file="dados/csv/df_newpred.csv") |> 
  select(-starts_with("log_"))
# df_pred
# df_pred <- read_csv("dados/csv/resultados_MN/MNEE/df_pred.csv")
# df_newdat <- expand.grid(p_z = seq(min(df_ad$p_z),max(df_ad$p_z), length=150),
#                          k_cont_z = seq(min(df_ad$k_cont_z),max(df_ad$k_cont_z), length=150))
# df_newdat <- adply(df_newdat,1,.fun = \(x) cbind(x,distinct(select(df_ad,SiteCode,log_S_obs_z,log_Ntotal_z))))
# write_csv(df_newdat,"dados/csv/df_newdataSADs.csv")
#
# df_intePred_contrastes.csv
df_intPred <- read_csv("dados/csv/df_intePred_contrastes.csv")
# df_congContrastetsREP.cvs
df_congContrastes <- read_csv("dados/csv/resultados_MN/df_congContrastes.csv") |> 
  inner_join(df_md |> 
               select(SiteCode,p,k,logOR_pair,contraste_z),
             by=c("SiteCode","k","pair" = "logOR_pair")) |> 
  arrange(p) |> 
  relocate(p,.after=k) |> 
  mutate(SiteCode = factor(SiteCode))
# loads
load("dados/Rdata/l_md.contrastes.Rdata")
load("dados/Rdata/md_frag_area.Rdata")
load("dados/Rdata/l_md_congContrastes.Rdata")
load("dados/Rdata/l_md.logOR.Rdata")
```


## Sítios Selecionados 
### Figura A2 1


```{r fig 1 - sitios amostrados e grau de limitação de dispersao,fig.width=12,fig.height=6}
df_plot <- df_dados_disponiveis |> 
  select(SiteCode, effort_ha, Ntotal, S_obs, year_bestProxy, forest_succession, lat:long_correct)
l_p <- list()
l_p[[1]] <- df_plot |> 
  ggplot(aes(y=lat,x=long)) +
  geom_point(alpha=0.5) +
  theme_light() +
  labs(subtitle = "a)")
v_labels <- c("effort_ha" = "plot area (ha)",
              "Ntotal" = "# ind",
              "S_obs" = "riqueza",
              "year_bestProxy" = "approx. data year")
df_plot[grep("\\_",df_plot$year_bestProxy),"year_bestProxy"] <- "2012.5"
l_p[[2]] <- df_plot |>
  mutate(year_bestProxy = as.numeric(year_bestProxy)) |> 
  pivot_longer(effort_ha:year_bestProxy) |> 
  ggplot(aes(x=name,y=value)) +
  geom_jitter(alpha=0.4) +
  geom_boxplot() +
  labs(x="",y="",subtitle="b)") +
  facet_wrap(~name,ncol=1,scales="free", labeller = as_labeller(v_labels), strip.position = "bottom") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        strip.background = element_blank(),
        strip.placement = "outside") +
  coord_flip()
l_p[[3]] <- df_plot |> 
  ggplot(aes(x=forest_succession)) +
  geom_bar() +
  geom_text(aes(label = after_stat(count)), stat = "count", vjust = -0.2, colour = "black") +
  labs(x="classificação de estágio sucessional do TreeCo",
       y="countagem",subtitle="c)")
grid.arrange(grobs=l_p,ncol=3)
```

__Figura A2 1__ Sítios selecionados na base de dados TreeCo. a) latitude e longitude das coordenadas centrais dos inventários florestais. b) boxplot de variáveis dos inventários: área da parcela, número de indivíduos amostrado, riqueza de espécies observado, e ano da amostragem ou da publicação. c) Classificação do estado de conservação ou sucessional da área amostrada no inventário: primary (floresta primária, não-alterada, primitiva, old-growth (≥80 anos de sucessão) ); primary/secondary (floresta em estágio avançado de sucessão (50 a 80 anos de sucessão)); secondary (floresta secundária, alterada, em estágio médio de regeneração (20 a 50 anos de sucessão)); capoeira (floresta em estado inicial de sucessão (<20 anos de sucessão)).


## Contrastes - Taxa U

Nas paisagens com pouco habitat o padrão médio é similar ao esperado em paisagens infinitas sem perda de habitat (Apêndice 1): um patamar baixo de valores médios em graus de limitação de dispersão severos; aumento brusco para um novo patamar em graus de limitação de dispersão menos severos; seguido por redução da taxa U com o aumento da capacidade de dispersão para graus brandos de limitação de dispersão (Figura A2 2 e 3). A variabilidade entre réplicas pode aumentar nos graus de limitação de dispersão pouco severos (Figura A2 2), onde há o patamar superior de valores da taxa U nas paisagens sem perda de habitat (Figura A2 2 e 3). 


### Figura A2 2

```{r Fig A2 2 - Graf Exp dos contrastes,fig.width=10,fig.height=4}
l_p <- list()
l_p[[1]] <- df_U |> 
  mutate(Ucv = Usd / Umed,
         k_factor = factor(round(k,2))) |> 
  inner_join(df_p) |> 
  # ggplot(aes(y=Ucv,x=k_factor)) + 
  # geom_jitter() +
  # geom_boxplot()
  ggplot(aes(x=Umed,y=Usd,color=land_type)) +
  geom_point(alpha=0.2) +
  geom_abline(slope = 1,intercept = 0) +
  geom_abline(slope=0.1,intercept = 0) +
  geom_abline(slope=0.01,intercept = 0) +
  scale_color_manual(values=c("darkred","darkblue","darkgreen"),
                     labels=c("contemporâneo","idealizado","sem fragmentação")) +
  labs(x="média taxa U",y="desvio padrão taxa U") +
  scale_y_continuous(labels = scales::label_scientific(digits = 1)) +
  theme(legend.position = "none") +
  facet_wrap(~k_factor,ncol=4)
l_p[[2]] <- df_U |>
  inner_join(df_p) |>
  pivot_longer(c(p,k)) |> 
  ggplot(aes(x=value,y=Umed,color=land_type)) +
  geom_point(alpha=0.2) +
  geom_smooth(method = "gam",se=F,alpha=0.2) +
  scale_color_manual(values=c("darkred","darkblue","darkgreen"),
                     labels=c("contemporâneo","idealizado","sem fragmentação")) +
  labs(color="",y="média taxa U",x="") +
  facet_wrap(~name,ncol=2,scales="free",strip.position = "bottom") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.margin=margin(-26, 0, 0, 0),
        strip.background = element_blank(),
        strip.placement = "outside")
grid.arrange(grobs=l_p,layout_matrix = rbind(c(1,2,2)))
```

__Figura A2 2__ Gráficos exploratórios da taxa U estimada e dos contrastes calculados. No painel da esquerda superior, coeficiente de variação da taxa U estimada por MNEE. Cada ponto representa uma bateria de simulação com 10 réplicas cada; no eixo x há a média da taxa U e no eixo y o correspondente desvio padrão. Todas as retas passam pela origem, em preto a reta com inclinação de 1, em verde a com inclinação de 0.1, e em vermelho com inclinaçãao de 0.01. A maior parte dos pontos tem coeficiente de inclinação entre 10% e 1%. Nos paineis da direita superior e da linha de baixo há os gráficos exploratórios dos contrastes, respectivamente: boxplots dos contrastes calculados, gráfico de dispersão dos contrastes de fragmentação per se e área per se, e o contraste contemporâneo em função de p e colorido por k. 

### Figura A2 3

```{r fig A2 3 Umed ~ d +(SiteCode ~ p),eval=TRUE,fig.height=30,fig.width=15}
df_plot <- df_Urep |> select(-d) |> 
  pivot_longer(-c(SiteCode:k),names_to = "rep",values_to = "U") |>
  inner_join(df_p) |> 
  arrange(p) |> 
  mutate(label = paste0(SiteCode,", p=",round(p,2)))
# df_plot <- df_U |>
#   inner_join(x=unique(select(df_sim,SiteCode,p)),by="SiteCode") |> 
#   arrange(p) |> 
#   mutate(label = paste0(SiteCode,", p=",round(p,2))) #, " ,S=",S_obs
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
df_plot |> 
  ggplot(aes(x=k,y=U,color=land_type)) +
  geom_point(alpha=0.1) +
  # geom_line() +
  stat_summary(geom = "line",fun.data = mean_se,alpha=0.5) +
  scale_x_reverse() +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
  theme_bw() +
  labs(color="landscape type") +
  theme(legend.position = "top",
        axis.text=element_text(size=4.5),
        strip.text = element_text(size = 4.5, margin = margin())) +
  scale_color_manual(values=c("darkred","darkblue","darkgreen"),
                     labels=c("contemporâneo","idealizado","sem fragmentação")) +
  facet_wrap(~label,ncol=5,scales="free")
ggsave("apendices/taxaU/figuras/Umed_k_landType_Site.png",
       width = 7,
       height = 30)
```

__Figura A2 3__ Taxa U estimada em cada sítio nos 20 graus de limitação de dispersão simulados. Os sítios estão organizados pela pela proporção de cobertura vegetal 

### Figura A2 4

```{r Figura A2 4 GE contrastes}
l_p <- list()
l_p[[1]] <- df_contrastes |>
  pivot_longer(efeito_area:efeito_conf) |>
  mutate(name = factor(name,labels = c("contraste area","contraste contemp","contraste frag"))) |>
  ggplot(aes(x=name,y=value)) +
  geom_hline(data = df_contrastes |>
               mutate(referencia_efeito = ifelse(p>=0.93,"p>=0.93","p<0.93")) |>
               group_by(referencia_efeito) |>
               filter(p>=0.93) |>
               summarise(min = min(across(efeito_area:efeito_conf,min)),
                         max = max(across(efeito_area:efeito_conf,max))) |>
               pivot_longer(min:max),
             # |>
               # pivot_longer(),
             aes(yintercept = value,
                 color=referencia_efeito)) +
  scale_x_discrete(limits=c("contraste area","contraste frag","contraste contemp")) +
  # coord_flip() +
  geom_boxplot() +
  geom_jitter(alpha=0.4) +
  labs(x="",y="contraste na estimativa da taxa U",
       # subtitle = "contraste area = (sem isolamento - idealizado) / idealizado  \ncontraste frag = (contemp - sem isolamento) / idealizado  \ncontraste contemp = (contemp - idealizado) / idealizado",
       color="valor extremos:",
       title="a)") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.margin=margin(-14, 0, 0, 0))
l_p[[2]] <- df_contrastes |>
  ggplot(aes(x=efeito_area,y=efeito_frag)) + # ,color=p>=0.93
  geom_abline(slope = 1,intercept = 0,color="darkred") +
  geom_hline(data = df_contrastes |>
               filter(p>=0.93) |>
               summarise(min = min(efeito_frag),
                         max = max(efeito_frag)) |>
               pivot_longer(min:max),
             aes(yintercept = value),color="darkgreen") +
  geom_vline(data = df_contrastes |>
               filter(p>=0.93) |>
               summarise(min = min(efeito_area),
                         max = max(efeito_area)) |>
               pivot_longer(min:max),
             aes(xintercept = value),color="darkgreen") +
  geom_point(alpha=0.3) +
  geom_hex(bins=70,alpha=0.4) +
  scale_x_continuous(limits = c(range(df_contrastes[,c("efeito_area","efeito_frag")]))) +
  scale_y_continuous(limits = c(range(df_contrastes[,c("efeito_area","efeito_frag")]))) +
  labs(x="Área per se",y="Fragmentação per se",level="2D density",title="b)") +
  guides(fill = guide_legend(title="contagem")) +
  scale_fill_continuous(type = "viridis") +
  theme_bw()
l_p[[3]] <- df_contrastes |>
  pivot_longer(cols = k:p,names_to = "pred_class",values_to = "pred_values") |>
  mutate(pred_class = factor(pred_class,levels=c("p","k"))) |>
  pivot_longer(cols = starts_with("efeito_"),names_to = "resp_class",values_to = "resp_values") |>
  mutate(resp_class = factor(resp_class,levels=names(df_contrastes)[4:6])) |>
  ggplot(aes(x=pred_values,y=resp_values)) +
  geom_point(alpha=0.4) +
  geom_quantile(method="rqss",quantiles = c(0.05,0.5,0.95),lambda=0.1,color="darkred") +
  labs(title="c)",x="",y="") +
  facet_grid(pred_class~resp_class,scales="free",
             labeller = labeller(pred_class = c(p="p",k="k"),
                                 resp_class = c(efeito_area = "área per se",
                                                efeito_conf = "contemporaneidade",
                                                efeito_frag = "fragmentação per se")))
grid.arrange(grobs=l_p,
             layout_matrix = rbind(c(1,1,2,2),
                                   c(3,3,3,3),
                                   c(3,3,3,3))
             )
```

__Figura A2 4__ Gráficos explotários dos contraste

### Avaliação GAMM 1

Os GAMM utilizaram a cubic regression spline como função base nos splines simples e nos tensores entre as variáveis preditoras (Janela de código 1). A estrutura aleatória do GAMM foi específica de modo que há um intercepto e spline de k por inventário florestal (Janela de código 1), com os splines de k por inventário florestal compartilhando um mesmo parâmetro de penalização (veja @Pedersen2019).

__Janela de código 1__ GAMM usado para ajustar os contrastes 

```{r janela 1 GAMM contrastes taxa U, echo=T,eval=F}
f_gam <- function(df){
  gam(value ~
        s(k_z,bs = "cr") + s(p_z,bs = "cr") +
            ti(p_z,k_z) +
            s(k_z, SiteCode, bs="fs",xt=list(bs="cr")) + 
            s(SiteCode,bs="re"),
            data=df,method = "REML")
}
```

__Janela de output R console 1__ Validação dos GAMMs usados para descrever os contrastes da taxa U 

```{r avaliação contrastes}
l_ply(names(l_md.contrastes),\(string) f_validaGAMM(md_name = string,l_md=l_md.contrastes))
```

  
O GAMM do contraste de área apresenta o melhor ajuste entre os GAMMs para os 3 contrastes. O spline indivídual para a variável p apresenta a melhor estimativa do efeito parcial médio, com o desvio padrão sendo mais uniforme ao longo da estimativa do efeito parcial médio (gráfico 's(p_z)' no output da função 'gratia::draw'; e outputs das funções 'mgcv::k.check' e 'mgcv::summary'). Os splines indivíduos para a variável p nos GAMMs dos outros dois contrastes (contemporâneo e fragmentação per se) apresentam estimativa do efeito médio que tendem à uma reta ; o ajuste do GAMM para o contraste de contemporaneidade parece ser mais adequado do que o fragmentação per se, pois o desvio padrão ao redor da estimativa de efeito médio é mais uniforme ao longo do gradiente da preditora (gráfico 's(p_z)' do output da função 'gratia::draw'). Os 3 GAMMs não fazem um bom ajuste de valores extremos dos contrastes (output da função 'gratia:appraise - QQplot of residuals'), o quê explica a melhor qualidade do GAMM para o contraste de área per se. O deviance explained  dos GAMMs foram 96.2%, 98.1% e 98.1% para os contrastes de área, contemporaneidade e fragmentação per se, respectivamente. As estimativas de efeitos médios dos splines da variável k de cada inventário florestal podem apresentar variação qualitativa do padrão dos efeitos médios do spline geral para a variável k ou do tensor entre a variável k e a variável p (output da função 'gratia::draw').


### Avaliação GAMM 2

Avaliação GAMMs contraste - taxa U: frag. per se ~ f(área per se)


__Janela de código 2__ GAMM usado para ajustar os contrastes 

```{r janela 2 GAMM frag per se ~ area Taxa U,echo=T,eval=F}
md_frag_area <- gam(frag_z ~ 
                      s(area_z,bs="tp") + 
                      s(area_z,SiteCode,bs="fs",xt=list(bs="tp")) + 
                      s(SiteCode,bs="re"),
                      data=df,method = "REML")
```


__Janela de output R console 2__ Validação dos GAMMs usados para descrever os contrastes da taxa U 

```{r janela de output 2 GAMM frag ~ area taxa U}
f_validaGAMM(md_name = "Frag. per se ~ Area",l_md = md_frag_area,size = 1)
```


## Contrastes - Congruência SADs preditas

__Janela de output R console 3__ Validação dos GAMMs mais plausíveis

```{r Janela de output R console 3}
df_tab <- ldply(l_md_congContrastes,f_TabSelGAMM)
# df_tab
df_mdlik <- df_tab |> filter(dAICc == 0) |> select(pair,modelo)
l_md_plot <- alply(df_mdlik,1,\(df) l_md_congContrastes[[df$pair]][[df$modelo]])
names(l_md_plot) <- df_mdlik$pair
l_ply(names(l_md_plot),\(string) f_validaGAMM(md_name = string,l_md=l_md_plot))
```


## Congruência com a SAD observada

### Diferença na Riqueza Estimada

```{r gráficos explorátórios de diffS}
df_md |> 
  ggplot(aes(x=p,y=diffS)) +
  geom_point(alpha=0.3) +
  geom_smooth(method="gam",se=F) +
  geom_hline(yintercept = 0,color="red") +
  facet_wrap(~land_hyp,ncol=3)
```

__Figura A2 5 __ Gráficos Exploratórios geom_smoother(method="gam")

```{r graf exp diffS md + lik}
md_diffs <- lmer(diffS ~ land_hyp * p + (1|SiteCode),df_md)
p_dharma <- simulateResiduals(md_diffs,n = 1000)
plot(p_dharma)
```

__Figura A2 6__ Gráficos diagnósticos do pacote DHARMa para o modelo mais plausível para descrever o erro na riqueza estimada

__Janela de output R console 4__ sumário do modelo mais plausível para descrever o erro na riqueza estimada

```{r sumário do modelo mais plausível para descrever o erro na riqueza estimada}
summary(md_diffs)
```

