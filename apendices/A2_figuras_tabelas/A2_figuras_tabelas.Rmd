
```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE,cache=TRUE)
# pacotes
library(dagitty)
library(ggdag)
library(gt)
library(gratia)
library(sads)
library(doMC)
library(metR)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(MuMIn)
library(AICcmodavg)
library(insight)
library(bbmle)
library(DHARMa)
library(mgcv)
library(lme4)
library(data.table)
library(plyr)
library(dplyr)
source("source/nameModel.R")
source("source/GAMMtools.R")
source("source/general_tools.R")
figHeight=28
figWidth=40
# dados
# df_dados_disponiveis
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv")
# df_p
df_p <- read_csv("dados/df_p.csv")
# df_resultMNEE
df_resultados <- read_csv("dados/csv/resultados_MN/df_resultados.csv")
# df_sim
df_sim <- read_csv("dados/df_simulacao.csv")
# df_Urep
df_Urep <- list.files(path = "dados/csv/taxaU/MNEE", pattern = ".csv",recursive = T,full.names = T) %>%  
  adply(.,1,data.table::fread,.id=NULL) %>% na.omit()
# df_U
df_U <- data.table::fread("dados/csv/taxaU/df_U.csv")
# df_contrastes
df_contrastes <- fread("dados/csv/taxaU/df_contrastes.csv")
# df_ad: dados completos, com todos os logOR e as proporções observadas para os 3 e as preditoras
f_z <- function(x) (x-mean(x))/sd(x)
df_ad <- df_resultados |>
  arrange(p) |> 
  inner_join(distinct(select(df_sim,SiteCode,Ntotal:S_obs)),"SiteCode") |> 
  mutate(diffS = (Smed - S_obs)/S_obs)
# df_contrastes: contrastes por sítio e grau de limitação de dispersão
df_contrastes <- fread(file="dados/csv/taxaU/df_contrastes.csv") |> 
  inner_join(df_sim |> select(SiteCode,Ntotal:S_obs) |> distinct(),
             by="SiteCode") |> 
  rename(N=Ntotal,S=S_obs) |> 
  mutate(across(N:S,log,.names="log.{.col}"),
         across(c(p,k,log.N:log.S),f_z,.names = "{.col}_z"),
         SiteCode = factor(SiteCode)) |> 
  select(-c(N:log.S))
# df_md: dados necessários 
df_md <- df_ad |> 
  inner_join(df_contrastes |> 
               select(SiteCode:efeito_conf) |> 
               mutate(across(.cols=c(p,k,contains("efeito")),f_z,.names="{.col}_z")) |> 
               select(-c(p,efeito_area:efeito_conf)) |> 
               pivot_longer(starts_with("efeito_"),names_to="logOR_pair",values_to="contraste_z") |> 
               mutate(logOR_pair = case_when(logOR_pair == "efeito_area_z" ~ "non_frag.ideal",
                                             logOR_pair == "efeito_frag_z" ~ "cont.non_frag",
                                             TRUE ~ "cont.ideal")),
             by=c("SiteCode","k","logOR_pair")) |> 
  mutate(SiteCode = factor(SiteCode),
         land_hyp = factor(land_type),
         contrasteSAD_z = f(logOR_value)) |> 
  select(-land_type) |> 
  rename(nCong=nCongKS)
  # df_newdata
fwrite(df_md,"dados/csv/df_md_logOR.csv")
df_newpred <- fread(file="dados/csv/df_newpred.csv") |> 
  select(-starts_with("log_"))
# df_pred
# df_pred <- read_csv("dados/csv/resultados_MN/MNEE/df_pred.csv")
# df_newdat <- expand.grid(p_z = seq(min(df_ad$p_z),max(df_ad$p_z), length=150),
#                          k_cont_z = seq(min(df_ad$k_cont_z),max(df_ad$k_cont_z), length=150))
# df_newdat <- adply(df_newdat,1,.fun = \(x) cbind(x,distinct(select(df_ad,SiteCode,log_S_obs_z,log_Ntotal_z))))
# write_csv(df_newdat,"dados/csv/df_newdataSADs.csv")
#
# df_intePred_contrastes.csv
df_intPred <- fread("dados/csv/df_intePred_contrastes.csv")
# df_congContrastetsREP.cvs
df_congContrastes <- fread("dados/csv/resultados_MN/df_congContrastes.csv") |> 
  inner_join(df_md |> 
               select(SiteCode,p,k,logOR_pair,contraste_z),
             by=c("SiteCode","k","pair" = "logOR_pair")) |> 
  arrange(p) |> 
  relocate(p,.after=k) |> 
  mutate(SiteCode = factor(SiteCode))
# loads
# load("dados/Rdata/l_md.contrastes.Rdata")
# load("dados/Rdata/md_frag_area.Rdata")
# load("dados/Rdata/l_md_congContrastes.Rdata")
# load("dados/Rdata/l_md_PrCong.Rdata")
df_plot <- df_md |> select(SiteCode:nCong,p_z:k_z) |> 
  inner_join(df_p) |> 
  inner_join(df_dados_disponiveis |> 
               filter(forest_succession != "capoeira") %>% 
               select(SiteCode, forest_succession)) %>% 
  arrange(p) |> 
  mutate(succession = case_when(forest_succession == "primary" ~ "1°",
                                forest_succession == "secondary" ~ "2°",
                                forest_succession == "primary/secondary" ~ "1.5°"),
         label = paste0(SiteCode,", p=",round(p,2)," ,suc=",succession),
         k_f=factor(round(k,2))) %>% 
  select(-succession)
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
#
df_tif_txt <- read.csv(file="./dados/csv/df_txt_tif_landscape_paths.csv")
```

```{r trackdown chunk, include=FALSE,eval=FALSE}
# pacotes
library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
# upload_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
#             gpath = "mestrado/artigo_principal/apendices/",
#             hide_code = TRUE)
update_file(file ="apendices/A2_figuras_tabelas/A2_figuras_tabelas.Rmd",
            gpath = "mestrado/artigo_principal/apendices/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file = "secoes_texto/Resultados/Resultados.Rmd",
              gpath = "mestrado/artigo_principal/secoes_texto/")
```


<!-- # Texto e tabelas -->

<!-- Todas as análises dos dados foram feitas em R (REF). -->

<!-- ## GLMM binomial -->

<!-- Utilizamos funções do pacote lme4 (REF) para ajustar os GLMM binomiais. O modelo com estrutura aleatória mais complexa, com 1 intercepto e 1 inclinação no grau de limitação de dispersão por sítio de amostragem e tipo de paisagem hipotética, teve alerta de não convergência e mesmo depois de ajustar com outros otimizadores o alerta permaneceu. Como era um modelo que demorava muito para ajustar não fiz mais explorações com ele. Outro modelo explorado e descartado foi o modelo cheio que interpretava o grau de limitação de dispersão como variável categórica. Esse modelo demorou muito para rodar e sua execução foi interrompida antes de terminar a estimativa dos coeficientes. -->
<!-- A tabela de seleção, com o delta AICc e peso de evidência, foi obtida usando a função AICctab do pacote bbmle (REF) e os coeficientes de determinação foram obtidos usando a função r.squaredGLMM do pacote MuMIn (REF). -->
<!-- Avaliamos a qualidade de ajuste do modelo explorando os resíduos quantílicos (FIGURA A2 REF) usados no pacote DHARMa (REF). Também plotamos o predito e o observado (FIGURA A2 REF). -->

<!-- # Figuras  -->


# Sítios Selecionados

```{r caption 1}
cap <- "Sítios selecionados na base de dados TreeCo. a) latitude e longitude das coordenadas centrais dos inventários florestais. b) boxplot de variáveis dos inventários: área da parcela, número de indivíduos amostrado, riqueza de espécies observado, e ano da amostragem ou da publicação. c) Classificação do estado de conservação ou sucessional da área amostrada no inventário: primary (floresta primária, não-alterada, primitiva, old-growth (≥80 anos de sucessão) ); primary/secondary (floresta em estágio avançado de sucessão (50 a 80 anos de sucessão)); secondary (floresta secundária, alterada, em estágio médio de regeneração (20 a 50 anos de sucessão)); capoeira (floresta em estado inicial de sucessão (<20 anos de sucessão))."
```
```{r GE-sitios-amostrados criacao,eval=FALSE,include=FALSE}
df_plot <- df_dados_disponiveis |> 
  select(SiteCode, effort_ha, Ntotal, S_obs, year_bestProxy, forest_succession, lat:long_correct)
l_p <- list()
l_p[[1]] <- df_plot |> 
  ggplot(aes(y=lat,x=long)) +
  geom_point(alpha=0.5) +
  theme_light() +
  labs(subtitle = "a)")
v_labels <- c("effort_ha" = "plot area (ha)",
              "Ntotal" = "# ind",
              "S_obs" = "riqueza",
              "year_bestProxy" = "approx. data year")
df_plot[grep("\\_",df_plot$year_bestProxy),"year_bestProxy"] <- "2012.5"
l_p[[2]] <- df_plot |>
  mutate(year_bestProxy = as.numeric(year_bestProxy)) |> 
  pivot_longer(effort_ha:year_bestProxy) |> 
  ggplot(aes(x=name,y=value)) +
  geom_jitter(alpha=0.4) +
  geom_boxplot() +
  labs(x="",y="",subtitle="b)") +
  facet_wrap(~name,ncol=1,scales="free", labeller = as_labeller(v_labels), strip.position = "bottom") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        strip.background = element_blank(),
        strip.placement = "outside") +
  coord_flip()
l_p[[3]] <- df_plot |> 
  ggplot(aes(x=forest_succession)) +
  geom_bar() +
  geom_text(aes(label = after_stat(count)), stat = "count", vjust = -0.2, colour = "black") +
  labs(x="classificação de estágio sucessional do TreeCo",
       y="countagem",subtitle="c)")
save(l_p,file="./dados/Rdata/figA21.Rdata")
```
```{r GE-sitios-amostrados,fig.width=12,fig.height=6,fig.cap=cap,cache=TRUE,fig.pos="H"}
load("./dados/Rdata/figA21.Rdata")
grid.arrange(grobs=l_p,nrow=1)
```



## Paisagens Contemporâneas
```{r caption 2}
cap <- "Paisagens contemporâneas (4x4 km2) aos eventos de amostragem da SAD na área amostrada. Mapas de cobertura da coleção 6 do mapbiomas."
```
```{r fig-contempLandscape,fig.cap=cap,fig.pos="H",fig.width=figWidth,fig.height=figHeight}
v_pngfiles <- list.files(path="./dados/paisagens/png_land_sim/",pattern=".png",full.names = TRUE)
l_p <- v_pngfiles %>% ll_ggpng()
grid.arrange(grobs=l_p,ncol=10)
```


## Taxa U estimado em cada paisagem teórica

```{r caption GE  características dos Sítios Selecionados}
# caption
cap <- "Taxa U estimada em cada sítio nos 20 graus de limitação de dispersão simulados e coloridos pelo tipo de paisagem hipotética. Os sítios estão organizados pela proporção de cobertura vegetal na paisagem de 4x4 km2 (p). Nos rótulos dos paineis há o código do sítio de amostragem, a proporção de cobertura vegetal (p), e a classe do estágio sucessional da área amostrada segundo o TreeCo"
```
```{r figura GE características dos Sítios Selecionados, eval=FALSE,include=FALSE,fig.cap=cap}
# figura
df_plot <- df_Urep %>% select(-d) %>% 
  pivot_longer(-c(SiteCode:k),names_to = "rep",values_to = "U") |>
  inner_join(df_p) |> 
  arrange(p) |> 
  mutate(label = paste0(SiteCode,", p=",round(p,2)))
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
p <- df_plot |> 
  ggplot(aes(x=k,y=U,color=land_type)) +
  geom_point(alpha=0.1) +
  # geom_line() +
  stat_summary(geom = "line",fun.data = mean_se,alpha=0.5) +
  scale_x_reverse() +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
  theme_bw() +
  labs(color="landscape type") +
  theme(legend.position = "top",
        axis.text=element_text(size=4.5),
        strip.text = element_text(size = 4.5, margin = margin())) +
        # legend.title=element_text(size=v_titleS),
        # legend.text = element_text(size = v_titleS)) +
  scale_color_manual(values=c("darkred","darkblue","darkgreen"),
                     labels=c("contemporâneo","idealizado","sem fragmentação")) +
  facet_wrap(~label,ncol=v_ncol_fatetwrap,scales="free")
save(p,file="./dados/Rdata/figA23.Rdata")
```
```{r GE-Urep-sitio-k-land,eval=TRUE,fig.height=figHeight,fig.width=figWidth,fig.cap=cap,fig.pos="H"}
load("./dados/Rdata/figA23.Rdata")
p
```


\newpage

```{r preditoras empiricas criacao codigo,eval=FALSE,include=FALSE}
# ajuste dos modelos
df_md <- df_plot %>% select(SiteCode,forest_succession,p) %>% distinct() %>% 
  mutate(logit_p = car::logit(p=p))
l_md <- list()
l_md[[1]] <- lm(formula = logit_p ~ forest_succession,data = df_md)
l_md[[2]] <- lm(formula = logit_p ~ 1,data = df_md)
names(l_md) <- c("~forest suscession","~1")
# construção dos dados
## tabela de seleção
df_AICctab <- AICctab(l_md,weights=TRUE) %>% as.data.frame()
df_AICctab$modelo <- row.names(df_AICctab)
md_p_fsc <- l_md[[row.names(df_AICctab)[1]]]
row.names(df_AICctab) <- NULL
df_AICctab$R2 <- sapply(l_md,\(x) summary(x)$adj.r.squared)
df_AICctab <- df_AICctab %>% relocate(modelo) %>% mutate(across(2:5,\(x) round(x,digits=3)),
                                                         R2 = R2*100) %>% 
  rename(`R2(%)`=R2)
## tabela do modelo mais plausível
df_plot1 <- broom::tidy(md_p_fsc) %>% 
  mutate(`IC upp` = estimate + std.error,`IC low` = estimate - std.error) %>% 
  select(-c(std.error:p.value)) %>% 
  mutate(across(c(-term),\(x) exp(x)/(1+exp(x)))) %>% 
  pivot_longer(-term) %>% 
  rename(forest_succession = term) %>%
  mutate(forest_succession = case_when(forest_succession == "(Intercept)" ~ "primary",
                                       forest_succession == "forest_successionprimary/secondary" ~ "primary/secondary",
                                       TRUE ~ "secondary"))
df_table <- broom::tidy(md_p_fsc) %>% 
  mutate(`IC upp` = estimate + std.error,`IC low` = estimate - std.error) %>% 
  select(-c(std.error:statistic)) %>%
  mutate(across(c(-term,-p.value),\(x) exp(x)/(1+exp(x)))) %>% 
  rename(`forest succession` = term) %>%
  relocate(p.value,.after = last_col()) %>% 
  mutate(`forest succession` = case_when(`forest succession` == "(Intercept)" ~ "primary",
                                         `forest succession` == "forest_successionprimary/secondary" ~ "primary/secondary",
                                          TRUE ~ "secondary")) %>% 
  mutate(across(2:4,\(x) round(x,3)))
df_p2 <- data.frame(x = rep(1:3,1),
                    y_0 = df_plot1 %>% filter(name=="IC low") %>% pull(value),
                    y_1 = df_plot1 %>% filter(name=="IC upp") %>% pull(value))
# obj para ggplot2
v_colors <- c("black",rep("darkred",2))
names(v_colors) <- df_plot1$name %>% unique()
# gráficos
library("ggpmisc")
l_p <- list()
l_p[[1]] <- ggplot() + theme_void() + annotate(geom="table",x=1,y=1,label = list(df_AICctab)) + 
  labs(title="Seleção de Modelos",subtitle = "~N(logit(p),sd)") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 0),
        plot.subtitle = element_text(hjust = 0.5, vjust = 0))
l_p[[2]] <- df_plot %>% 
  ggplot(aes(x=forest_succession,y=p)) +
  geom_jitter(alpha=0.6) +
  geom_point(data=df_plot1,aes(x=forest_succession,y=value,color=name),shape="_",size=15) +
  geom_segment(data = df_p2,aes(x=x,xend=x,y=y_0,yend=y_1,group=x)) +
  scale_color_manual(values=v_colors) +
  geom_vline(xintercept = c(1.5,2.5)) + 
  theme(legend.title = element_blank(),
        legend.position = "top",
        legend.margin = margin(0, 0, 0, 0),
        legend.box.spacing = unit(0, "pt"),
        plot.title = element_text(hjust = 0.5, vjust = -1),
        axis.title.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(size=1))) +
  labs(x="classe de sucessão",title="Modelo mais plausível")
l_p[[3]] <- ggplot() +
  theme_void() +
  annotate(geom = "table",
           x = 1,
           y = 1,
           label = list(df_table)) + labs(title="Coef. modelo mais plausível") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 0))
save(l_p,file="./figuras/figSI2_relacaoPredEmp_normal_logit_p.Rdata")
load(file="./figuras/figSI2_relacaoPredEmp_normal_logit_p.Rdata")
grid.arrange(grobs=l_p,layout_matrix=rbind(c(1,3,3),
                                           c(2,2,2),
                                           c(2,2,2),
                                           c(2,2,2),
                                           c(2,2,2)),
             top="PREDITORAS EMPÍRICAS")
```
```{r caption preditoras empiricas}
cap <- "Modelos Lineares Gaussianos da relação entre as preditoras empíricas (p e classe de sucessão). A estimativa da média de p diferem entre as classes de sucessão. Para ajustar os modelo normais p foi transformada usando a função logito."
```
```{r preditoras-empiricas-SI,fig.cap=cap,fig.pos="H",eval=FALSE,include=FALSE}
p <- ll_ggpng("./figuras/figSI_2.png")[[1]]
p
```


# Congruência com a SAD Observada 



```{r ggplot2code GE nCong,eval=FALSE,include=FALSE,cache=TRUE}
df_plot <- df_md |> select(SiteCode:nCong,p_z:k_z) |> 
  inner_join(df_p) |> 
  inner_join(df_dados_disponiveis |> 
               filter(forest_succession != "capoeira") %>% 
               select(SiteCode, forest_succession)) %>% 
  arrange(p) |> 
  mutate(label = paste0(SiteCode,", p=",round(p,2)))
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
#
f_plot <- \(nvresp="nCong",
            png_repo = "apendices/analise_dados/figuras/",
            end_name = "_k_land.hyp_site"){
  f_ <- \(dfi){
    dfi %>% 
      ggplot(aes(x=k,y=.data[[nvresp]],color=land_hyp,fill = p)) +
      geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)) +
      geom_point(alpha=0.5) +
      geom_line(alpha=0.5) +
      scale_x_reverse() +
      theme_bw() +
      labs(color="landscape hyp.") +
      theme(legend.position = "top",
            axis.text=element_text(size=4.5),
            axis.title = element_text(size = 20),
            strip.text = element_text(size = textsize, margin = margin())) +
            # legend.title=element_text(size=v_titleS),
            # legend.text = element_text(size = v_titleS)) +
      scale_color_manual(values=c("darkred","darkblue","darkgreen"),
                         labels=c("contemporâneo","idealizado","sem fragmentação")) +
      scale_fill_gradientn(colours = terrain.colors(10),trans="reverse",values = c(0,0.5,1),guide = "none") +
      # scale_fill_gradient2(low="white",mid = "brown",high="green",midpoint = 0.5,limi)
      facet_wrap(~label,ncol=5)
  }
  l_p <- dlply(df_plot,"forest_succession",f_)
  l_p <- alply(names(l_p),1,\(nli){
    l_p[[nli]] + labs(title = nli) + theme(plot.title = element_text(hjust = 0.5))
  })
  save(l_p,file=paste0("./dados/Rdata/",nvresp,end_name,".Rdata"))
}
f_plot()
########
nvresp="nCong";png_repo = "apendices/analise_dados/figuras/";end_name = "_k_land.hyp_site"
oname <- load(file=paste0("./dados/Rdata/",nvresp,end_name,".Rdata"))
l_p <- get(oname)
laymat <- cbind(rep(1,10),
                c(rep(2,6),NA,NA,NA,NA),
                c(rep(3,6),NA,NA,NA,NA))
legend_position="top"
plot_table <- ggplot_gtable(ggplot_build(l_p[[1]])) # get tabular interpretation of plot 
index_legend_plot <- which(sapply(plot_table$grobs, function(x) x$name) == "guide-box") #  Mark only legend in plot 
common_legend <- plot_table$grobs[[index_legend_plot]] # extract legend 
# títulos associados
l_title <- llply(l_p,\(li){
  p_title <- ggplot_gtable(ggplot_build(li))  
  index_title <- str_which(sapply(p_title$grobs, function(x) x$name),"plot.title")
  p_title$grobs[[index_title]] 
})
# remoção dos títulos e das legendas
l_p <- llply(l_p,\(li){
  # arrumar título
  p_title <- ggplot_gtable(ggplot_build(li))  
  index_title <- str_which(sapply(p_title$grobs, function(x) x$name),"plot.title")
  p_title <- p_title$grobs[[index_title]] 
  # remoção de legenda e ajuste eixos
  li +  
    theme(legend.position = "none",
          plot.title = element_blank(),
          axis.title = element_text(size = textsize)) +
    labs(y="#SADs cong")
  # # arranjo dos gráficos
  })
arrenged_plot <- arrangeGrob(grobs=l_p,layout_matrix = laymat)
arrenged_plot <- arrangeGrob(arrangeGrob(grobs = l_title,nrow = 1),
                             arrenged_plot,
                             heights = c(0.5, 10))
if(legend_position=="bottom"){
  p <- arrangeGrob(common_legend,arrenged_plot,ncol=1,heights = c(10, 1))
}else if(legend_position=="top"){
  p <- arrangeGrob(common_legend,arrenged_plot,ncol=1,heights = c(1, 10))
}
l_plot <- list()
l_plot[[1]] <- p %>% as_ggplot()
l_plot[[2]] <- df_plot %>% filter(k==0.05,land_hyp=="cont") %>% distinct() %>%
  ggplot(aes(x=forest_succession,y=p,colour=p)) +
  geom_boxplot() +
  geom_jitter(size=2) +
  theme_grey() +
  scale_colour_gradientn(colours = terrain.colors(10),trans="reverse",values = c(0,0.5,1),
                         guide=guide_colourbar(reverse = TRUE,barheight = 15)) +
  scale_x_discrete(labels=c("secondary" = "2a", "primary" = "1a", "primary/secondary"="1a/2a")) +
  theme(legend.position = "left",
        # axis.text.y=element_blank(),
        # axis.ticks.y=element_blank(),
        # axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  labs(x="forest succession")
save(l_plot,file="./figuras/fig6_final.Rdata")
#
v_size = 3
# v_w <- 860
png("./figuras/fig6_final.png",width = 743 * v_size, height = 712 * v_size,res = 72 * v_size)
l_plot[[1]]
print(l_plot[[2]],vp=viewport(0.85, 0, 0.3, 0.3,just = "bottom"))
dev.off()
```
```{r caption GE nCong }
cap <- "Número de SADs simuladas congruentes com a SAD empírica (eixo y). A classificação da SAD simulada como congruente ocorreu quando a comparação entre SADs segundo um teste de Kolmogorov-Smirnov apresentou p-valor igual ou maior do que 0.05. No eixo x há o grau de limitação de dispersão per capita (k). Os pontos são coloridos pelo tipo de paisagem hipotética pressuposta pela simulação. Os paíneis estão organizados pela proporção de cobertura vegetal na paisagem ao redor de 4x4km2."
```
```{r GE-nCong,eval=TRUE,fig.height=10,fig.width=figWidth,fig.cap=cap,fig.pos="H",cache=FALSE}
p <- ll_ggpng("./figuras/fig6_final.png")[[1]]
p
# load("./figuras/fig6_final.Rdata")
# l_plot[[1]]
# print(l_plot[[2]],vp=viewport(0.70, 0, 0.3, 0.3,just = "bottom"))
```

## Gráficos da distribuição espacial do padrão observado 


```{r caption next figure}
cap <- "Distribuição espacial da avaliação visual e das preditoras empíricas. Na primeira linha (a e b) as classificações visuais do padrão de congruência com o observado: a) diferença entre as paisagens hipotéticas; b) congruência do predito pelo modelo neutro (independente do tipo de paisagem) com a SAD observada ao longo dos graus de dispersão simulados. Na segunda linha (c e d) as preditoras empíricas: c) proporção de cobertura vegetal (p); e d) classe de sucessão ecológica do TreeCo (primary =>80 anos desde o dist., primary/secondary = entre 80 e 50 anos, secondary = entre 50 e 20 anos)"
```
```{r GE-coordenadas-preditoras,fig.cap=cap,fig.height=10,fig.width=10}
# Install and load necessary packages
# library(sf)
# dados
df_class <- read.csv(file="./dados/csv/df_class.csv")
# df_class$land_diff %>% table()
v_landdiff <- df_class$land_diff %>% unique()
# df_class$Cong %>% table()
v_cong <- df_class$Cong %>% unique()
df_class <- df_class %>% mutate(
  classi_land = case_when(land_diff %in% c("similar","igual") ~ "similares",
                          land_diff %in% v_landdiff[str_which(v_landdiff,"contemp")] ~ "contemp. dif.", 
                          land_diff %in% v_landdiff[str_which(v_landdiff,"ideal")] ~ "ideal.\ndif.",
                          land_diff == "sem frag pior" ~ "sem frag.\ndif."),
  classi_land2 = case_when(land_diff %in% v_landdiff[str_which(v_landdiff,"contemp")] ~ gsub("contemp ","cont. \n",land_diff),
                           TRUE ~ classi_land),
  classi_cong = case_when(Cong %in% c("ruim exceto em graus brandos","melhor em graus brandos") ~ "boa em brandos",
                          Cong == "ruim em intermediário e boa em graus brandos" ~ "ruim em intermed",
                          TRUE ~ Cong)) %>% 
  select(-land_diff,-Cong)
df_class$classi_cong <- gsub(" graus","",df_class$classi_cong) %>% 
  gsub("intermediários","intermed",.) %>% 
  gsub(" em"," em\n",.)
#
df_plot <- df_md |> select(SiteCode:nCong,p_z:k_z) |> 
  inner_join(df_p) |> 
  inner_join(df_dados_disponiveis |> 
               filter(forest_succession != "capoeira") %>% 
               select(SiteCode, forest_succession)) %>% 
  arrange(p) |> 
  mutate(succession = case_when(forest_succession == "primary" ~ "1°",
                                forest_succession == "secondary" ~ "2°",
                                forest_succession == "primary/secondary" ~ "1.5°"),
         label = paste0(SiteCode,", p=",round(p,2)," ,suc=",succession)) %>% 
  select(-succession)
df_plot$label <- factor(df_plot$label,levels=unique(df_plot$label))
df_plot <- inner_join(df_plot,df_class) %>% 
  inner_join(.,df_dados_disponiveis %>% select(SiteCode, lat:long_correct))
#
v_labels <- c("classi_land2"="a) Diferença entre paisagens","classi_cong"="b) Congruência do modelo neutro",
              "p"="c) % cobertura vegetal (p)","forest_succession"="d) classe de tempo desde o último dist. no local")
l_vcolors <- list()
# l_vcolors[[1]] <- c("similares"="black","sem frag. dif."="#003300","contemp. dif."="#CC0000","ideal. dif."="darkblue")
l_vcolors[[1]] <- c("similares"="black","sem frag.\ndif."="#003300","ideal.\ndif."="darkblue",
                    "cont. \nmelhor"="darkred","cont. \npior"="#E69F00","cont. \ndiferente"="darkgrey")
l_vcolors[[2]] <- c("boa"="#003300","boa exceto em\n brandos"="yellow","boa em\n intermed"="darkblue","boa em\n brandos"="purple","ruim em\n intermed"="#CC0000","ruim"="#FF0000")
l_vcolors[[3]] <- NA
l_vcolors[[4]] <- c("secondary"="darkblue","primary/secondary"="darkred","primary"="darkgreen")
names(l_vcolors) <- names(v_labels)
#
f_plot <- \(cname){
  v_colors <- l_vcolors[[cname]]
  p <- df_plot |> 
  mutate(lat=ifelse(is.na(lat),lat_correct,lat),
         long=ifelse(is.na(long),long_correct,long)) %>% 
  filter(k==0.05,land_hyp=="cont") %>% 
  ggplot(aes(y=lat,x=long,color=.data[[cname]])) +
    geom_point(shape=15,size=5,alpha=0.8) + # alpha=0.5
    {if(cname=="p") scale_colour_gradientn(colours = terrain.colors(10),
                                           trans="reverse") else scale_color_manual(values=v_colors)} +
    theme_light() +
    theme(legend.position = c(.95, .35),
          legend.title = element_blank(),
          # aspect.ratio = 1,
          legend.justification = c("right", "top"),
          legend.box.just = "right",
          legend.margin = margin(0, 0, 0, 0)
          # legend.background = element_blank(),
          # legend.box.background = element_rect(colour = "black")
          ) +
    # guides(color = guide_legend(override.aes = list(size = 1))) +
    labs(subtitle = v_labels[cname])
  p_return <- if(cname!="p"){
    p + theme(legend.background = element_blank(),legend.box.background = element_rect(colour = "black"))
  }else{
    p
  }
  return(p_return)
}
l_p <- alply(names(v_labels),1,f_plot)
grid.arrange(grobs=l_p,ncol=2)
# save(p,file="./dados/Rdata/coordenadas_preditoras.Rdata")
```
```{r GE-coordenadas-preditoras0,fig.cap=cap,eval=FALSE}
# load(file="./dados/Rdata/coordenadas_preditoras.Rdata")
# p
```



\newpage

## Predito para o contraste na taxa U entre paisagens

```{r ip contrastes ~ p k,fig.height=figHeight,fig.width=figWidth,eval=FALSE,include=FALSE}
df_plot <- df_intPred |> 
  mutate(p = p_z*sd(df_ad$p) + mean(df_ad$p),
         k = k_z*sd(df_ad$k) + mean(df_ad$k),
         name=factor(name,levels=paste0("efeito_",c("area","frag","contemp")))) |> 
  select(-contains("_z"),-predito) |> 
  pivot_longer(starts_with("Q_0."),values_to = "pred",names_to = "label")
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label)[c(3,2,4,1,5)])
# gráficos
v_range <- range(df_plot$pred)
v_breaks1 <- c(-0.2,0,0.2,0.5,1)
f_plot <- function(df){
  f_ggplot <- function(df,facets=2){
  ggplot(df,aes(x=p,y=k,z=pred,fill=pred)) +
    geom_raster() +
    geom_contour(aes(z=pred),
                 size=0.5,color="darkblue",
                 breaks=v_breaks1) +
    geom_text_contour(aes(z=pred),
                      breaks=v_breaks1,
                      label.placer = label_placer_flattest()) +
    scale_fill_gradient2(low="green",
                         mid="red",
                         high="black",
                         midpoint = 0.5,
                         limits=v_range,
                         # round(seq(v_range[1],v_range[2],length.out = 5)[1:4],2)
                         breaks=v_breaks1) +
    scale_y_reverse() +
    theme_classic() +
    guides(fill = guide_colourbar(title = gsub("efeito_","",df$name[1]))) +
    coord_cartesian(expand = FALSE) +
    labs(fill=df$name[1]) +
    facet_wrap(~label,ncol = facets,scales="free")
  }
  l_p <- list()
  l_p[[1]] <- df |> 
    filter(label == "Q_0.5") |>
    f_ggplot() + labs(x="")
  l_p[[2]] <- df |> 
    filter(label != "Q_0.5") |>
    f_ggplot()
  ggpubr::ggarrange(plotlist = l_p,nrow=2, common.legend = TRUE, legend="top")
}
l_plot <- dlply(df_plot,"name",f_plot)
p <- grid.arrange(grobs=l_plot,ncol=3)
ggsave("figuras/FigFinal_contrastes.png",p,
       width = 13,
       height = 9)
```
```{r}
cap <- "Predito para os contrastes na taxa U entre paisagens hipotéticas. Para cada sítio e grau de limitação de dispersão foi calculada a diferença entre a média da taxa U entre pares de paisagens hipotéticas e então dividido pela média na paisagem idealizada. Os contrastes são: área (sem fragmentação -  idealizado); fragmentação per se (contemporâneo - sem fragmentação); contemporaneidade (contemporâneo - idealizado). Um GAMM com distribuição normal foi ajustado aos contrastes observados (com splines indivíduais para p e k, tensor entre p e k, e com splines aleatórios de k para cada sítio de amostragem), o intervalo de predição foi construído pressupondo que os coeficientes do GAMM podem ser bem aproximados por uma normal multivariada e então 10 mil sorteios foram feitos dessa normal multivariada e para cada uma foi obtido uma predição. Na figura há os quantis da distribuição de predições."
```
```{r contrastes-taxaU,fig.cap=cap}
p <- ll_ggpng("figuras/FigFinal_contrastes.png")[[1]]
p
```




<!-- antigo -->

```{r include=FALSE,eval=FALSE}
cap <- "Gráficos diagnósticos"
```
```{r fig-DHARMaResidual,fig.cap=cap,fig.pos="H",include=FALSE,eval=FALSE}
oname <- load(file="./dados/Rdata/glmm_nCong_selecionado.Rdata",verbose = TRUE)
l_md_e_start <- get(oname)
p_plot <- simulateResiduals(l_md_e_start$modelo,n = 1000)
plot(p_plot)
```

```{r caption 3,include=FALSE,eval=FALSE}
cap <- "Observado e predito para o número de SADs simuladas congruentes com a SAD observada."
```
```{r fig-preditoObs,fig.cap=cap,fig.pos="H",include=FALSE,eval=FALSE}
oname <- load(file="./dados/Rdata/glmm_nCong_selecionado.Rdata",verbose = TRUE)
l_md_e_start <- get(oname)
df_obs <- l_md_e_start$modelo@frame[,-1]
df_obs$nCong <- l_md_e_start$modelo@frame[,1][,1]
df_obs$predito <- predict(l_md_e_start$modelo,type="response")*sum(l_md_e_start$modelo@frame[,1][1,])
df_obs %>% 
  ggplot(aes(x=nCong,y=predito,group=SiteCode)) +
  geom_line(alpha=0.4) +
  geom_point(alpha=0.4) +
  geom_abline(intercept = 0,slope=1,color="red")+
  facet_grid(land_hyp~forest_succession)
```
