---
title: Determinação da extensão espacial da paisagem local
authors:
  - name: Danilo Pereira Mori
    affiliation: LET - IBUSP
# bibliography: references.bib
# biblio-style: unsrt
# output: rticles::arxiv_article
output: html_document
editor_options: 
  chunk_output_type: console
---

## Introdução

<p> Aqui determino a extensão espacial da paisagem local ao redor da parcela amostrada usando a análise de escala de efeito (REF). A análise de escala de efeito se baseia em determinar a extensão espacial da paisagem local que maximiza o peso de evidência da regressão entre o número de espécies na parcela e a proporção de cobertura vegetal dos 109 sítios de amostragens selecionados na base TreeCo. Primeiro calculamos a proporção de cobertura vegetal para paisagens locais quadradas em que variamos a extensão espacial da paisagem. Fizemos uma sequência de extensões espaciais somando 0.12 km no lado da paisagem. A menor paisagem apresentou 0.3km de lado,  aproximadamente o lado da maior parcela caso ela fosse quadrada (área de  10.24 ha, lado de 0.32 km). E a maior extensão espacial apresentou 22.26 km de lado. Ao todo foram 184 extensões espaciais. Então é calculado o peso de evidência da regressão para cada extensão espacial. Aquela extensão que atribuir maior peso de evidência será selecionada para determinar a extensão espacial da paisagem local.</p>  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# pacotes
library(doMC)
library(raster)
library(bbmle)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(plyr)
library(dplyr)
select <- dplyr::select
# dados
getwd()
df_dados <- read_csv(file = "./dados/df_dados_disponiveis.csv") |> 
  mutate(year_bestProxy = ifelse(is.na(year_data),year,year_data),
         tif.path = list.files(path="./dados/paisagens_mapbiomas6_padronizadas/",pattern = ".tif",full.names=T)) |> 
  select(SiteCode,effort_ha,year_bestProxy,Ntotal,S_obs,tif.path)
```

#### Análise exploratória variáveis primárias: S_obs e Ntotal

```{r análise exploratória variáveis primárias Sobs e Ntotal,echo=FALSE}
df_dados |> 
  ggplot(aes(x=Ntotal,y=S_obs)) + 
  # geom_smooth() +
  geom_point(alpha=0.5) + 
  labs(title="S_obs = Riqueza observada; Ntotal = total indivíduos")
```

__Figura 1__ Análise exploratória variáveis primárias: riqueza observada (S_obs) e número total de indivíduos (Ntotal)

### 1o Passo: calcular a proporção de cobertura vegetal para cada extensão espacial

```{r calcular a prop CV para cada extensão espacial,eval=FALSE}
f_pEscalas <- function(df){
  df_p <- data.frame(p = NA, lado_km = NA)
  m_full <- raster(df$tif.path) |> raster::as.matrix()
  i_centro <- nrow(m_full)/2
  v_last_i <- (i_centro-5+2)/2
  for(i in 1:v_last_i){
    v_add <- 5+2*(i-1)
    m_i <- m_full[(i_centro+1-v_add):(i_centro+v_add),
                  (i_centro+1-v_add):(i_centro+v_add)]
    df_p[i,] <- c(length(m_i[m_i==1])/length(m_i),
                  nrow(m_i) * 30/1000)
  }
  df_p$SiteCode <- df$SiteCode
  return(df_p)
}
registerDoMC(3)
df_pEscalas <- adply(df_dados,1,f_pEscalas,.id = "SiteCode",.parallel = TRUE)
write_csv(x = select(df_pEscalas,Ntotal,S_obs,p:SiteCode),
          file = "./dados/csv/df_EscalaEfeito.csv")
```

## análise de escala de efeito

Para determinar a extensão espacial da escala de paisagem 

```{r dados para analise de escala de efeito usando MNEE,echo=FALSE}
# sítios
df_DA <- read_csv("dados/df_dados_disponiveis.csv") |> select(SiteCode,effort_ha)
df_sitios <- read_csv("./dados/csv/df_EscalaEfeito.csv") |> 
  filter(lado_km == 16.02) |> arrange(p) |> 
  inner_join(df_DA,by="SiteCode") |> 
  mutate(tif.path = paste0("dados/paisagens_mapbiomas6_padronizadas//",SiteCode,".tif"),
         DA = Ntotal/effort_ha)
# sítios para escala de efeito
df_SoE <- df_sitios |> head(n=5) |> rbind(filter(df_sitios,p == max(df_sitios$p)))
```


```{r funções para ajuste do mapa de cobertura vegetal para as simulacoes de MNEE, echo=TRUE,eval=FALSE}
## funções
# função para ajustar resolução de um arquivo png
func_png.ajust <- function(file, densidade){ # atualizar para o pacote 'magick'
  system(paste(
    "convert ",file, " -resize ", densidade*A_landscape,"@ ", file,  
    sep = ""
  ))
}
# função para desenhar a área amostral quadrada com N indivíduos
f_area.simulada <- function(matriz, N, coordenada_central=TRUE,index_janela=8/4){
  # determinação da matriz para aplicçaão da rotina: usar a coordenada central do tif ou uma janela com nova coordenada central?
  if(coordenada_central){
    l <- ceiling(dim(matriz)[1]/2)
    c <- ceiling(dim(matriz)[2]/2)
    d <- ceiling(sqrt(N)*index_janela)
    m_temp <- matriz[(l-d):(l+d),(c-d):(c+d)]
  } else{
      m_temp <- matriz
    }
  # Janela de preparo é suficiente para criar a área da parcela?
  if(length(m_temp[m_temp==1]) < N) { 
    stop("habitat insuficiente na janela de observação")
  } else if (length(m_temp[m_temp==1]) == N) { 
    stop("area amostral igual janela de observacao")
  } else { # caso seja adequado, use esse código antigo e misterioso:
    col_cresc <- which(m_temp==m_temp, arr.ind = T)
    col_decre <- col_cresc[dim(col_cresc)[1]:1,]
    row_cresc <- col_cresc[order(col_cresc[,1],decreasing = FALSE),] 
    row_decre <- row_cresc[dim(col_cresc)[1]:1,] 
    ciclo <- (dim(m_temp)[1]-1)/2
    l_mat_index <- list()
    dim_temp <- dim(m_temp)[1]
    for(i in 1:ciclo){
      a1 <- col_cresc[col_cresc[,"col"]==i,]
      b1 <- row_cresc[row_cresc[,"row"]==dim_temp+1-i,]
      c1 <- col_decre[col_decre[,"col"]==dim_temp+1-i,]
      d1 <- row_decre[row_decre[,"row"]==i,]
      l_mat_index[[i]] <- do.call(rbind,list(a1,b1,c1,d1))
    }
    l_mat_index[[(dim_temp+1)/2]] <- col_cresc[col_cresc[,"col"]==(dim_temp+1)/2,]
    mat_ref <- unique(do.call(rbind, l_mat_index))
    length_ref <- length(m_temp[mat_ref][m_temp[mat_ref]==1])
    m_temp[mat_ref][m_temp[mat_ref]==1][(1+length_ref-N):length_ref] <- 2
  }
  # se tiver usado a coordenada central então retorne a paisagem completa
  if(coordenada_central){
   matriz[(l-d):(l+d),(c-d):(c+d)] <- m_temp
   return(matriz)
  } else{ # se tiver usado a janela centrada em outra coordenada, apenas a matrix de trabalho
     return(m_temp)
   }
}
# função que aplica as duas funções anteriores e salva o resultado em .txt
f_landscape_for_MNEE <- function(df){
  # leitura e preparo da paisagem .tif
  m_raster <- as.matrix(raster(df$tif.path))
  i_centro <- nrow(m_raster)/2
  i_ladoKm <- df$lado_km * 1000/60
  m_i <- m_raster[(i_centro+1-i_ladoKm):(i_centro+i_ladoKm),
                  (i_centro+1-i_ladoKm):(i_centro+i_ladoKm)]
  # escrita da paisagem no temporario .png
  png.path <- tempfile(fileext = ".png")
  png::writePNG(image = m_i,target = png.path)
  # processamento para MNEE
  A_landscape <- (df$lado_km ^ 2) * 100
  func_png.ajust(file=png.path,densidade = df$DA)
  m_png <-  png::readPNG(png.path) |> as.matrix()
  m_png[m_png>=0.7] <- 1
  m_png[m_png<0.7] <- 0
  mat_tri <- try(f_area.simulada(matriz = m_png, N = df$Ntotal))
  # salvamento no formato .txt
  if(is.matrix(mat_tri)){ 
    try(write.table(x = mat_tri, 
                    file = paste0("dados/simulacao//",df$SiteCode,".txt"),
                    sep = " ", row.names = FALSE, col.names = FALSE))
  } else{print("f_area.simulada: not a matrix")}
  unlink(png.path)
}
```

```{r rotina para processar as paisagens,eval=FALSE}
a_ply(df_SoE,1,f_landscape_for_MNEE)
```

```{r df_auditoria,echo=FALSE}
df_auditoria <- data.frame(txt.path = list.files(path = "dados/simulacao",pattern = ".txt",full.names = T)) |> 
  mutate(SiteCode = str_extract(txt.path,"(?<=o\\/).*?(?=.txt)")) |> 
  inner_join(select(df_SoE,-tif.path),by = "SiteCode")
```
```{r auditoria das paisagens,eval=FALSE}
f_auditoria <- function(path_name){
  m <- read_table(file = path_name) |> as.matrix()
  d <- ceiling(sqrt(2500)*2)
  l <- ceiling(dim(m)[1]/2)
  c <- ceiling(dim(m)[2]/2)
  m_temp <- m[(l-d):(l+d),(c-d):(c+d)]
  image(m_temp,main=str_extract(path_name,"(?<=cao\\/).*?(?=\\.txt)"))
}
sapply(df_auditoria$txt.path,f_auditoria)
```

```{r aglomeração do habitat na parcela local,echo=TRUE,eval=FALSE}
# funções
f_nova_parcela <- function(df){
  par(mar=c(0.2,0.2,1.2,0.2),
      mfrow=c(1,1))
  N <- df$Ntotal
  paisagem <- read_table(file = df$txt.path) |> as.matrix()
  # janela de observação
  d <- ceiling(sqrt(N)*(8/4))  # metade do lado do janela de observação
  l <- ceiling(dim(paisagem)[1]/2) # linha central da paisagem
  c <- ceiling(dim(paisagem)[2]/2) # coluna central da paisagem
  m_janela_original <- paisagem[(l-d):(l+d),(c-d):(c+d)]
  m_janela_original[round(nrow(m_janela_original)/2,0),round(ncol(m_janela_original)/2,0)] <- 1.5
  # visualização
  image(m_janela_original,col=terrain.colors(12,rev = TRUE))
  abline(h=0.5)
  abline(v=0.5)
  # remoção da parcela original
  m_janela_nova <- m_janela_original
  m_janela_nova[m_janela_nova>1] <- 1
  paisagem[(l-d):(l+d),(c-d):(c+d)] <- m_janela_nova
  # locator
  coordenada_ <- locator(1) |> unlist()
  l2 <- round(coordenada_[1]*nrow(m_janela_nova)) #linha
  c2 <- round(coordenada_[2]*ncol(m_janela_nova)) #coluna
  #
  m_janela_nova[round(nrow(m_janela_nova)/2,0),round(ncol(m_janela_nova)/2,0)] <- 1.5
  m_janela_nova[l2,c2] <- 1.5
  image(m_janela_nova)
  l1 <- round(nrow(m_janela_nova)/2,0)
  c1 <- round(ncol(m_janela_nova)/2,0)
  add_l = l2-l1
  add_c = c2-c1
  # nova parcela
  m_nova_parcela <- paisagem[(l+add_l-d):(l+add_l+d),(c+add_c-d):(c+add_c+d)]
  # função para desenhar nova parcela
  m_nova_parcela <- f_area.simulada(matriz = m_nova_parcela,
                                    N = df$Ntotal,
                                    coordenada_central = FALSE)
  paisagem[(l+add_l-d):(l+add_l+d),(c+add_c-d):(c+add_c+d)] <- m_nova_parcela
  # print da mudança
  par(mfrow=c(1,2))
  image(m_janela_original,main=df$SiteCode)
  m_nova_parcela <- paisagem[(l-d):(l+d),(c-d):(c+d)]
  image(m_nova_parcela,main="deslocada do centro")
  #
  return(paisagem)
}
```

```{r}
# v_Sites__conserto <- "MGuberl7"
df_correcao <- df_auditoria |> filter(SiteCode == "PRipir")
m_paisagem_corrigida <- f_nova_parcela(df_correcao)
write.table(x = m_paisagem_corrigida,
            file = df_correcao$txt.path,
            sep = " ", row.names = FALSE, col.names = FALSE)
```


# Support Information

## análise de escala padrão

### 2o Passo: Ajustar os modelos para um mesmo lado_km

S_obs = riqueza observada na parcela;  
  
p = proporção de cobertura vegetal;  
  
Ntotal = número de indivíduos vivos na parcela;  
  
lado_km = lado da paisagem ao redor em km;  
  
SiteCode = código do sítio de observação, cada sítio possui um mapa de paisagem.  
  

### análise de escala padrão

Na análise de escala de efeito padrão, um GLM binomial negativo, descrevendo a riqueza observada em função de um polinômio da cobertura vegetal (p) e do log do número de indivíduos na amostra, é ajustado para cada lado da paisagem. Essa abordagem apresenta alguns problemas pois não ocnsidera: a colinearidade dos valores de p entre lados da paisagem e a autocorrelação espacial entre sítios próximos (REF). Contudo, essa ainda é a abordagem mais executada (REF) e foi usada aqui para comparar com a seleção da escala de efeito que fizemos via simulação de MNEE.

```{r 2o passo}
f_glm.nb <- function(data_){
  md_ <- MASS::glm.nb(S_obs ~ poly(p, 3) + log(Ntotal), data = data_)
}
registerDoMC(3)
l_md <- dlply(df_se,"lado_km",f_glm.nb,.parallel = TRUE)
```

### 3o Passo: Calcular o peso de evidência por lado da paisagem local (km)

```{r 3o passo,results='hide'}
df_averageSE <- print(AICctab(l_md,weights=TRUE),min.weight=10^(-10)) %>% 
  as.data.frame()
df_averageSE$lado_km <- row.names(df_averageSE) %>% as.numeric()
df_averageSE$weight <- as.numeric(as.character(df_averageSE$weight))
df_averageSE$dAICc <- as.numeric(as.character(df_averageSE$dAICc))
```
  
    
### 4o Passo: Selecionar o lado da paisagem local que atribuiu maior peso de evidência

```{r 4o passo,echo=FALSE}
v_lado_max_weight <- df_averageSE |> filter(weight==max(df_averageSE$weight)) |> pull(lado_km)
df_averageSE |> 
  ggplot(aes(x=lado_km,y=weight)) +
  geom_line() +
  labs(title = paste0("O maior weight foi no maior lado = ",v_lado_max_weight,"km"))
```

__Figura 2__ Peso de evidência pelo lado da paisagem local.

### Avaliação

#### Gráficos Exploratórios das preditoras para o lado selecionado

```{r graf exp lado selecionado,echo=FALSE}
df_data <- df_se |> 
  filter(lado_km == 22.26) |> 
  mutate(log_S = log(S_obs))
f_ggplot <- function(y){
  ggplot(df_data,aes(x=p,y=.data[[y]])) +
    geom_smooth(color="red") +
    geom_point(aes(color=log(Ntotal))) + 
    theme_minimal() +
    theme(legend.position = "bottom")
}
# f_ggplot(y="log_SN")
l_p <- alply(c("S_obs","log_S"),1,f_ggplot)
grid.arrange(grobs=l_p,ncol=2,top="Smooth: Riqueza observada(S) e log(S) ~ p, lado paisagem = 22.26")
```

__Figura 3__ Gráficos Exploratórios das preditoras do modelo mais plausível, quando %CV(p) é calculado usando o maior lado da paisagem. Em vermelho uma funçõa loess considerando apenas p como preditora.


#### Como a %CV varia com o lado da paisagem? 


```{r figura p por lado da paisagem,echo=FALSE,fig.width=10,fig.height=6}
# df_se |> 
#   mutate(log_SN = log(S_obs/Ntotal)) |> 
#   filter(lado_km == max(df_se$lado_km)) |> 
#   ggplot(aes(x=p,y=S_obs,color=lado_km)) +
#   geom_point(alpha=0.4) #+
  # geom_line()
  # geom_smooth(aes(group=lado_km),method = "lm", formula = "y ~ x+x^2",se=FALSE)
l_p <- list()
l_p[[1]] <- df_se |>
  group_by(lado_km) |> 
  summarise(var_p = var(p)) |> 
  ggplot(aes(x=lado_km,y=var_p)) +
  geom_point(size=0.4,alpha=0.4) + labs(y="var(p)")
l_p[[2]] <- df_se |> 
  ggplot(aes(x=lado_km,y=p)) + 
  geom_point(alpha=0.2,size=0.2) +
  geom_line(aes(group=SiteCode),size=0.2,alpha=0.2) +
  scale_y_continuous(breaks = seq(0,1,by=0.1))
v_levels <- df_se |> 
  group_by(SiteCode) |> 
  summarise(p_change=max(p) - min(p)) |> 
  arrange(p_change) |> pull(SiteCode)
l_p[[3]] <- df_se |> 
  ggplot(aes(x=SiteCode,y=p)) +
  geom_point(aes(color=lado_km),alpha=0.3,size=0.2) +
  scale_x_discrete(limits=v_levels) + theme(axis.text.x = element_blank(),axis.ticks.x = element_blank())
grid.arrange(grobs=l_p,ncol=1,top="%CV (p) em função da mudança do lado da paisagem",
             layout_matrix=rbind(c(NA,NA,1,1,NA,NA),
                                 c(2,2,2,3,3,3),
                                 c(2,2,2,3,3,3)))
```

__Figura 4__ Proporção de cobertura vegetal (%CV) em relação ao lado da paisagem (lado_km). SiteCode = código da paisagem. 


#### Como está o ajuste do modelo que atribuiu maior peso de evidência?
  
__tabela 1__ Sumário do modelo mais plausível, lado da paisagm = 22.26 km  
  
```{r sumário modelo mais plausível, echo=FALSE}
md_ee <- l_md[[as.character(v_lado_max_weight)]]
summary(md_ee)
```


```{r dharma residuals modelo com maior peso de evidência,echo=FALSE}
res.Dharma <- DHARMa::simulateResiduals(md_ee,n = 250,refit = FALSE)
plot(res.Dharma)
```

__figura 5__ Resíduos quantilícos (DHARMa) do modelo mais plausível. 


```{r predito contra observado, echo=FALSE}
df_plot <- df_se |> 
  filter(lado_km == 22.26) |> 
  mutate(log_S = log(S_obs))
df_plot$fit <- predict(md_ee,type = "response",newdata=df_data)
df_plot |> 
  ggplot(aes(x=S_obs,y=fit)) +
  geom_point() +
  geom_smooth(method = "lm",formula="y~0+x") +
  geom_abline(slope=1,intercept = 0,color="red")
```

__figura 6__ Predito pelo modelo mais plausível e observado. Em vermelho reta 1:1; em azul a regressão linear entre predito e observado. 

```{r predito por p quando Ntotal é igual a mediana,echo=FALSE}
df_data <- df_se |> 
  filter(lado_km == 22.26) |> 
  mutate(log_S = log(S_obs))
df_plot <- data.frame(p=df_data$p, Ntotal=median(df_data$Ntotal))
df_plot$fit <- predict(md_ee,type="response",newdata=df_plot)
df_plot |> 
  ggplot(aes(x=p,y=fit)) + 
  geom_line() +
  labs(y="Riqueza predita",title=paste0("Ntotal = median(Ntotal observado)=",median(df_data$Ntotal)))
```

__figura 7__ Riqueza predita quando Ntotal é mantido constante no valor mediano.