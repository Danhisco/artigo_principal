---
title: Análise de escala de efeito usando MNEE
authors:
  - name: Danilo Pereira Mori
    affiliation: LET - IBUSP
# bibliography: references.bib
# biblio-style: unsrt
# output: rticles::arxiv_article
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# pacotes
library(doMC)
library(raster)
library(bbmle)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(plyr)
library(dplyr)
# funções
source("source/dinamica_coalescente.R")
source("source/SoE_MNEE.R")
source("source/f_z.R")
# df dados para simulação
df_sim <- read_csv("dados/df_simulacao.csv")
# df_se_completa: p (%CV) para diferentes extensões espaciais (máximo lado = 22.26 km, min = 0.36 km)
df_se_completo <- read_csv("./dados/csv/df_p_extensoes.csv")
# df_se: 5 sítios com a menor extensão espacial da
# setwd("../..")
df_se <- data.frame(txt.file = list.files(path = "dados/simulacao",
                                          pattern = ".txt"),
                    SiteCode = str_extract(list.files(path = "dados/simulacao",
                                                      pattern = ".txt"),
                                           ".*?(?=.txt)")) |> #(?<=ao\\/)
  inner_join(select(filter(df_sim,k==0.05),SiteCode,d,S_obs,Ntotal,effort_ha),by="SiteCode")
# df_sorteio_sitios
df_sorteio_sitios <- read_csv(file="dados/csv/df_sorteio_sitios.csv") |> 
  select(-d) |> 
  inner_join(x=select(df_sim,SiteCode,d,k),by="SiteCode")
## df_Unull
df_Unull <- list.files(path = "dados/csv/U_nullLand_16km/",pattern = ".csv",full.names = T) |> 
  map_df(~read_csv(.)) |> 
  inner_join(x=distinct(select(df_sim,SiteCode:S_obs)),by="SiteCode")
df_Unull <- cbind(df_Unull[,1:6],
                  Umed = apply(df_Unull[,7:10], 1, mean),
                  Usd = apply(df_Unull[,7:10], 1, sd)) |> 
  mutate(DA = Ntotal / effort_ha)
# df_Usoe
df_Usoe <- list.files(path="dados/csv/SoE",pattern = ".csv",full.names = TRUE) |> 
  map_df(~read_csv(.)) |> 
  inner_join(x=mutate(select(df_sorteio_sitios,-k),DA=Ntotal/effort_ha),by="SiteCode")
df_Usoe <- cbind(select(df_Usoe,SiteCode:k),
                 Umed = apply(select(df_Usoe,-(SiteCode:k)), 1, mean),
                 Usd = apply(select(df_Usoe,-(SiteCode:k)), 1, mean))
# df_Urep <- list.files(path = "dados/csv/SoE",pattern = "_null.csv",full.names = T) |> 
#   map_df(~read_csv(.)) |> 
#   inner_join(x=select(df_sorteio_sitios,-txt.file),by="SiteCode")
# df_U
# df_U <- cbind(df_Urep[,1:8],
#               Umed = apply(df_Urep[,9:12], 1, mean),
#               Usd = apply(df_Urep[,9:12], 1, sd)) |> 
#   group_by(SiteCode) |> 
#   arrange(lado_km)
# df_U$Umed.z <- f_z(df_U$Umed)
# df <- df_U |> filter(SiteCode == "MGipia1")
# f_lag.U <- function(df){
#   v_Udiff <- max(df$Umed) - df$Umed[nrow(df)]
#   df$Ulag <- c((df$Umed[1:(nrow(df)-1)] - df$Umed[2:nrow(df)])/v_Udiff,NA)
#   df$Ucsum <- cumsum(df$Ulag)
#   # df$Ulag3 <- c((df$Umed[1:(nrow(df)-3)] - df$Umed[4:nrow(df)])/df$Umed[nrow(df)],NA,NA,NA)
#   return(df)
# }
# df_U <- ddply(df_U,"SiteCode",f_lag.U) |> arrange(lado_km)
# df_auditoria
df_auditoria <- data.frame(csv.file = list.files(path="dados/csv/SoE",pattern = "_null.csv",full.names = T),
                           SiteCode = str_extract(list.files(path="dados/csv/SoE",pattern = "_null.csv",full.names = T),
                                                  "(?<=E\\/).*?(?=_null.csv)")) |> 
  anti_join(x=df_sorteio_sitios,by="SiteCode") |> 
  inner_join(distinct(select(df_sim,SiteCode,tif.path)),by="SiteCode")
```

```{r trackdown}
library(trackdown)
# 1a vez:
upload_file(file="apendices/EfeitoEscala/EfeitoEscala.Rmd",
            gpath = "mestrado/DaniloPMori-artigo_mestrado/")
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
update_file(file ="relatorio_final.Rmd",
            gpath = "mestrado/disciplinas/BIE5716/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file ="relatorio_final.Rmd",
              gpath = "mestrado/disciplinas/BIE5716/")
```

 
## Introdução

<p> O objetivo é determinar a extensão espacial da paisagem local ao redor da parcela amostrada. Comparo duas abordagens. 
estimarei a taxa U no cenário de limitação à dispersão __per capita__ mais brando em 5 paisagens (com maior perda). Esse método será usado para determinar aquela extensão espacial em que o valor de U para de reduriz. A extensão espacial que estabilizar a estimativa de U indica que a maior porção de contribuição dos indivíduos da paisagem ao redor à chuva de propágulos que pode repor a diversidade local foi atingida. Por conta do pressuposto de soma zero de MNEE, ou seja, toda morte é reposta por um nascimento, dessa forma a probabilidade das unidades de matriz serem sorteadas como parentais é redistribuída para as unidades de habitat remanescente. Então esparamos que a extensão espacial da paisagem ao redor que irá estabilizar a estimativa de U no cenário de limitação à dispersão mais brando deve ser maior quanto menor a proporção de cobertura vegetal. Assim, as paisagens de menor proporção de cobertura vegetal devem indicar extensão espacial suficiente em valores superiores à da paisagem com maior proporção de cobertura vegetal. Segundo, faço a análise de escala de efeito como proposto por Jackson & Fahrig (2015), utilizarei a abordagem mais comum - apesar das limitações (REF), em que se estima aquela extensão espacial que maximiza o peso de evidência da regressão binomial negativa da riqueza local pelo polinômio de terceiro grau da cobertura vegetal e do log do número de indivíduos. PUtkker et al (2020) em análise similar para a Floresta Atlântica encontrou a extensão espacial de cerca de 4x4km. As duas abordagens pressupõe que a paisagem ao redor é a área que pode fornecer propágulos para a paisagem ao redor com maior frequência (REF ECO LET), porém a primeira abordagem pressupõe explicitamente a dinâmica ecológica idealizada usada para comparar as hipóteses investigadas, enquanto a segunda utiliza outro arcabouço teórico. Assim, Optei por não usar a análise de escala de efeito para determinar a escala espacial da paisagem ao redor para comparar as hipóteses investigadas.</p>



```{r figura 1 variaveis }
df_plot <- df_se |>
  mutate(sorteio_site = ifelse(SiteCode %in% unique(df_Unull$SiteCode),"SoE","non SoE"),
         DA = Ntotal / effort_ha)
l_p <- list()
l_p[[1]] <- df_plot |> 
  ggplot(aes(x=DA,y=S_obs,color=sorteio_site)) +
  geom_point(alpha=0.8) +
  scale_color_manual(values=c("black","red"),name="SoE: 36 sites") +
  labs(x="density (individuals / ha)", 
       y="spp richness",
       title="a) 106 sítios selecionados") +
  theme(legend.position = "bottom")
l_p[[2]] <- df_sim |> 
  ggplot(aes(x=k,y=d,group=k)) +
  geom_jitter() +
  geom_boxplot() +
  labs(x = "k = % de propágulos até a vizinhança imediata do progenitor",
       y = "d = desvio-padrão da função de dispersão (dist. de Laplace)",
       title = "c) Cenários de limitação de dispersão simulados")
grid.arrange(grobs=l_p,ncol=2)
```

<p> __Figura 1__ a) Riqueza de espécies e densidade de indivíduos nas parcelas dos 106 sítios selecionados (parcela contígua de pelo menos 1ha). Em vermelho os pontos amostrados e selecionados para investigar a extensão espacial da paisagem ao redor usando MNEE (Scale of Effect, SoE). b) Cenários de limitação de dispersão simulados, códigos para gerar simular o desvio padrão correspondente ao k em 'source/qkernel_e_sigkernel.R'.</p>


```{r figura 2 U para todo k em paisagens nulas na maior escala investigada,fig.width=8,fig.height=8}
df_plot <- df_Unull |> 
  arrange(S_obs) |> 
  mutate(label = paste(SiteCode,S_obs,Ntotal,round(DA,0),sep = ", "))
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |> 
  ggplot(aes(x=k,y=Umed)) +
  geom_line() +
  geom_point() +
  labs(title = "U estimado por cenário de dispersão em paisagens nulas de lado 16 km",
       subtitle = "label = SiteCode, S, N, DA; free y axis; reverse x axis") +
  geom_vline(xintercept = c(0.25, 0.1,0.05),color="red",alpha=0.4) +
  scale_x_reverse() +
  facet_wrap(~label, ncol=6,scales="free_y")
```

<p> __Figura 2__ U estimado (eixo y) por cenário de limitação de dispersão (eixo x) em paisagens sem perda de cobertura vegetal (nulas) na maior extensão espacial (lado de 16 km). Os pontos representam a média de 4 réplicas e as linhas. Os paineis estão separados por sítios de amostragem, cujo mapa de cobertura vegetal foi artificialmente mudado para remover a matriz. As linhas em vermelhor representam os cenários de limitação de dispersão usados na análise de escala de efeito usada a partir de MNEE, k = 0.25, 0.10 e 0.05. Eixo y varia entre paineis e eixo x está reverso. Quanto menor k, maior a capacidade de dispersão simulada. S = riqueza da espécie, N = número de indivíduos, DA = densidade de indivíduos.</p>





#### Análise de Escala de Efeito usando MNEE

##### Sorteio dos sítios ao longo do gradiente de riqueza de espécies e densidade de indivíduos

```{r df sorteios sitios, eval=FALSE}
df_sorteio_sitios <- df |> 
  filter(S_obs %in% sample(size = 15,df$S_obs) | DA %in% sample(size = 15,df$DA)) |> 
  rbind(filter(df,S_obs %in% range(df$S_obs) | DA %in% range(df$DA))) |>  distinct()
write_csv(df_sorteio_sitios,file = "dados/csv/df_sorteio_sitios.csv")
```



 
```{r figura 2 mapa das paisagens que foram usadas na estimativa de SoE por MNEE,fig.width=8,fig.height=8}
df <- df_se
v_landExt <- 16.02 * 1000/30 # the maximum landscape extension simulated, pixel = 30x30m2
par(mar=c(0.2,0.2,2.2,0.2),mfrow=c(5,5))
for(i in 1:nrow(df)){
  m_full <- raster(df$tif.path[i]) |> raster::as.matrix()
  index <- (nrow(m_full)-v_landExt)/2
  m <- m_full[(index+1):(nrow(m_full) - index),
              (index+1):(nrow(m_full) - index)]
  image(m,main=df$SiteCode[i],axes=FALSE)
  abline(h=0.5)
  abline(v=0.5)
  # print(dim(m))
}
```

<p> __Figura 2__ Mapa das paisagens usadas para estimar o efeito da escala por MNEE quando a paisagem possui lado 16.02km: essas são as 5 com menor cobertura vegetal.</p>

#### Processamento dos rasters do mapbiomas6  

<p>Para simular MNEE é necessário: 
  
i) ajustar a resolução (mapa original 30x30m) tal que a densidade de pixels é igual a densidade de indivíduos na parcela; 
  
ii) considerar unidades de habitat os pixels com valores maiores do 0.7, no mapa original há apenas 0s e 1s, mas após o aumento da resolução há a inclusão de valores intermediários; 
  
iii) desenhar a parcela no centro do mapa, trocando N (número total de indivíduos na parcela) valores 1s por 2s (posições iniciais das linhagens monitoradas na simulação coalescente); 

iv) caso não seja possível desenhar uma parcela quadrada centrada na coordenda central, desloquei a parcela para algum local próximo dentro do fragmento amostrado.</p>


```{r figura 3 detalhe da vizinhança da parcela,message=FALSE,warning=FALSE,fig.width=10,fig.height=8}
f_auditoria <- function(path_name){
  m <- read_table(file = path_name) |> as.matrix()
  d <- ceiling(sqrt(2500)*2)
  l <- ceiling(dim(m)[1]/2)
  c <- ceiling(dim(m)[2]/2)
  m_temp <- m[(l-d):(l+d),(c-d):(c+d)]
  image(m_temp,main=str_extract(path_name,"(?<=cao\\/).*?(?=\\.txt)"),axes=FALSE)
}
par(mar=c(0.2,0.2,2.2,0.2),mfrow=c(5,5))
a_ply(df_se$txt.file,1,f_auditoria)
# sapply(df_se$txt.file,f_auditoria)
```

<p>__Figura 3__ Vizinhança imediata das parcelas simuladas. Em vermelho as unidades de habitat da parcela, em amarelo as unidades de habitat e em branco a matriz.</p>

## Estimativa de U para diferentes extensões espaciais


```{r figura 4 Umed por lado da paisagem,fig.width=10,fig.height=8}
df_plot <- df_Urep |> 
  pivot_longer(cols=8:11,names_to = "n", values_to = "U") |> 
  arrange(S_obs,DA) |> 
  mutate(label = paste(SiteCode,S_obs,Ntotal,round(DA,1),sep = ", ")) 
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |>
  ggplot(aes(x=lado_km,y=U),color=S_obs) +
  geom_smooth(method="loess",formula = "y ~ x",se=F,alpha=0.1,color="red",size=0.8) +
  geom_point(alpha=0.4,size=1.5) +
  scale_x_continuous(trans='log2',breaks = round(16.02/2^(5:0),0)) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  labs(title="SiteCode, riqueza, número de indivíduos ,densidade",
       x = "lado da paisagem (km)",
       y = "taxa U estimada") +
  facet_wrap(~label,ncol = 6)
```

<p> __Figura 4__ U estimado (eixo y) nas diferentes extensões espaciais (eixo x). Pontos representam 5 réplicas por bateria de simulação. A simulação coalescente foi feita pressupondo que apenas 5% dos propágulos permanecem até a vizihança imediata do progenitor (100/sqrt(densidade indivíduos)).</p>


```{r figura 5 Udiff}
# df_Urep <- read_csv("../csv/df_Urep.csv")
df_U |> 
  ggplot(aes(x=lado_km,y=Udiff,group=SiteCode)) +
  geom_point() +
  geom_line() +
  labs(title="Udiff = U - U_16x16km2") +
  scale_x_continuous(trans='log2',breaks = round(16.02/2^(5:0),0)) +
  theme_minimal()
```

<p> __Figura 4__ U estimado (eixo y) nas diferentes extensões espaciais (eixo x). Pontos representam 5 réplicas por bateria de simulação. A simulação coalescente foi feita pressupondo que apenas 5% dos propágulos permanecem até a vizihança imediata do progenitor (100/sqrt(densidade indivíduos)).</p>

```{r figura 5 reducao percentual de U entre escalas}
# plot(density(na.omit(df_U$Ulag)))
df_U$lado_factor <- factor(df_U$lado_km,labels=c(paste(16/(2^(5:1)),"->",16/(2^(4:0))),NA))
l_p <- list()
l_p[[1]]<- df_U |>
  drop_na() |>
  # mutate(class_S = cut(S_obs,breaks = 6)) |> 
  ggplot(aes(x=lado_factor, y = Ulag)) +
  geom_boxplot() +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  labs(x="mudança de escala",y="U_i - U_i+1 / (U_inicial - U_final)",title="Contribuição para a redução geral")
l_p[[2]]<- df_U |>
  drop_na() |>
  # mutate(class_S = cut(S_obs,breaks = 6)) |> 
  ggplot(aes(x=lado_factor, y = Ucsum)) +
  geom_boxplot() +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  labs(x="mudança de escala",y="U_i - U_i+1 / (U_i - U_final)",title="Contribuição acumulativa para a redução geral")
df_U |> 
  group_by(SiteCode) |> 
  mutate(Urange = max(Umed) - min(Umed)) |> 
  select(SiteCode,Urange,S_obs) |> distinct()

grid.arrange(grobs=l_p,nrow=1)
```


# Support Information

## Códigos para estimar U nas diferentes extensões espaciais

<p>Olhar source/SoE_MNEE.R para os códigos que estimam U para diferentes extensões espaciais.</p>

```{r codigos para estimar U para uma mesma extensao espacial e diferentes k,eval=FALSE}
setwd("dados/simulacao")
f_siteU <- function(df,replicas=4,csv.repo="../csv/U_nullLand_16km/"){
  l_dfU <- list()
  for(i in 1:nrow(df)){
    v_U <- replicate(n=replicas,f_simU(df = df[i,]))
    l_dfU[[i]] <- cbind(select(df[i,],-(txt.file:DA)),matrix(v_U,nrow = 1))
  }
  df_write <- rbind.fill(l_dfU)
  write_csv(df_write,file = paste0(csv.repo,df$SiteCode[1],".csv"))
}
registerDoMC(2)
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
d_ply(df_sorteio_sitios,"SiteCode",f_siteU,.parallel = TRUE)
```


```{r codigos para estimar U SoE, eval=FALSE}
setwd("dados/simulacao")
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
df_se <- df_sorteio_sitios |> filter(k %in% unique(df_sim$k)[c(16,19)])
registerDoMC(2)
a_ply(df_se,1,f_SoE_MNEE_null,.parallel = TRUE)
```

```{r arrumando os dados do SoE para k05,eval=FALSE}
v_csv.path <- list.files(path = "dados/csv/SoE", pattern = "_null.csv",full.names = T)
v_k <- unique(df_sim$k)
f_csv <- function(path.csv){
  df <- read_csv(path.csv)
  df$k <- v_k[20]
  df <- cbind(df[,c(1:2,7)],df[,3:6])
  file.remove(path.csv)
  write_csv(df,file = gsub("null",paste0("k",v_k[20]*100),path.csv))
}
v_logical <- sapply(v_csv.path[-1],f_csv)
system("du -s dados/csv/SoE/")
```


Distribuição da diferença de U entre escalas consecutivas,

Padronização:
1) transformação z: ( Umed - mean(Umed) ) / sd(Umed)
2) subtração pelo valor da maior escala
3) diferença entre escalas padronizada pela diferença geral do sítio: i+1 - i / (inicial - final) 
4) distribuição de valores das diferenças entre escalas 




<!-- ## Códigos para análise de escala de efeito -->

<!-- Essa abordagem apresenta alguns problemas pois não ocnsidera: a colinearidade dos valores de p entre lados da paisagem e a autocorrelação espacial entre sítios próximos (REF). Contudo, essa ainda é a abordagem mais executada (REF) e foi usada aqui para comparar com a seleção da escala de efeito que fizemos via simulação de MNEE. -->



<!-- #### Análise exploratória variáveis primárias: S_obs e Ntotal -->

<!-- ```{r análise exploratória variáveis primárias Sobs e Ntotal,echo=FALSE} -->
<!-- df_dados |>  -->
<!--   ggplot(aes(x=Ntotal,y=S_obs)) +  -->
<!--   # geom_smooth() + -->
<!--   geom_point(alpha=0.5) +  -->
<!--   labs(title="S_obs = Riqueza observada; Ntotal = total indivíduos") -->
<!-- ``` -->

<!-- __Figura 1__ Análise exploratória variáveis primárias: riqueza observada (S_obs) e número total de indivíduos (Ntotal) -->

<!-- ### 1o Passo: calcular a proporção de cobertura vegetal para cada extensão espacial -->



<!-- Para determinar a extensão espacial da escala de paisagem  -->

<!-- ```{r 2o passo} -->
<!-- f_glm.nb <- function(data_){ -->
<!--   md_ <- MASS::glm.nb(S_obs ~ poly(p, 3) + log(Ntotal), data = data_) -->
<!-- } -->
<!-- registerDoMC(3) -->
<!-- l_md <- dlply(df_se,"lado_km",f_glm.nb,.parallel = TRUE) -->
<!-- ``` -->

<!-- ### 3o Passo: Calcular o peso de evidência por lado da paisagem local (km) -->

<!-- ```{r 3o passo,results='hide'} -->
<!-- df_averageSE <- print(AICctab(l_md,weights=TRUE),min.weight=10^(-10)) %>%  -->
<!--   as.data.frame() -->
<!-- df_averageSE$lado_km <- row.names(df_averageSE) %>% as.numeric() -->
<!-- df_averageSE$weight <- as.numeric(as.character(df_averageSE$weight)) -->
<!-- df_averageSE$dAICc <- as.numeric(as.character(df_averageSE$dAICc)) -->
<!-- ``` -->


<!-- ### 4o Passo: Selecionar o lado da paisagem local que atribuiu maior peso de evidência -->

<!-- ```{r 4o passo,echo=FALSE} -->
<!-- v_lado_max_weight <- df_averageSE |> filter(weight==max(df_averageSE$weight)) |> pull(lado_km) -->
<!-- df_averageSE |>  -->
<!--   ggplot(aes(x=lado_km,y=weight)) + -->
<!--   geom_line() + -->
<!--   labs(title = paste0("O maior weight foi no maior lado = ",v_lado_max_weight,"km")) -->
<!-- ``` -->

<!-- __Figura 2__ Peso de evidência pelo lado da paisagem local. -->

<!-- ### Avaliação -->

<!-- #### Gráficos Exploratórios das preditoras para o lado selecionado -->

<!-- ```{r graf exp lado selecionado,echo=FALSE} -->
<!-- df_data <- df_se |>  -->
<!--   filter(lado_km == 22.26) |>  -->
<!--   mutate(log_S = log(S_obs)) -->
<!-- f_ggplot <- function(y){ -->
<!--   ggplot(df_data,aes(x=p,y=.data[[y]])) + -->
<!--     geom_smooth(color="red") + -->
<!--     geom_point(aes(color=log(Ntotal))) +  -->
<!--     theme_minimal() + -->
<!--     theme(legend.position = "bottom") -->
<!-- } -->
<!-- # f_ggplot(y="log_SN") -->
<!-- l_p <- alply(c("S_obs","log_S"),1,f_ggplot) -->
<!-- grid.arrange(grobs=l_p,ncol=2,top="Smooth: Riqueza observada(S) e log(S) ~ p, lado paisagem = 22.26") -->
<!-- ``` -->

<!-- __Figura 3__ Gráficos Exploratórios das preditoras do modelo mais plausível, quando %CV(p) é calculado usando o maior lado da paisagem. Em vermelho uma funçõa loess considerando apenas p como preditora. -->

<!-- #### Como está o ajuste do modelo que atribuiu maior peso de evidência? -->

<!-- __tabela 1__ Sumário do modelo mais plausível, lado da paisagm = 22.26 km   -->

<!-- ```{r sumário modelo mais plausível, echo=FALSE} -->
<!-- md_ee <- l_md[[as.character(v_lado_max_weight)]] -->
<!-- summary(md_ee) -->
<!-- ``` -->


<!-- ```{r dharma residuals modelo com maior peso de evidência,echo=FALSE} -->
<!-- res.Dharma <- DHARMa::simulateResiduals(md_ee,n = 250,refit = FALSE) -->
<!-- plot(res.Dharma) -->
<!-- ``` -->

<!-- __figura 5__ Resíduos quantilícos (DHARMa) do modelo mais plausível.  -->


<!-- ```{r predito contra observado, echo=FALSE} -->
<!-- df_plot <- df_se |>  -->
<!--   filter(lado_km == 22.26) |>  -->
<!--   mutate(log_S = log(S_obs)) -->
<!-- df_plot$fit <- predict(md_ee,type = "response",newdata=df_data) -->
<!-- df_plot |>  -->
<!--   ggplot(aes(x=S_obs,y=fit)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "lm",formula="y~0+x") + -->
<!--   geom_abline(slope=1,intercept = 0,color="red") -->
<!-- ``` -->

<!-- __figura 6__ Predito pelo modelo mais plausível e observado. Em vermelho reta 1:1; em azul a regressão linear entre predito e observado.  -->

<!-- ```{r predito por p quando Ntotal é igual a mediana} -->
<!-- df_data <- df_se |>  -->
<!--   filter(lado_km == 22.26) |>  -->
<!--   mutate(log_S = log(S_obs)) -->
<!-- df_plot <- data.frame(p=df_data$p, Ntotal=median(df_data$Ntotal)) -->
<!-- df_plot$fit <- predict(md_ee,type="response",newdata=df_plot) -->
<!-- df_plot |>  -->
<!--   ggplot(aes(x=p,y=fit)) +  -->
<!--   geom_line() + -->
<!--   labs(y="Riqueza predita",title=paste0("Ntotal = median(Ntotal observado)=",median(df_data$Ntotal))) -->
<!-- ``` -->

<!-- __figura 7__ Riqueza predita quando Ntotal é mantido constante no valor mediano. -->


