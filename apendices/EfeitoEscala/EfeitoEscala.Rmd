---
title: "Efeito de escala na estimativa da taxa U necessária para manter a riqueza local no equilíbrio em um modelo neutro espacialmente explícito"
author: 
  - Danilo Pereira Mori, Laboratório de Ecologia Teórica (IBUSP)
date: "2022-08-20"
output:
  pdf_document:
    latex_engine: xelatex
    extra_dependencies: ["tabu"]
  html_document: default
editor_options:
  chunk_output_type: console
# bibliography: citations.bib
csl: plos.csl
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# pacotes
library(lubridate)
library(doMC)
library(raster)
library(insight)
library(DHARMa)
library(bbmle)
library(broom.mixed)
library(lme4)
library(scales)
library(ggnewscale)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr) 
library(tidyr)
library(plyr)
library(dplyr)
# funções
source("source/dinamica_coalescente.R")
source("source/SoE_MNEE.R")
source("source/f_z.R")
source("source/nameModel.R")
# df dados da proporção de cobertura vegetal
df_p <- read_csv("dados/df_p.csv")
# df dados para simulação
df_sim <- read_csv("dados/df_simulacao.csv") |> 
  inner_join(x=df_p,by="SiteCode")
# df_sorteio_sitios
df_sorteio_sitios <- read_csv(file="dados/csv/df_sorteio_sitios.csv") |> 
  select(-d) |> 
  inner_join(x=select(df_sim,SiteCode,d,k),by="SiteCode")
# v_sim_sites: se precisar é só mover as paisagens de volta ou incluir um programa coalescente na outra pasta
## acabei perdendo a mão e deletei as paisagens nulas de ambas situações, mas tudo bem faz mais em mapas_...Rmd
# v_sim_sites <- list.files(path="dados/simulacao",pattern = "_null.txt")
# file.copy(from=paste0("dados/simulacao/",v_sim_sites),
#           to=paste0("dados/paisagens/paisagens_SoE_MNEE/",v_sim_sites))
# file.remove(paste0("dados/simulacao/",v_sim_sites))
# df_SoE
df_Usoe.rep <- read_csv("dados/csv/df_Usoe.csv") |> 
  pivot_longer(cols=`1`:`10`, names_to = "n", values_to = "U") |> 
  inner_join(x=distinct(select(df_sim,SiteCode,effort_ha:S_obs)),by="SiteCode") |> 
  arrange(S_obs,k)
# df_Unull
df_Unull <- df_Usoe.rep |> filter(round(lado_km) == 16) 
# df_Usoe
df_Usoe <- df_Usoe.rep |> 
  arrange(lado_km) |> 
  group_by(SiteCode,k,lado_km) |> 
  summarise(Umed = mean(U),
            Umedian = median(U)) |> 
  mutate(diffU = Umed - Umedian)
# registerDoMC(3)
df_Usoe <- ddply(df_Usoe,c("SiteCode","k"),f_lag.U,.parallel = TRUE)
df_Usoe$Schange <- factor(df_Usoe$lado_km,labels=c(paste(16/(2^(5:1)),"->",16/(2^(4:0))),NA))
df_Usoe$Schange_cumulative <- factor(df_Usoe$lado_km,labels=c(paste(0.5,"->",16/(2^(4:0))),NA))
df_Usoe$k_factor <- factor(round(df_Usoe$k,2),levels = sort(unique(round(df_Usoe$k,2)),decreasing = T))
df_Usoe <- df_Usoe |> 
  group_by(SiteCode,k) |> 
  summarise(Ucv = sd(Umed)*100/mean(Umed),
            Ulag_f = ifelse(any(Ulag < -0.1,na.rm = T),"neg_v","pos_v")) |> 
  mutate(Ucv_f = ifelse(Ucv>10,"top90","low10")) |> 
  # select(-Ucv) |> 
  inner_join(x=df_Usoe,by=c("SiteCode","k"))
# df_md
df_md <- df_Usoe |> 
  inner_join(distinct(select(df_sim,SiteCode,effort_ha:S_obs)),by="SiteCode") |> 
  mutate(logit_Umed = log(Umed/(1-Umed)),
         DA = Ntotal / effort_ha,
         S.DA = S_obs / Ntotal,
         log2_lado.km = log2(round(lado_km,1)),
         lado_factor = factor(round(lado_km,1)) ) |> 
  select(SiteCode,Umed,logit_Umed,k,k_factor,lado_factor,lado_km,log2_lado.km,S_obs,Ntotal,DA,S.DA) |> 
  mutate(across(S_obs:S.DA,log,.names="log_{.col}"),
         across(c(k,log2_lado.km,S_obs:log_S.DA),f_z,.names="{.col}_z"))
md_SoE <- lmer(logit_Umed ~ log_S_obs_z * log_Ntotal_z * k_factor * lado_factor + (1|SiteCode),
                  data=df_md)
# dados usados na simulação com os valores preditos e os residuos z transformados
df_plot <- df_md |> 
  select(SiteCode, logit_Umed:lado_factor, S_obs,Ntotal,log_S_obs_z:log_Ntotal_z)
df_plot$deviance <- residuals(md_SoE,scale=T)
df_plot$predict <- predict(md_SoE)
df_plot <- df_plot |> 
  mutate(Umed = exp(logit_Umed) / exp(1-logit_Umed),
         Pre_Umed = exp(predict) / exp(1-predict),
         lado_numeric = as.numeric(as.character(lado_factor)),
         S.N = S_obs / Ntotal)
df_plot <- df_plot |>
  group_by(k_factor,lado_factor) |> 
  summarise(Umed = mean(Pre_Umed)) |> 
  ddply("k_factor",f_lag.U) |>
  ddply("k_factor",f_k.SoE) |> 
  select(k_factor,SoE.99) |> 
  inner_join(x=df_plot,by="k_factor")
```

```{r trackdown,eval=FALSE}
library(trackdown)
# 1a vez:
upload_file(file="apendices/EfeitoEscala/EfeitoEscala.Rmd",
            gpath = "mestrado/DaniloPMori-artigo_mestrado/",
            hide_code = TRUE)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
update_file(file ="apendices/EfeitoEscala/EfeitoEscala.Rmd",
            gpath = "mestrado/DaniloPMori-artigo_mestrado/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file ="apendices/EfeitoEscala/EfeitoEscala.Rmd",
              gpath = "mestrado/DaniloPMori-artigo_mestrado/")
```

__Objetivo__
 
<p> Primeiro avaliamos se a maior extensão considerada é suficiente para obter o padrão não linear de U esperado em paisagens infinitas. E depois comparamos a estimativa de U para cada subescala (0.5, 1, 2, 4, 8 e 16 km de lado da paisagem ao redor quadrada). Dos 108 sítios selecionados para a comparação dos modelos neutros, 36 foram sorteados e selecionados para avaliar qual a extensão espacial suficiente para comparar os modelos neutros. Esses 36 sítios incluem os extremos da riqueza de espécies e densidade de indivíduos observada e outros 32 sítios sorteados na amplitude de valores dessas duas variáveis (figura 1a). Para cada sítio simulamos 20 graus de limitação de dispersão no modelo espacialmente explícito (Figura 1b e Figura 2). Vamos selecionar os graus de limitação de dispersão no qual a extensão espacial de 4x4 km2 acumula a maior parte do efeito da escala na estimativa de U. </p>

```{r figura 1 variaveis de controle e cenarios de limitacao de dispersao,fig.height=4}
df_plot <- df_sim |>
  filter(k==0.05) |> 
  mutate(sorteio_site = ifelse(SiteCode %in% unique(df_Unull$SiteCode),"SoE","non SoE"),
         DA = Ntotal / effort_ha)
l_p <- list()
l_p[[1]] <- df_plot |> 
  ggplot(aes(x=DA,y=S_obs,color=sorteio_site)) +
  geom_point(alpha=0.8) +
  scale_color_manual(values=c("black","red"),name="SoE: 36 sites") +
  labs(x="density (individuals / ha)", 
       y="spp richness",
       title="a) 108 sítios totais, 36 para estudo") +
  theme(legend.position = "bottom")
l_p[[2]] <- df_sim |> 
  ggplot(aes(x=k,y=d,group=k)) +
  geom_jitter() +
  geom_boxplot() +
  labs(x = "k",
       y = "d",
       title = "b) graus de dispersão")
grid.arrange(grobs=l_p,ncol=2)
```

<p> __Figura 1__ a) Riqueza de espécies e densidade de indivíduos nas parcelas dos 106 sítios selecionados (parcela contígua de pelo menos 1ha). Em vermelho os pontos amostrados e selecionados para investigar a extensão espacial da paisagem ao redor usando MNEE (Scale of Effect, SoE). b) Cenários de limitação de dispersão simulados. k = proporção de propágulos que permanece até a vizinhança imediata (distância média entre indivíduos); d = desvio padrão da função de dispersão com distribuição de Laplace. Para detalhes sobre a seleção dos sítios na base TreeCo e sobre os cenários de limitação à dispersão olhar o texto principal.</p>

### Taxa U na maior extensão espacial da paisagem (16x16km2)

```{r figura 2 U para todo k em paisagens nulas na maior escala investigada,fig.width=12,fig.height=7}
df_plot <- df_Unull |> 
  arrange(S_obs) |> 
  mutate(label = paste(SiteCode,S_obs,Ntotal,effort_ha,sep = ", "))
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |> 
  ggplot(aes(x=k,y=U)) +
  # geom_line() +
  # geom_smooth(method = "loess",se=F) +
  geom_point(alpha=0.4) +
  stat_summary(geom = "line",fun.data = mean_se) +
  stat_summary(geom = "pointrange",fun.data = mean_se, color="red",size=0.1) +
  stat_summary(geom = "errorbar",fun.data = mean_se, color="red",linewidth=0.5) +
  labs(title = "U estimado por cenário de dispersão em paisagens nulas de lado 16 km",
       subtitle = "label = SiteCode, S, N, plot area(ha); free y axis; reverse x axis") +
  # geom_vline(xintercept = c(0.25, 0.1,0.05),color="red",alpha=0.4) +
  scale_x_reverse() +
  facet_wrap(~label, ncol=6,scales="free_y") +
  theme_classic()
# ggsave("apendices/EfeitoEscala/fig2_U16_k.png",
#        width = 17.2,
#        height = 6.7)
```

<p> __Figura 2__ U estimado (eixo y) por cenário de limitação de dispersão (eixo x) em paisagens sem perda de cobertura vegetal (nulas) na maior extensão espacial (lado de 16 km). Os pontos são as estimativas réplicas de U, os pontos vermelhos marcam o valor médio e a linha une os valores médios entre cenários de limitação de dispersão. Eixo y varia entre paineis e eixo x está reverso. Quanto menor k, maior a capacidade de dispersão, simulada com um kernel de dispersão com decaimento exponencial da probabilidade de colonização com o aumento da distância. S = riqueza da espécie, N = número de indivíduos.</p>

A taxa U estimada na extensão de 16x16 km2 apresenta padrão não linear com máximo em graus pouco severos de limitação de dispersão (Figura 2). Há muita variação entre os sítios, relacionado com a riqueza de espécies (texto principal resultados), por isso na figura 2 o eixo y varia entre paineis. A variação das réplicas em torno da média pode ser elevada (Figura 2). Os valores médios sugerem um padrão de patamares, com valores baixos de U quando a limitação de dispersão é severa e em graus pouco severos um aumento brusco que suavemente diminui com o relaxamento da limitação de dispersão (Figura 2). Uma vez que observamos um padrão qualitativamente similar ao esperado em paisagens infinitas, iremos considerar a extensão espacial de 16x16 km2 como maior escala de referência para os graus de limitação de dispersão. A seguir o efeito 

### Efeito da escala na estimativa média da taxa U por grau de limitação de dispersão

```{r figura 3 Umed por lado da paisagem,fig.width=13,fig.height=8}
df_plot <- df_Usoe.rep |> 
  mutate(DA = Ntotal / effort_ha,
         label = paste(SiteCode,S_obs,Ntotal,round(DA,1),sep = ", "),
         k = round(k,2)) 
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |>
  ggplot(aes(x=lado_km,y=U,color=k,group=factor(k))) +
  geom_point(alpha=0.4) +
  stat_summary(geom = "line",fun.data = mean_se) +
  stat_summary(geom = "pointrange",fun.data = mean_se, color="black",size=0.1) +
  scale_x_continuous(trans='log2',breaks = c(0,round(16.02/2^(5:0),1))) +
  # scale_color_gradient2(low="red",mid = "green",high = "blue", midpoint = 0.5) +
  scale_color_distiller(palette = "Spectral") +
  theme_gray() +
  # theme(legend.position = "bottom") +
  labs(title = "U estimado em diferentes subescalas da paisagem ao redor para os 20 cenários de limitação de dispersão (k)",
       subtitle="facet label = Site code, riqueza, número de indivíduos ,densidade; free y axis",
       x = "lado da paisagem (km)",
       y = "taxa U estimada") +
  # guides(color = guide_legend(title.position = "right")) + # gostaria de deixar o k para a direita e completar a descição dele, mas não tive tempo para fazer
  theme(legend.position= c(0.57,1.10),
        legend.direction = "horizontal",
        legend.justification='left',
        legend.background = element_rect(fill=alpha('white', 0.1))) +
  facet_wrap(~label,ncol = 6,scales="free_y")
ggsave("apendices/EfeitoEscala/fig3_Uk_ladoKM.png",
       width = 17.2,
       height = 6.7)
```

<p> __Figura 3__ U estimado (eixo y) nas diferentes extensões espaciais (eixo x) e para os 20 graus de limitação de dispersão (cor dos pontos e linhas). Pontos representam a média de 10 réplicas por bateria de simulação e as linhas ligam os pontos médos. Eixo y varia entre paineis.</p>

Principalmente para os graus de limitação de dispersão brandos, observamos o padrão esperado de a taxa U diminuir com o aumento da escala (Figura 3). Em para graus pouco severos de limitação de dispersão pode existir pouca variação na estimativa média entre escalas (Figura 3 e 4). Os graus pouco severos devem operar no máximo global de taxa U necessária para obter a riqueza observada (Figura 2) e por isso devem apresentar baixa variação na estimativa da taxa U com a mudança na escala. As estimativas médias irão diminuir com o aumento da escala para todos os graus de limitação de dispersão?

```{r figura 4 Ucv por k}
# versão 1:
df_Usoe |>
  group_by(SiteCode,k) |>
  summarise(Ucv = sd(Umed)*100/mean(Umed)) |>
  ggplot(aes(x=k,y=Ucv, group=k)) +
  geom_jitter() +
  geom_boxplot() +
  geom_hline(yintercept = 10,color="red") +
  labs(x="k, prop. de propágulos até a vizinhança imediata",
       y="Coef. Var. de Umed (%)",
       title="Variação da média de U por grau de limitação de dispersão")
```

__Figura 4__ Coeficiente de variação (sd/mean) de Umed (eixo y) para um mesmo cenário de limitação de dispersão (eixo x) e sítio, considerando todas as escalas. 

### Efeito da Escala: Grau de limitação de dispersão e extensão espacial da paisagem ao redor

__1) descrever o padrão por modelos de regressão LMM__
__2) aplicar a lógica do Ulag -> Ucsum no padrão predito pelas análises de regressão__

Procuro considerar todos os dados sem aplicar filtros que modificam a variabilidade dos dados, mas que ainda permitem descrever a tendência geral dos dados. 

__Motivação de cada variável__

A estimativa de U depende da arvóre genalógica da comunidade simulada por MNEE. O número de indivíduos (N) determina o número inicial de linhagens que são monitoras e o número de espécies (S) determina o número final de linhagens monitoradas. A árvore genealógica da comunidade também é influenciada pelo grau de limitação de dispersão (k) e da extensão espacial (scale), pois em alguns graus de limitação de dispersão a árvore genealógica pode ser restringida pela extensão da paisagem e não pela limitação de dispersão. 

__Modelos Estatísticos__

Para descrever a média da estimativa da taxa U optamos por transformar a variável usando a função logito e usar um modelo gaussiano misto (LMM). O número de indivíduos e riqueza foram modelados na escala log e z (transformação z). As variáveis graus de limitação de dispersão (k) e extensão espacial da paisagem ao redor (scale) foram interpretados como fatores, então cada combinação de k e scale possui um intercepto. Os dados foram agrupados por sítio, então cada sítio possui um intercepto comum. Não inclui estruturas mais complexas como a de ter um intercepto por grau de limitação de dispersão e sítio, pois isso implicaria em estimar um parâmetro a cada 6 valores e portanto muito tempo para a estimativa completa. Na tabela 1 há comparação de 4 modelos que consideram a interação das 4 variáveis. 

__tabela 1__ Seleção das variáveis de controle. S_obs = riqueza observada, N = número de indivíduos, DA = densidade de indivíduos;  Funções lmer do pacote lme4 (REF), AICctab do pacote bblme (REF). 

```{r GLMM selecao de variaveis para fixar no GLMM final,eval=T,cache=T,echo=TRUE}
l_md <- list()
l_md[[1]] <- lmer(logit_Umed ~ log_S_obs_z * log_Ntotal_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
l_md[[2]] <- lmer(logit_Umed ~ log_S_obs_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
l_md[[3]] <- lmer(logit_Umed ~ S_obs_z * Ntotal_z * k_factor * lado_factor  + (1|SiteCode),data=df_md)
l_md[[4]] <- lmer(logit_Umed ~ S_obs_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
names(l_md) <-laply(l_md,f_nameModel)
AICctab(l_md,weights=T)
```


__Tabela 2__ Coeficientes de determinal (R2) do modelo mais plausível: marginal(m, desconsiderando o efeito aleatório) e condicional(c, considerando o efeito aleatório):

```{r R2 marginal e condicional do modelo mais plausível para descrever SoE}
# print("R2 marginal e condicional, respectivamente:")
# md_SoE <- AICctab(l_md,weights=T) |> as.data.frame() |> head(n=1) |> row.names() |> 
#   (\(.) l_md[[.]])()
md_SoE |> (\(.) MuMIn::r.squaredGLMM(.))()
```

O modelo mais plausível considera os logs da riqueza observada e número de indivíduos na parcela (tabela 1). Os coeficientes de determinação marginal e condional do modelo são aproximadamente iguais à 0.96. No final do apêndice há os gráficos diagnósticos do modelo. Apesar dos resíduos quantilícos apresentarem algum desvio (Figura X), o modelo faz uma boa predição do observado (Figura X). Na figura 5 há a média da predição do modelo mais plausível, que descreve o logito da estimativa média da taxa U em função da interação entre log da riqueza e número total de indivíduos, e grau de limitação de dispersão e lado da paisagem como fatores. Os pontos estão coloridos pela razão entre número de espécies e número de indivíduos (S/N).


```{r figura para resultados do efeito de escala}
cols <- c("avg+-sd"="blue","SoE >= 0.99" = "red") # "#f04546","3 quant"=
a <- 0.5
df_plot |> 
  ggplot(aes(x=lado_numeric,y=Pre_Umed)) + #,group=k_factor,color=k
  geom_point(alpha=0.40,aes(color=S.N)) +
  geom_line(aes(group=SiteCode,color=S.N),alpha=0.25) +
  scale_color_distiller(palette = "Spectral",name="S / N") +
  new_scale_color() +
  # stat_summary(aes(x=lado_numeric,y=Pre_Umed,color="3 quant"), #,color=name,group=name
  #              fun.min = \(.) quantile(.,0.25),
  #              fun.max = \(.) quantile(.,0.75),
  #              fun = median,
  #              size=a) +
  # stat_summary(aes(x=lado_numeric,y=Pre_Umed,group=k_factor,color="3 quant"),
  #              fun = median,
  #              geom = "line",
  #              size=a) +
  stat_summary(fun.data = mean_se,geom ="line",aes(group=k_factor,color="avg+-sd"),alpha=0.6,size=a) +
  stat_summary(fun = mean,
               fun.min = function(x) mean(x) - sd(x), 
               fun.max = function(x) mean(x) + sd(x), 
               geom = "pointrange",
               aes(x=lado_numeric,y=Pre_Umed,color="avg+-sd"),alpha=0.6,size=a) +
  geom_vline(aes(xintercept=SoE.99,color="SoE >= 0.99"),alpha=0.5) +
  scale_color_manual(name="",values=cols) +
  scale_x_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x)) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
  facet_wrap(~k_factor,ncol=5) +
  theme_classic() +
  labs(title = "Média da estimativa média da taxa U predito pelo LMM:",
       subtitle="logit(Umed) ~ log(S) * log(N) * k * scale + (1|Site)",
       x="scale (landscape side, km)",
       y="avg U rate (Umed)",
       color="") +
  theme(legend.position = "top")
```

__Figura 5__ Média das estimativas médias da taxa U (eixo x) em fução do lado da paisagem ao redor (scale, eixo x). Em azul a média e o desvio padrão para cada combinação de grau de limitação de dispersão (título dos paineis, k = proporção de propágulos que permanece até a vizinhança imediata) e scale. S = número de espécies, N = número de indivíduos. As linhas verticais em vermelho marcam a escala que acumula pelo menos 0.99 de toda a variação da média com o aumento da escala (Ver seção "Escala que acumula a maior parte do efeito da escala").

__Escala que acumula a maior parte do efeito da escala__

Para determinar quais os graus de limitação de dispersão são apropriados para simular nas paisagens de lado 4 km avaliamos qual a escala que acumula pelo menos 99% de toda a variação observada para a média geral com o aumento da escala até paisagens de lado 16 km. Para isso, calculei por grau de limitação de dispersão: a diferença entre a média da estimativa entre 2 escalas consecutivas e dividi o valor pela amplitude para todas as escalas; então os valores de escalas consecutivas são somados em ordem crescente. A escala que acumula pelo menos 0.99 é considerada como a extensão espacial mínima suficiente para simular aquele grau de limitação de dispersão (linhas verticais figura 5). 

Com a redução da limitação de dispersão há aumento na escala adequada (Figura 5, linhas verticais vermelhas): quando k é até 0.90 o lado de 1 km é suficiente; k entre 0.50 e 0.40 sugere incerteza entre o lado de 1 e 2 km; e a partir de k igual 0.20 o lado suficiente é maior do que 4 km. Nos graus de limitação de dispersão pouco severos e pouco brandos (k c [0.85;0.55]), onde ocorre valores máximos da média da estimativa da taxa U (Figura 2), não foi possível obsservar tendência de mudança na média geral (Figura 5). Nesses graus de limitação de dispersão há a menor variação entre escalas para um mesmo sítio e maior variação entre sítios, considerando todo o conjunto de dados (Figura 5). O aumento da variação do padrão geral da média parece estar associado ao aumento do número de espécies per capita (Figura 5). Em média, a extensão espacial adequada para simular os graus onde não foi possível estimar a escala adequada deve variar entre 1 e 2 km. Assim, as paisagens mínimas suficientes para simular os graus de limitação de dispersão são: 1 km de lado, para k entre 0.99 e 0.90; 1 e 2 km de lado, para k entre 0.85 e 0.35; 2 km de lado, para k igual 0.30; e 4 km de lado, para k igual 0.25 (Figura 6).  

```{r figura 6 scale e k adequados}
df_plot |> 
  ggplot(aes(x=k_factor,y=SoE.99)) +
  geom_hline(yintercept = 4,color="red") +
  geom_point() +
  geom_rect(aes(xmin=4, xmax=13.5, ymin=0.99, ymax=2.1),alpha=0.01) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = c(0.5,1,2,4,8)) +
  labs(x="k = proporção de propágulos que permanece na vizinhança imediata",
       y="lado da paisagem (km)",
       title="lado da paisagem que acumula 99% de todo efeito de escala observado na média") +
  theme_classic()
```

__Figura 6__ Lado da paisagem que acumula a maior parte do efeito da escala no grau de limitação de dispersão. Em cinza a área com grande incerteza na estimativa da escala adequada: o lado da paisagem 1 e 2 km podem ser adequados.

Fim da proposta 2 ###



### Support Information

#### Gráficos Diagnóstico do LMM 

```{r diagnostico modelo mais plausivel GLMM efeito de escala}
df_AICctab <- AICctab(l_md,weights=T) |> as.data.frame()
md_SoE <- l_md[[row.names(df_AICctab[1,])]]
p_plot <- simulateResiduals(md_SoE,n=1000)
plot(p_plot)
```

```{r coef sítios}
df_ranef <- ranef(md_SoE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  inner_join(y=distinct(select(df_sim,SiteCode, Ntotal, S_obs)),"SiteCode") 
df_ranef |> 
  pivot_longer(-SiteCode) |>
  ggplot(aes(sample=value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") + theme_classic() +
  facet_wrap(~name) +
  labs(title="qqnorm: interceptos por sítios (1|SiteCode")
```

```{r diagnosticos 1 dados originais 36 sitios}
df_plot |> 
  pivot_longer(log_S_obs_z:log_Ntotal_z) |> 
  ggplot(aes(x=value,y=deviance)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~name,ncol=2)
df_plot |> 
  ggplot(aes(x=logit_Umed,y=predict)) +
  geom_point() +
  geom_smooth(aes(group=SiteCode),se = F,method = "lm") +
  geom_abline(slope = 1,intercept = 0,color="red")
summary(lm(predict~logit_Umed,df_plot))
plot(md_SoE)
df_plot |> 
  ggplot(aes(x=Ntotal,y=Umed,group=k_factor)) +
  geom_point() 
# +
  # geom_smooth()
```

__Figura 5__ Gráficos diagnósticos

Resíduos quantilícos do LMM mais plausível: logit(Umed) ~ log(S) + log(N). Umed = média da bateria de simulações (# réplicas = 10), S = riqueza de espécies, N = número de indivíduos.



<!-- ## Códigos para estimar U nas diferentes extensões espaciais -->


##### Códigos para rodar as simulações

<p>Olhar source/SoE_MNEE.R para os códigos que estimam U para diferentes extensões espaciais.</p>

```{r codigos para estimar U para uma mesma extensao espacial e diferentes k,eval=FALSE}
# usado para estimar o U para uma determinada
setwd("dados/simulacao")
f_siteU <- function(df,replicas=4,csv.repo="../csv/U_nullLand_16km/"){
  l_dfU <- list()
  for(i in 1:nrow(df)){
    v_U <- replicate(n=replicas,f_simU(df = df[i,]))
    l_dfU[[i]] <- cbind(select(df[i,],-(txt.file:DA)),matrix(v_U,nrow = 1))
  }
  df_write <- rbind.fill(l_dfU)
  write_csv(df_write,file = paste0(csv.repo,df$SiteCode[1],".csv"))
}
registerDoMC(2)
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
d_ply(df_sorteio_sitios,"SiteCode",f_siteU,.parallel = TRUE)
```

```{r codigos para estimar U SoE, eval=FALSE}
setwd("dados/simulacao")
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
df_se <- df_sorteio_sitios # |> filter(k %in% unique(df_sim$k)[c(16,19)]) # para seleção de alguns cenários
registerDoMC(3)
a_ply(df_se[-1,],1,f_SoE_MNEE_null,.parallel = TRUE)
##
df_sitios_2lote <- data.frame(path.file = list.files("../csv/SoE",".csv",full.names = T)) |>
  mutate(ctime = as.Date(file.info(path.file)$ctime),
         SiteCode = str_extract(path.file,"(?<=E\\/).*?(?=\\_k)"),
         k = as.numeric(str_extract(path.file,"(?<=\\_k).*?(?=\\.csv)")),
         label = paste(SiteCode, k/100)) |>
  filter(ctime>"2023-01-02")
df_se2 <- df_sorteio_sitios |> 
  mutate(label = paste(SiteCode, round(k,2))) |>
  anti_join(select(df_sitios_2lote,SiteCode:label),by="label") |> 
  select(-label)
registerDoMC(2)
a_ply(df_se2,1,f_SoE_MNEE_null,.parallel = TRUE)
#
df <- df_se |> filter(SiteCode == "PRrico3",k==unique(df_se$k)[3])
```

Em alguns sítios não foi possível simular a extensão de 0.5 km para nenhum cenário de dispersão. Nesse extensão espacial, a parcela corresponde à 0.64 da área da parcela, ta certo isso?

o erro informado é:
A practical cause to "corrupted size vs. prev_size" is quite simple - memory chunk control structure fields in the adjacent following chunk are being overwritten due to out-of-bounds access by the code. if you allocate x bytes for pointer p but wind up writing beyond x in regards to the same pointer, you might get this error, indicating the current memory allocation (chunk) size is not the same as what's found in the next chunk control structure (due to it being overwritten).

```{r arrumando os dados do SoE para k05,eval=FALSE}
v_csv.path <- list.files(path = "dados/csv/SoE", pattern = "_null.csv",full.names = T)
v_k <- unique(df_sim$k)
f_csv <- function(path.csv){
  df <- read_csv(path.csv)
  df$k <- v_k[20]
  df <- cbind(df[,c(1:2,7)],df[,3:6])
  file.remove(path.csv)
  write_csv(df,file = gsub("null",paste0("k",v_k[20]*100),path.csv))
}
v_logical <- sapply(v_csv.path[-1],f_csv)
system("du -s dados/csv/SoE/")
```

```{r df sorteios sitios, eval=FALSE}
df_sorteio_sitios <- df |> 
  filter(S_obs %in% sample(size = 15,df$S_obs) | DA %in% sample(size = 15,df$DA)) |> 
  rbind(filter(df,S_obs %in% range(df$S_obs) | DA %in% range(df$DA))) |>  distinct()
write_csv(df_sorteio_sitios,file = "dados/csv/df_sorteio_sitios.csv")
```
