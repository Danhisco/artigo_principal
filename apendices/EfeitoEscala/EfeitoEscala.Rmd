---
title: "Efeito de escala na estimativa da taxa U necessária para manter a riqueza local no equilíbrio em um modelo neutro espacialmente explícito"
author: 
  - Danilo Pereira Mori, Laboratório de Ecologia Teórica (IBUSP)
date: "2022-08-20"
output:
  pdf_document:
    latex_engine: xelatex
    extra_dependencies: ["tabu"]
  html_document: default
editor_options:
  chunk_output_type: console
# bibliography: citations.bib
csl: plos.csl
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# pacotes
library(lubridate)
library(doMC)
library(raster)
library(insight)
library(DHARMa)
library(bbmle)
library(broom.mixed)
library(lme4)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr) 
library(tidyr)
library(plyr)
library(dplyr)
# funções
source("source/dinamica_coalescente.R")
source("source/SoE_MNEE.R")
source("source/f_z.R")
source("source/nameModel.R")
# df dados da proporção de cobertura vegetal
df_p <- read_csv("dados/df_p.csv")
# df dados para simulação
df_sim <- read_csv("dados/df_simulacao.csv") |> 
  inner_join(x=df_p,by="SiteCode")
# df_sorteio_sitios
df_sorteio_sitios <- read_csv(file="dados/csv/df_sorteio_sitios.csv") |> 
  select(-d) |> 
  inner_join(x=select(df_sim,SiteCode,d,k),by="SiteCode")
# v_sim_sites: se precisar é só mover as paisagens de volta ou incluir um programa coalescente na outra pasta
## acabei perdendo a mão e deletei as paisagens nulas de ambas situações, mas tudo bem faz mais em mapas_...Rmd
# v_sim_sites <- list.files(path="dados/simulacao",pattern = "_null.txt")
# file.copy(from=paste0("dados/simulacao/",v_sim_sites),
#           to=paste0("dados/paisagens/paisagens_SoE_MNEE/",v_sim_sites))
# file.remove(paste0("dados/simulacao/",v_sim_sites))
# df_SoE
df_Usoe.rep <- read_csv("dados/csv/df_Usoe.csv") |> 
  pivot_longer(cols=`1`:`10`, names_to = "n", values_to = "U") |> 
  inner_join(x=distinct(select(df_sim,SiteCode,effort_ha:S_obs)),by="SiteCode") |> 
  arrange(S_obs,k)
# df_Unull
df_Unull <- df_Usoe.rep |> filter(round(lado_km) == 16) 
# df_Usoe
df_Usoe <- df_Usoe.rep |> 
  arrange(lado_km) |> 
  group_by(SiteCode,k,lado_km) |> 
  summarise(Umed = mean(U),
            Umedian = median(U)) |> 
  mutate(diffU = Umed - Umedian)
# registerDoMC(3)
df_Usoe <- ddply(df_Usoe,c("SiteCode","k"),f_lag.U,.parallel = TRUE)
df_Usoe$Schange <- factor(df_Usoe$lado_km,labels=c(paste(16/(2^(5:1)),"->",16/(2^(4:0))),NA))
df_Usoe$Schange_cumulative <- factor(df_Usoe$lado_km,labels=c(paste(0.5,"->",16/(2^(4:0))),NA))
df_Usoe$k_factor <- factor(round(df_Usoe$k,2),levels = sort(unique(round(df_Usoe$k,2)),decreasing = T))
df_Usoe <- df_Usoe |> 
  group_by(SiteCode,k) |> 
  summarise(Ucv = sd(Umed)*100/mean(Umed),
            Ulag_f = ifelse(any(Ulag < -0.1,na.rm = T),"neg_v","pos_v")) |> 
  mutate(Ucv_f = ifelse(Ucv>10,"top90","low10")) |> 
  # select(-Ucv) |> 
  inner_join(x=df_Usoe,by=c("SiteCode","k"))
# df_md
df_md <- df_Usoe |> 
  inner_join(distinct(select(df_sim,SiteCode,effort_ha:S_obs)),by="SiteCode") |> 
  mutate(logit_Umed = log(Umed/(1-Umed)),
         DA = Ntotal / effort_ha,
         S.DA = S_obs / Ntotal,
         log2_lado.km = log2(round(lado_km,1)),
         lado_factor = factor(round(lado_km,1)) ) |> 
  select(SiteCode,Umed,logit_Umed,k,k_factor,lado_factor,lado_km,log2_lado.km,S_obs,Ntotal,DA,S.DA) |> 
  mutate(across(S_obs:S.DA,log,.names="log_{.col}"),
         across(c(k,log2_lado.km,S_obs:log_S.DA),f_z,.names="{.col}_z"))
md_SoE <- lmer(logit_Umed ~ log_S_obs_z * log_Ntotal_z * k_factor * lado_factor + (1|SiteCode),
                  data=df_md)
# dados usados na simulação com os valores preditos e os residuos z transformados
df_plot <- df_md |> 
  select(SiteCode, logit_Umed:lado_factor, S_obs,Ntotal,log_S_obs_z:log_Ntotal_z)
df_plot$deviance <- residuals(md_SoE,scale=T)
df_plot$predict <- predict(md_SoE)
df_plot <- df_plot |> 
  mutate(Umed = exp(logit_Umed) / exp(1-logit_Umed),
         Pre_Umed = exp(predict) / exp(1-predict),
         lado_numeric=as.numeric(as.character(lado_factor)))
df_plot <- df_plot |>
  group_by(k_factor,lado_factor) |> 
  summarise(Umed = mean(Pre_Umed)) |> 
  ddply("k_factor",f_lag.U) |>
  ddply("k_factor",f_k.SoE) |> 
  select(k_factor,SoE.99) |> 
  inner_join(x=df_plot,by="k_factor")
```

```{r trackdown,eval=FALSE}
library(trackdown)
# 1a vez:
upload_file(file="apendices/EfeitoEscala/EfeitoEscala.Rmd",
            gpath = "mestrado/DaniloPMori-artigo_mestrado/",
            hide_code = TRUE)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
update_file(file ="apendices/EfeitoEscala/EfeitoEscala.Rmd",
            gpath = "mestrado/DaniloPMori-artigo_mestrado/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file ="apendices/EfeitoEscala/EfeitoEscala.Rmd",
              gpath = "mestrado/DaniloPMori-artigo_mestrado/")
```

__Objetivo__
 
<p> Primeiro avaliamos se a maior extensão considerada é suficiente para obter o padrão não linear de U esperado em paisagens infinitas. E depois comparamos a estimativa de U para cada subescala (0.5, 1, 2, 4, 8 e 16 km de lado da paisagem ao redor quadrada). Dos 108 sítios selecionados para a comparação dos modelos neutros, 36 foram sorteados e selecionados para avaliar qual a extensão espacial suficiente para comparar os modelos neutros. Esses 36 sítios incluem os extremos da riqueza de espécies e densidade de indivíduos observada e outros 32 sítios sorteados na amplitude de valores dessas duas variáveis (figura 1a). Para cada sítio simulamos 20 graus de limitação de dispersão no modelo espacialmente explícito (Figura 1b e Figura 2). Vamos selecionar os graus de limitação de dispersão no qual a extensão espacial de 4x4 km2 acumula a maior parte do efeito da escala na estimativa de U. </p>

```{r figura 1 variaveis de controle e cenarios de limitacao de dispersao,fig.height=4}
df_plot <- df_sim |>
  filter(k==0.05) |> 
  mutate(sorteio_site = ifelse(SiteCode %in% unique(df_Unull$SiteCode),"SoE","non SoE"),
         DA = Ntotal / effort_ha)
l_p <- list()
l_p[[1]] <- df_plot |> 
  ggplot(aes(x=DA,y=S_obs,color=sorteio_site)) +
  geom_point(alpha=0.8) +
  scale_color_manual(values=c("black","red"),name="SoE: 36 sites") +
  labs(x="density (individuals / ha)", 
       y="spp richness",
       title="a) 108 sítios totais, 36 para estudo") +
  theme(legend.position = "bottom")
l_p[[2]] <- df_sim |> 
  ggplot(aes(x=k,y=d,group=k)) +
  geom_jitter() +
  geom_boxplot() +
  labs(x = "k",
       y = "d",
       title = "b) graus de dispersão")
grid.arrange(grobs=l_p,ncol=2)
```

<p> __Figura 1__ a) Riqueza de espécies e densidade de indivíduos nas parcelas dos 106 sítios selecionados (parcela contígua de pelo menos 1ha). Em vermelho os pontos amostrados e selecionados para investigar a extensão espacial da paisagem ao redor usando MNEE (Scale of Effect, SoE). b) Cenários de limitação de dispersão simulados. k = proporção de propágulos que permanece até a vizinhança imediata (distância média entre indivíduos); d = desvio padrão da função de dispersão com distribuição de Laplace. Para detalhes sobre a seleção dos sítios na base TreeCo e sobre os cenários de limitação à dispersão olhar o texto principal.</p>

### Taxa U na maior extensão espacial da paisagem (16x16km2)


```{r figura 2 U para todo k em paisagens nulas na maior escala investigada,fig.width=12,fig.height=7}
df_plot <- df_Unull |> 
  arrange(S_obs) |> 
  mutate(label = paste(SiteCode,S_obs,Ntotal,effort_ha,sep = ", "))
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |> 
  ggplot(aes(x=k,y=U)) +
  # geom_line() +
  # geom_smooth(method = "loess",se=F) +
  geom_point(alpha=0.4) +
  stat_summary(geom = "line",fun.data = mean_se) +
  stat_summary(geom = "pointrange",fun.data = mean_se, color="red",size=0.1) +
  stat_summary(geom = "errorbar",fun.data = mean_se, color="red",linewidth=0.5) +
  labs(title = "U estimado por cenário de dispersão em paisagens nulas de lado 16 km",
       subtitle = "label = SiteCode, S, N, plot area(ha); free y axis; reverse x axis") +
  # geom_vline(xintercept = c(0.25, 0.1,0.05),color="red",alpha=0.4) +
  scale_x_reverse() +
  facet_wrap(~label, ncol=6,scales="free_y") +
  theme_classic()
# ggsave("apendices/EfeitoEscala/fig2_U16_k.png",
#        width = 17.2,
#        height = 6.7)
```

<p> __Figura 2__ U estimado (eixo y) por cenário de limitação de dispersão (eixo x) em paisagens sem perda de cobertura vegetal (nulas) na maior extensão espacial (lado de 16 km). Os pontos são as estimativas réplicas de U, os pontos vermelhos marcam o valor médio e a linha une os valores médios entre cenários de limitação de dispersão. Eixo y varia entre paineis e eixo x está reverso. Quanto menor k, maior a capacidade de dispersão, simulada com um kernel de dispersão com decaimento exponencial da probabilidade de colonização com o aumento da distância. S = riqueza da espécie, N = número de indivíduos.</p>

A taxa U estimada na extensão de 16x16 km2 apresenta padrão não linear com máximo em graus pouco severos de limitação de dispersão (Figura 2). Há muita variação entre os sítios, relacionado com a riqueza de espécies (texto principal resultados), por isso na figura 2 o eixo y varia entre paineis. A variação das réplicas em torno da média pode ser elevada (Figura 2). Os valores médios sugerem um padrão de patamares, com valores baixos de U quando a limitação de dispersão é severa e em graus pouco severos um aumento brusco que suavemente diminui com o relaxamento da limitação de dispersão (Figura 2). Uma vez que observamos um padrão qualitativamente similar ao esperado em paisagens infinitas, iremos considerar a extensão espacial de 16x16 km2 como maior escala de referência para os graus de limitação de dispersão. A seguir o efeito 

### Efeito da escala na estimativa média da taxa U por grau de limitação de dispersão

```{r figura 3 Umed por lado da paisagem,fig.width=13,fig.height=8}
df_plot <- df_Usoe.rep |> 
  mutate(DA = Ntotal / effort_ha,
         label = paste(SiteCode,S_obs,Ntotal,round(DA,1),sep = ", "),
         k = round(k,2)) 
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |>
  ggplot(aes(x=lado_km,y=U,color=k,group=factor(k))) +
  geom_point(alpha=0.4) +
  stat_summary(geom = "line",fun.data = mean_se) +
  stat_summary(geom = "pointrange",fun.data = mean_se, color="black",size=0.1) +
  scale_x_continuous(trans='log2',breaks = c(0,round(16.02/2^(5:0),1))) +
  # scale_color_gradient2(low="red",mid = "green",high = "blue", midpoint = 0.5) +
  scale_color_distiller(palette = "Spectral") +
  theme_gray() +
  # theme(legend.position = "bottom") +
  labs(title = "U estimado em diferentes subescalas da paisagem ao redor para os 20 cenários de limitação de dispersão (k)",
       subtitle="facet label = Site code, riqueza, número de indivíduos ,densidade; free y axis",
       x = "lado da paisagem (km)",
       y = "taxa U estimada") +
  # guides(color = guide_legend(title.position = "right")) + # gostaria de deixar o k para a direita e completar a descição dele, mas não tive tempo para fazer
  theme(legend.position= c(0.57,1.10),
        legend.direction = "horizontal",
        legend.justification='left',
        legend.background = element_rect(fill=alpha('white', 0.1))) +
  facet_wrap(~label,ncol = 6,scales="free_y")
ggsave("apendices/EfeitoEscala/fig3_Uk_ladoKM.png",
       width = 17.2,
       height = 6.7)
```

<p> __Figura 3__ U estimado (eixo y) nas diferentes extensões espaciais (eixo x) e para os 20 graus de limitação de dispersão (cor dos pontos e linhas). Pontos representam a média de 10 réplicas por bateria de simulação e as linhas ligam os pontos médos. Eixo y varia entre paineis.</p>

Principalmente para os graus de limitação de dispersão brandos, observamos o padrão esperado de a taxa U diminuir com o aumento da escala (Figura 3). Em para graus pouco severos de limitação de dispersão pode existir pouca variação na estimativa média entre escalas (Figura 3 e 4). Os graus pouco severos devem operar no máximo global de taxa U necessária para obter a riqueza observada (Figura 2) e por isso devem apresentar baixa variação na estimativa da taxa U com a mudança na escala. As estimativas médias irão diminuir com o aumento da escala para todos os graus de limitação de dispersão?

```{r figura 4 Ucv por k}
# versão 1:
df_Usoe |>
  group_by(SiteCode,k) |>
  summarise(Ucv = sd(Umed)*100/mean(Umed)) |>
  ggplot(aes(x=k,y=Ucv, group=k)) +
  geom_jitter() +
  geom_boxplot() +
  geom_hline(yintercept = 10,color="red") +
  labs(x="k, prop. de propágulos até a vizinhança imediata",
       y="Coef. Var. de Umed (%)",
       title="Variação da média de U considerando todas as escalas")
```

__Figura 4__ Coeficiente de variação (sd/mean) de Umed (eixo y) para um mesmo cenário de limitação de dispersão (eixo x) e sítio, considerando todas as escalas. 

### Proposta de quantificação do efeito de escala acumulado até uma determinada subescala

Calculamos a diferença entre a média de U de escalas consecutivas e dividimos pela amplitude de U para todas as escalas (Ulag). Eperavamos que o aumento da escala iria reduzir a estimativa da taxa U, ou seja, esperavamos que os valores extremos de escala fossem os valores extremos de U e, dessa forma, a soma de Ulag poderia quantificar o efeito acumulado até uma determinada escala.

```{r figura 5 Ulag por grau de limitação de dispersão}
df_Usoe |>
  drop_na() |> 
  ggplot(aes(x=Ucv,y=Ulag)) +
  geom_point() +
  geom_smooth(se=F) +
  geom_hline(yintercept = 0,col="red") +
  geom_vline(xintercept = 10,colour="red") +
  facet_wrap(~k_factor,ncol=5) +
  labs(x="Coef. Var. de Umed (%)",
       y="Ulag",
       title="Ulag = ( U_i - U_i+1 )/ U_breadth; U_breadth = diff(range(Umed)), Umed = mean(U)")
```

__Figura 5__ Diferença na estimativa média de escalas consecutivas dividido pela amplitude das estimativas médias para todas as escalas (eixo y) e o coeficiente de variação das estimativas médias para todas as escalas. Paineis dividos pelo grau de limitação de dispersão.

Os graus de limitação de dispersão 
Em alguns casos podemos observar Ulag negativo (Figura 5), indicando que o aumento da escala pode aumentar a estimativa média de U. Quando há pouca variação na estimativa média para todas as escalas se torna comum observar Ulag mínimos mais próximos de -1 ao invés de 0; esses casos são comuns em graus de limitação de dispersão pouco severos e pouco brandos onde a estimativa de U é próxima do máximo global (figura 2).


Valores de Ulag negativos indicam que o aumento da escala pode aumentar a estimativa média de U. Nos casos em que Ulag = -1 pode existir um padrão não linear de máximo ou apresentar um padrão que sugere estabilização (Figura 6). Também observamos variação das réplicas entorno da média (Figura 6). Esses resultados sugerem que graus de limitação de dispersão pouco severos e pouco brandos podem ter pouca sensibilidade ao aumento da extensão espacial da paisagem ao redor, pois já operam próximo do máximo global

```{r figura 6 filtro de figura 3 apenas aqueles com low10 e Ulag menor do que -0.5}
df_plot <- df_Usoe |> filter(Ucv_factor=="low10" & Ulag < -0.5) |> select(SiteCode, k) |> distinct() |> 
  inner_join(x=df_Usoe.rep,by=c("SiteCode","k")) |> 
  mutate(DA = Ntotal / effort_ha,
         k = round(k,2),
         k_factor = factor(k),
         label = paste0(SiteCode,", S=",S_obs)) 
df_plot$label <- factor(df_plot$label,levels = unique(df_plot$label))
df_plot |>
  ggplot(aes(x=lado_km,y=U,color=k,group=factor(k))) +
  geom_point() +
  stat_summary(geom = "line",fun.data = mean_se) +
  stat_summary(geom = "pointrange",fun.data = mean_se) +
  scale_x_continuous(trans='log2',breaks = round(16.02/2^(5:0),0)) +
  scale_color_distiller(palette = "Spectral") +
  labs(title = "Casos em que Ucv < 10 e Ulag < -0.5",
       subtitle="*filtrado da figura 3",
       x = "lado da paisagem (km)",
       y = "taxa U estimada") +
  theme_dark() +
  theme(legend.position= c(0.57,1.07),
        legend.direction = "horizontal",
        legend.justification='left',
        legend.background = element_rect(fill=alpha('white', 0.1))) +
  facet_wrap(~label,ncol = 6,scales="free_y")
```

__Figura 6__ Filtro de paineis da figura 3 onde Ulag=-1, os paineis estão subdividos pelo sítio e grau de limitação de dispersão.

O efeito acumulada da escala das baterias de simulação (sítio e grau de limitação de dispersão) com pelo menos 10% de coeficiente de variação da estimativa da média pode informar quais os cenários apropriados para simular na extensão de 4x4 km2 (figura 7), pressuposto que o efeito acumulado de pelo menos 90% é suficiente simular o grau de limitação de dispersão (linha azul, figura 7). Alguns graus de limitação de dispersão podem apresentar padrão não linear com a variação na escala (Figura 5), essas bateriais de simulação operam próximos do máximo global da estimativa de U (figura 2) e podem ser pouco afetadas pela escala ou apresentam padrão não linear (Figura 6). O esperado era que o aumento da escala iria reduzir a estimativa de U, o quê pode ser observado em graus severos ou brandos de limitação de dispersão, mas não em graus pouco severos e brandos (Figura 7). 


```{r antiga figura 7 Ucumulative top 90,fig.height=8,fig.width=8,eval=F,include=F}
df_Usoe |> 
  filter(Ucv_factor == "top90") |> 
  drop_na() |>
  ggplot(aes(x=Schange_cumulative, y = Ucsum, color=k,
             group=interaction(k_factor,Schange_cumulative))) +
  geom_point() +
  geom_boxplot(aes(color=k)) +
  # geom_text(aes(label = round(k,2)), nudge_y = 0.5) +
  geom_hline(yintercept = 0.9,color="red",alpha=0.6) +
  ## na próxima versão do gráfico a idea é:
  # stat_summary(aes(group=interaction(k_factor,lado_factor)),
  #              geom = "ribbon",fun.data = mean_se, color="green",alpha=0.4) +
  # stat_summary(aes(group=interaction(k_factor,lado_factor)),
  #              geom = "line",fun.data = mean_se,color="green") +
  labs(x="mudança de escala",
       y="cumsum(Ulag)",
       title="",
       subtitle = "apenas os caos em que Ucv > 10 (figura 5)") +
  theme_classic()
  # facet_wrap(~k_factor,ncol=3)
# ggsave("apendices/EfeitoEscala/fig4_Ucs.png",
#        width = 17.2,
#        height = 6.7)
# grid.arrange(grobs=l_p,nrow=2)
```

<!-- <p> __Figura 7__ O efeito de escala acumulado entre escalas consecutivas.  -->
<!-- No conjunto de paineis em 'a' os valores calculados para cada mudança de escala, em 'b' o valor acumulado. Os subpainíeis estão dividos pelo cenário de limitação de dispersão.</p> -->


```{r atual figura 7}
df_Usoe |> 
  drop_na() |>
  # filter(Ulag_f == "pos_v") |>
  # filter(Ucv_factor == "top90") |> 
  ggplot(aes(x=Schange_cumulative,y=Ucsum)) +
  geom_point(position = position_jitter(w = 0.1, h = 0),alpha=0.5) +
  geom_boxplot(aes(group=Schange_cumulative)) +
  geom_smooth(aes(group=1),method = "loess",se=F,color="black") +
  stat_summary(fun.data = mean_se,color="red",size=0.2) +
  geom_hline(yintercept = 0.9, color="blue") +
  facet_wrap(~k_factor, nrow=4) +
  labs(x="mudança acumulada de escala (lado da paisagem em km)",
       y="cumsum(Ulag)",
       title="Os graus de limitação de dispersão apropriados na exensão de 4x4km2 são mais severos ou iguais à k=0.40 em média") +
  theme_classic()
```

__Figura 7__ Efeito acumulado do aumento da escala na estimativa de U. Ulag = ( Umed_i - Umed_i+1 )/ diff(range(Umed)), Umed = mean(U), i c [0.5; 16] km de lado da paisagem. cumsum = soma acumulativa das escalas consecutivas em ordem crescente. Pontos são os valores estimados das bateria de simulação (sítio e grau de limitação de dispersão) no qual a variação na escala marcou pelo menos 10% no coeficiente de variação da média estimada por escala (Figura 5). Os pontos em vermelho representam a média, as linhas vermelhas verticais ao redor das médias marcam o desvio-padrão; a linha liga as médias; o boxplot marca os 3 primeiros quantils. Paineis são separados pelo grau de limitação de dispersão (k = proporção de propágulos que permanecem até a vizinhança imediata da planta progenitora).  

### Proposta 2: sem remover as baterias com Ulag < 0
__1) descrever o padrão por modelos de regressão LMM__
__2) aplicar a lógica do Ulag -> Ucsum no padrão predio pelas análises de regressão__

Procuro considerar todos os dados sem aplicar filtros que modificam a variabilidade dos dados, mas que ainda permitem descrever a tendência geral dos dados. 

__Motivação de cada variável__

A estimativa de U depende da arvóre genalógica da comunidade simulada por MNEE. O número de indivíduos (N) determina o número inicial de linhagens que são monitoras e o número de espécies (S) determina o número final de linhagens monitoradas. A árvore genealógica da comunidade também é influenciada pelo grau de limitação de dispersão (k) e da extensão espacial (scale), pois em alguns graus de limitação de dispersão a árvore genealógica pode ser restringida pela extensão da paisagem e não pela limitação de dispersão. 

__Modelos Estatísticos__

Para descrever a média da estimativa da taxa U optamos por transformar a variável usando a função logito e usar um modelo gaussiano misto (LMM). O número de indivíduos e riqueza foram modelados na escala log e z (transformação z). As variáveis graus de limitação de dispersão (k) e extensão espacial da paisagem ao redor (scale) foram interpretados como fatores, então cada combinação de k e scale possui um intercepto. Os dados foram agrupados por sítio, então cada sítio possui um intercepto comum. Não inclui estruturas mais complexas como a de ter um intercepto por grau de limitação de dispersão e sítio, pois isso implicaria em estimar um parâmetro a cada 6 valores e portanto muito tempo para a estimativa completa. Na tabela 1 há comparação de 4 modelos que consideram a interação das 4 variáveis. 

__tabela 1__ Seleção das variáveis de controle. S_obs = riqueza observada, N = número de indivíduos, DA = densidade de indivíduos;  Funções lmer do pacote lme4 (REF), AICctab do pacote bblme (REF). 

```{r GLMM selecao de variaveis para fixar no GLMM final,eval=T,cache=T,echo=TRUE}
l_md <- list()
l_md[[1]] <- lmer(logit_Umed ~ log_S_obs_z * log_Ntotal_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
l_md[[2]] <- lmer(logit_Umed ~ log_S_obs_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
l_md[[3]] <- lmer(logit_Umed ~ S_obs_z * Ntotal_z * k_factor * lado_factor  + (1|SiteCode),data=df_md)
l_md[[4]] <- lmer(logit_Umed ~ S_obs_z * k_factor * lado_factor + (1|SiteCode),data=df_md)
names(l_md) <-laply(l_md,f_nameModel)
AICctab(l_md,weights=T)
```

O modelo mais plausível considera os logs da riqueza observada e número de indivíduos na parcela (tabela 1).

__Tabela 3__ Coeficientes de determinal (R2) do modelo mais plausível: marginal(m, desconsiderando o efeito aleatório) e condicional(c, considerando o efeito aleatório):

```{r R2 marginal e condicional do modelo mais plausível para descrever SoE}
# print("R2 marginal e condicional, respectivamente:")
# md_SoE <- AICctab(l_md,weights=T) |> as.data.frame() |> head(n=1) |> row.names() |> 
#   (\(.) l_md[[.]])()
md_SoE |> (\(.) MuMIn::r.squaredGLMM(.))()
```

Os coeficientes de determinação marginal e condional do modelo são aproximadamente iguais à 0.96.  

```{r diagnostico modelo mais plausivel GLMM efeito de escala}
df_AICctab <- AICctab(l_md,weights=T) |> as.data.frame()
md_SoE <- l_md[[row.names(df_AICctab[1,])]]
p_plot <- simulateResiduals(md_SoE,n=1000)
plot(p_plot)
```

```{r coef sítios}
df_ranef <- ranef(md_SoE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  inner_join(y=distinct(select(df_sim,SiteCode, Ntotal, S_obs)),"SiteCode") 
df_ranef |> 
  pivot_longer(-SiteCode) |>
  ggplot(aes(sample=value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") + theme_classic() +
  facet_wrap(~name) +
  labs(title="qqnorm: interceptos por sítios (1|SiteCode")
```

```{r diagnosticos 1 dados originais 36 sitios}
df_plot |> 
  pivot_longer(log_S_obs_z:log_Ntotal_z) |> 
  ggplot(aes(x=value,y=deviance)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~name,ncol=2)
df_plot |> 
  ggplot(aes(x=logit_Umed,y=predict)) +
  geom_point() +
  geom_smooth(aes(group=SiteCode),se = F,method = "lm") +
  geom_abline(slope = 1,intercept = 0,color="red")
summary(lm(predict~logit_Umed,df_plot))
plot(md_SoE)
df_plot |> 
  ggplot(aes(x=Ntotal,y=Umed,group=k_factor)) +
  geom_point() 
# +
  # geom_smooth()
```

__Figura 5__ Gráficos diagnósticos

Resíduos quantilícos do LMM mais plausível: logit(Umed) ~ log(S) + log(N). Umed = média da bateria de simulações (# réplicas = 10), S = riqueza de espécies, N = número de indivíduos.


```{r figura para resultados do efeito de escala}
cols <- c("avg+-sd"="#f04546","3 quant"="#3591d1")
a <- 0.5
df_plot |> 
  ggplot(aes(x=lado_factor,y=Pre_Umed)) + #,group=k_factor,color=k
  stat_summary(aes(x=lado_factor,y=Pre_Umed,color="3 quant"), #,color=name,group=name
               fun.min = \(.) quantile(.,0.25),
               fun.max = \(.) quantile(.,0.75),
               fun = median,
               size=a) +
  stat_summary(aes(x=lado_factor,y=Pre_Umed,group=k_factor,color="3 quant"),
               fun = median,
               geom = "line",
               size=a) +
  stat_summary(fun.data = mean_se,geom ="line",aes(group=k_factor,color="avg+-sd"),alpha=0.6,size=a) +
  stat_summary(fun.data = mean_se,aes(color="avg+-sd"),alpha=0.6,size=a) +
  scale_color_manual(name="statistic:",values=cols) +
  facet_wrap(~k_factor,ncol=5) +
  theme_classic() +
  labs(title = "Estatistica de resumo da taxa U predito pelo LMM:",
       subtitle="logit(Umed) ~ log(S) * log(N) * k * scale + (1|Site)",
       x="scale (landscape side, km)",
       y="Umed") +
  theme(legend.position = "top")
# determinação da escala que acumula a maior parte do efeito da escala
# v_k <- 
df_k.SoE |> 
  ggplot(aes(x=k_factor,y=SoE.99)) +
  geom_point()
df_k.SoE <- df_plot |> 
  filter(!(k_factor %in% df_k.SoE$k_factor)) |> count(k_factor)
  select(k_factor,lado_factor) |> distinct() |> 
  rbind(df_k.SoE)
```


Fim da proposta 2 ###





<!-- __Figura 6__ Primeira escala que acumula pelo menos 90% do efeito da escala -->

<!-- <p> Quanto maior a dupla de escalas consecutivas menor o valor de Ulag1, apesar de existir variação entre cenários de limitação de dispersão (figura 4). A amplitude de valores de Ulag1 aumenta com a limitação de dispersão (figura 4a), por exemplo, nas simulações em que k=0.25 a primeira mudança de escala (de 0.5 km para 1 km) pode variar entre 80% e 30% de toda a variação da taxa U com o aumento da escala; enquanto para k=0.10 e 0.05 essa mudança de escala representa em geral até 40% de variação na taxa U (Figura 4a). O Ulag1 acumulado dos cenários mais brandos de limitação (k=0.10 e 0.05) chega aos 90% quando passamos para a escala de 8 km (Figura 4b); enquanto no cenário de limitação mais brando esse valor pode ser observado quando passamos para a escala de 4 km, com mais da metade dos sítios, ou de 2 km, com menos de um quarto dos sítios (Figura 4b).</p> -->

<!-- ## Discussão -->
<!-- IDEIAS: -->
<!-- - Na maior extensão espacial considerada da paisagem local (16x16km2) observamos um padrão que é qualitativamente similar ao esperado em paisagens infinitas (May et al. 2011), assim pressupomos que a maior extensão espacial é a referência de menor valor da taxa U para uma determinada bateria de simulações (cenário de limitação de dispersão, riqueza de espécies, número de indivíduos na parcela e densidade de indivíduos na paisagem). -->
<!-- - Dado a natureza não truncada da função de dispersão, a extensão espacial da paisagem que estabiliza a taxa U estimada em cenários de limitação de dispersão muito brandos (e.g. k=0.05) pode ser superior à maior extensão simulada (16x16km2) - aqui não fizemos essa avaliação, porém em todos os sítios a taxa de U no cenário mais brando está na mesma ordem de magnitude do primeiro cenário, possibilitando o padrão não linear.   -->
<!-- - A riqueza de espécies, número de indivíduos na parcela e densidade de indivíduos na paisagem influencia na magnitude da estimativa de U e da variação de U em função da limitação de dispersão e da extensão espacial da paisagem (Figuras 2, 3 e 4). -->
<!-- - Nosso método para avaliar a extensão espacial que acumula a maior variação da taxa U, padroniza a amplitude de valores de um sítio como diferença total para aquela sítio, possibilitando a comparação de sítios com diferentes amplitudes de valores.  -->



<!-- - Outros trabalhos na Floresta Atlântica utilizam a extensão espacial de cerca de 4x4 km2. Nessa escala observamos que a taxa U pode ser superestimada em até 20% (quando comparado com paisagens de 16x16 km2) no cenário de maior capacidade de dispersão (k=0.05), por conta da restrição espacial da paisagem ao redor. Esse efeito deve ser observado em paisagens com pouca perda de habitat e bem funcionalmente conectados. A superestimava da taxa U na escala de 4x4 km2 compensa a redução da contribuição de propágulos para a reposição de espécies perdidas localmente que estariam presentes em paisagens de 16x16 km2 -->



### Support Information

```{r figura SI 1 amplitude de U em funcao das variaveis de controle Sobs e DA,fig.height=3,fig.width=8,eval=F,include=F}
df_Usoe$k_factor <- factor(round(df_Usoe$k,2))
l_p <- list()
l_p[[1]] <- df_Usoe |> 
  ggplot(aes(x=S_obs,y=Umed,color=DA)) +
  geom_smooth(method="lm",se=F) +
  geom_line(aes(group=SiteCode),alpha=0.4) +
  geom_point(size=2,aes(shape=k_factor))
l_p[[2]] <- df_Usoe |> 
  ggplot(aes(x=DA,y=Umed,color=S_obs)) +
  geom_smooth(method="lm",se=F) +
  geom_line(aes(group=SiteCode),alpha=0.4) +
  geom_point(size=2,aes(shape=k_factor))
grid.arrange(grobs=l_p,ncol=2)
```

<!-- <p> __Figura SI1__ Amplitude da taxa U estimada em função da densidade de indivíduos (DA) e da riqueza de espécies (S_obs). </p> -->

<!-- ## Códigos para estimar U nas diferentes extensões espaciais -->

<!-- <p>Olhar source/SoE_MNEE.R para os códigos que estimam U para diferentes extensões espaciais.</p> -->

```{r codigos para estimar U para uma mesma extensao espacial e diferentes k,eval=FALSE}
# usado para estimar o U para uma determinada
setwd("dados/simulacao")
f_siteU <- function(df,replicas=4,csv.repo="../csv/U_nullLand_16km/"){
  l_dfU <- list()
  for(i in 1:nrow(df)){
    v_U <- replicate(n=replicas,f_simU(df = df[i,]))
    l_dfU[[i]] <- cbind(select(df[i,],-(txt.file:DA)),matrix(v_U,nrow = 1))
  }
  df_write <- rbind.fill(l_dfU)
  write_csv(df_write,file = paste0(csv.repo,df$SiteCode[1],".csv"))
}
registerDoMC(2)
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
d_ply(df_sorteio_sitios,"SiteCode",f_siteU,.parallel = TRUE)
```

```{r codigos para estimar U SoE, eval=FALSE}
setwd("dados/simulacao")
df_sorteio_sitios$txt.file <- gsub(".txt","_null.txt",df_sorteio_sitios$txt.file)
df_se <- df_sorteio_sitios # |> filter(k %in% unique(df_sim$k)[c(16,19)]) # para seleção de alguns cenários
registerDoMC(3)
a_ply(df_se[-1,],1,f_SoE_MNEE_null,.parallel = TRUE)
##
df_sitios_2lote <- data.frame(path.file = list.files("../csv/SoE",".csv",full.names = T)) |>
  mutate(ctime = as.Date(file.info(path.file)$ctime),
         SiteCode = str_extract(path.file,"(?<=E\\/).*?(?=\\_k)"),
         k = as.numeric(str_extract(path.file,"(?<=\\_k).*?(?=\\.csv)")),
         label = paste(SiteCode, k/100)) |>
  filter(ctime>"2023-01-02")
df_se2 <- df_sorteio_sitios |> 
  mutate(label = paste(SiteCode, round(k,2))) |>
  anti_join(select(df_sitios_2lote,SiteCode:label),by="label") |> 
  select(-label)
registerDoMC(2)
a_ply(df_se2,1,f_SoE_MNEE_null,.parallel = TRUE)
#
df <- df_se |> filter(SiteCode == "PRrico3",k==unique(df_se$k)[3])

```

Em alguns sítios não foi possível simular a extensão de 0.5 km para nenhum cenário de dispersão. Nesse extensão espacial, a parcela corresponde à 0.64 da área da parcela, ta certo isso?

o erro informado é:
A practical cause to "corrupted size vs. prev_size" is quite simple - memory chunk control structure fields in the adjacent following chunk are being overwritten due to out-of-bounds access by the code. if you allocate x bytes for pointer p but wind up writing beyond x in regards to the same pointer, you might get this error, indicating the current memory allocation (chunk) size is not the same as what's found in the next chunk control structure (due to it being overwritten).

```{r arrumando os dados do SoE para k05,eval=FALSE}
v_csv.path <- list.files(path = "dados/csv/SoE", pattern = "_null.csv",full.names = T)
v_k <- unique(df_sim$k)
f_csv <- function(path.csv){
  df <- read_csv(path.csv)
  df$k <- v_k[20]
  df <- cbind(df[,c(1:2,7)],df[,3:6])
  file.remove(path.csv)
  write_csv(df,file = gsub("null",paste0("k",v_k[20]*100),path.csv))
}
v_logical <- sapply(v_csv.path[-1],f_csv)
system("du -s dados/csv/SoE/")
```

```{r df sorteios sitios, eval=FALSE}
df_sorteio_sitios <- df |> 
  filter(S_obs %in% sample(size = 15,df$S_obs) | DA %in% sample(size = 15,df$DA)) |> 
  rbind(filter(df,S_obs %in% range(df$S_obs) | DA %in% range(df$DA))) |>  distinct()
write_csv(df_sorteio_sitios,file = "dados/csv/df_sorteio_sitios.csv")
```
