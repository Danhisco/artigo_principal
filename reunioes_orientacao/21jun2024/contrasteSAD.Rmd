---
title: "Contraste entre contrafactuais: congruência com a SAD observada"
author: "Mori, Danilo"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---
```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,warning = FALSE)
# pacotes
library(twosamples)
library(sads)
library(doMC)
library(ggpmisc)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(insight)
library(bbmle)
library(DHARMa)
library(lme4)
library(mgcv)
library(plyr)
library(dplyr)
# funções
source("source/dinamica_coalescente.R")
source("source/2samples_testes.R")
f_z <- function(x) (x-mean(x))/sd(x)
# obj comum
v_pares <- c("contemp-ideal","non_frag-ideal","contemp-non_frag")
names(v_pares) <- c("frag.total","area","frag.perse")
# dados
df_dados_disponiveis <- read_csv(file = "dados/df_dados_disponiveis.csv") %>% 
  select(SiteCode,year_bestProxy,matches("(lat|long)")) %>% 
  mutate(lat = ifelse(is.na(lat_correct),lat,lat_correct),
         long = ifelse(is.na(long_correct),long,long_correct),
         data_year = as.numeric(year_bestProxy),
         data_year = ifelse(is.na(data_year),2012.5,data_year)) %>% 
  select(-contains("correct"),-year_bestProxy)
# Resultados
## congruência 
df_adSAD <- readRDS("5_resultados/df_adSAD.rds")
## efeito U
df_contrastes <- read_csv(file="dados/csv/taxaU/df_contrastes.csv")
# dados para modelos
# df_md0 <- df_adSAD %>%
#   filter(taxaU=="contemp",land_type=="contemp") %>%
#   select(SiteCode,k,nCongKS) %>%
#   inner_join(df_contrastes %>% select(SiteCode:k,frag.total_logratio)) # versão do
df_contrastes <- df_contrastes %>%
  select(SiteCode:p, contains("_logratio")) %>% 
  mutate(across(-SiteCode,f_z,.names = "{.col}_z")) %>% 
  select(SiteCode,k,p,k_z:frag.total_logratio_z) %>% 
  rename_with(~str_remove(.,"_logratio_z")) %>% 
  pivot_longer(cols = c("area","frag.perse","frag.total"),
               values_to = "Uefeito",
               names_to = "contraste") %>% 
  mutate(contraste = case_when(contraste=="area" ~ "non_frag-ideal",
                               contraste=="frag.total" ~ "contemp-ideal",
                               contraste=="frag.perse" ~ "contemp-non_frag"))
# df SADs congruentes
df_adSADifself <- adply(c("contemp","ideal","non_frag"),1,\(i){
  df_return <- df_adSAD %>% filter(taxaU==i & land_type==i) %>% 
    select(-land_type,-c(Smed:Smax)) %>% 
    rename("contrafactual"="taxaU",
           "nCong"="nCongKS")
  inner_join(df_return,
             df_contrastes %>% 
               filter(contraste=="non_frag-ideal") %>% 
               select(SiteCode:p,ends_with("_z")),
             by=c("SiteCode","k"))
},.id=NULL)
# df_logOR para modelar
df_logOR <- df_adSAD %>% 
  mutate(nKS = case_when(nCongKS == 0 ~ 0.09, #min pred for a GLMM for a sampled comb
                         nCongKS == 100 ~ 99.73, #max pred for a GLMM for a sampled comb
                         TRUE ~ nCongKS),
         logitoKS = log (nKS / (100-nKS))) %>% 
  select(taxaU:land_type,logitoKS) %>% 
  f_contrasteSAD(.,pares=v_pares) %>% 
  inner_join(y=df_contrastes,by=c("contraste","SiteCode","k")) %>% 
  inner_join(y=df_dados_disponiveis,by="SiteCode") %>% 
  relocate(p,.after=k)
```

# Número de SADs congruentes 

```{r ajuste do número de SADs congruentes,eval=FALSE,echo=FALSE}
f_gam <- function(df){
  l_md <- list()
  # 1) gi
  l_md$gi <- gam(cbind(nCong,100-nCong) ~
                   s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                   ti(p_z,k_z) +
                   s(k_z, by=SiteCode, bs="cr") +
                   s(SiteCode,bs="re"),
                 data=df,method = "REML",family="binomial")
  # 2) gs
  l_md$gs <- gam(cbind(nCong,100-nCong) ~
                   s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                   ti(p_z,k_z) +
                   s(k_z, SiteCode, bs="fs",xt=list(bs="cr")) +
                   s(SiteCode,bs="re"),
                 data=df,method = "REML",family="binomial")
  # 3) gi - p*k
  l_md$gi_s_pk <- gam(cbind(nCong,100-nCong) ~
                        s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                        s(k_z, by=SiteCode, bs="cr") +
                        s(SiteCode,bs="re"),
                      data=df,method = "REML",family="binomial")
  # 4) gs - p * k 
  l_md$gs_s_pk <- gam(cbind(nCong,100-nCong) ~
                     s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                     s(k_z, SiteCode, bs="fs",xt=list(bs="cr")) +
                     s(SiteCode,bs="re"),
                   data=df,method = "REML",family="binomial")
  # 5) gi - p
  l_md$gi_s_p <- gam(cbind(nCong,100-nCong) ~
                        s(k_z,bs = "cr") +
                        s(k_z, by=SiteCode, bs="cr") +
                        s(SiteCode,bs="re"),
                      data=df,method = "REML",family="binomial")
  # 6) gs - p
  l_md$gs_s_p <- gam(cbind(nCong,100-nCong) ~
                     s(k_z,bs = "cr") + 
                     s(k_z, SiteCode, bs="fs",xt=list(bs="cr")) +
                     s(SiteCode,bs="re"),
                   data=df,method = "REML",family="binomial")
  # 7) p*k + 1|Site
  l_md$pk_1site <- gam(cbind(nCong,100-nCong) ~
                       s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                       ti(p_z,k_z) +
                       s(SiteCode,bs="re"),
                     data=df,method = "REML",family="binomial")
  # 8) p+k + 1|Site
  l_md$p_k_1site <- gam(cbind(nCong,100-nCong) ~
                         s(k_z,bs = "cr") + s(p_z,bs = "cr") +
                         s(SiteCode,bs="re"),
                       data=df,method = "REML",family="binomial")
  # 9) k + 1|Site
  l_md$k_1site <- gam(cbind(nCong,100-nCong) ~
                         s(k_z,bs = "cr") +
                         s(SiteCode,bs="re"),
                       data=df,method = "REML",family="binomial")
  return(l_md)
}
# registerDoMC(3)
# df <- df_adSADifself %>% 
#   mutate(SiteCode=factor(SiteCode)) %>% 
#   filter(contrafactual=="contemp")
l_md <- df_adSADifself %>% 
  mutate(SiteCode=factor(SiteCode)) %>% 
  split(.,df_md$contrafactual) %>% 
  lapply(.,f_gam)
saveRDS(l_md,file="dados/Rdata/l_md_nSAD_descricaos.rds")
```
```{r graficos exploratorios SAD congruentes}
df_adSADifself %>% 
  ggplot(aes(x=k,y=nCong,color=p,group=SiteCode)) +
  geom_line(alpha=0.2) +
  geom_point(alpha=0.2) +
  scale_colour_gradient2("% CF",midpoint=0.5,
                         low="darkred",
                         mid = "blue",
                         high = "darkgreen") +
  facet_wrap(~contrafactual,ncol=3)
  
```


# Contraste entre contrafactuais

Para cada contraste existem até 4 pontos de referência da taxa U: i) o correspondente, quando a taxa U e a paisagem contrafactual coincidem; ii) numerador, taxa U da paisagem contrafactual no numerador do contraste; iii) denominador, taxa U do contrafactual no denominador; e iv) prístino, a taxa U da respectiva paisagem contrafactual sem perda de .


```{r fig 1 cap}
cap = ""
```
```{r figura 1 - GE logOR em funcao da taxa}
# vai para SI
theme_set(theme_bw())
df_logOR %>% 
  select(-matches("^k|^p(!pristine)")) %>% 
  pivot_longer(cols = c("itself","pristine","numerator","denominator"),
               values_to="logOR",
               names_to="taxaU") %>% 
  mutate(taxaU = factor(taxaU,
                        levels=c("itself","pristine","numerator","denominator"))) %>% 
  ggplot(aes(x=Uefeito,y=logOR,color=taxaU,group=SiteCode)) +
  geom_hline(yintercept = 0,color="gray") +
  geom_vline(xintercept = 0,color="gray") +
  geom_line(alpha=0.2) +
  geom_point(alpha=0.2) +
  labs(x="respectivo efeito em U (z transformado)",
       y="log( Odds SAD / Odds SAD )",
       title="Congruência relativa da SAD simulada em relação ao respectivo efeito na taxa U") +
  scale_color_manual("Parâmetro usado:",values=c("darkred","darkgreen","darkblue","darkorange")) +
  facet_grid(taxaU~contraste)
```

## Conclusão 4 pontos de referência

Concluímos que o principal ponto de referência é o correspondente, pois é o mais coerente com a prática ontológica, enquanto a referência do numerador e denominador tem um caráter mais de análise de sensibilidade. O ponto de referência prístino pode ter valor para TNB uma vez que é proposto como referência de ausência de débito de extinção. Nesse sentido, uma oportunidade é relacionar a referência de correspondência, alinhada com as práticas ontológicas das ecológia de paisagens e a TNB, com a prístina, alinhada com a ontologia independente e da TNB. Assim, iremos prosseguir na seção dos resultados com a análise dos dados da referência correspondente.

# Análise

Primeiro utilizo um glmer padrão para obter o range de valores de logito adequado para esse conjunto de dados. Antes de discutirmos os 4 pontos de referência a ideia era analisar os 4, o código beta dessa abordagem está oculto nesse documento. <!-- (no próximo segundo chunk)  -->
Então segui ajustando para cada contraste de contrafactuais 3 GAMM:

```{r tabelas dos modelos da 1a fase }
library(knitr)
df <- data.frame(
  modelo = c("com efeito por paisagem", "com efeito de paisagem", "sem efeito de paisagem","mgcv::s"),
  `efeito em U` = c("1", "1", "0","s(bs='cr')"),
  `ano dados` = c("1", "1", "1","s(bs='cr')"),
  `coord. geo.` = c("1", "1", "1","s(bs='tp')"),
  `intecep. por sítio` = c("1", "1", "1","s(bs='re')"),
  `efeito em U por sítio` = c("1", "0", "0","s(bs='fs',xt=list(bs='cr'))")
)
knitr::kable(df, 
             caption = "Características dos GAMM na 1a fase de comparações\n method='REML'")
```

O gamm com efeito por paisagem pelo método GI não foi feito pois levava muito tempo em meu computador pessoal. *

```{r 1a parte - ajuste de um GLMM para avaliação do range de logito,eval=FALSE,echo=FALSE}
# 1a parte: ajuste de um GLMM para avaliaçã do range de logito necessário para descrição 
md <- glmer(cbind(nCongKS,100-nCongKS) ~ 
              frag.total_logratio + (1|SiteCode),
            data = df_md0, family = "binomial")
df_md0$pred <- predict(md,df_md0,type="response")*100
v_pred <- df_md0 %>% filter(pred %in% range(df_md0$pred)) %>% 
  pull(pred) %>% round(.,digits = 2)
boxplot(df_md0$nCongKS)
```
```{r 2a parte - ajuste de GAMM para descrever cada contraste NÃO USADO,eval=FALSE}
# 2a parte: ajuste de um GAMM para cada contraste de interesse
f_ajuste <- \(dfi,responses=c("itself","pristine","numerator","denominator")){
  df_md <- dfi %>% pivot_longer(cols=all_of(responses),names_to = "taxaU",values_to = "logOR")
  df_md %>% 
    split(.,df_md$taxaU) %>% 
    lapply(.,f_gamm)
}
f_gamm <- \(dfmd){
  if(all(is.na(dfmd$logOR))) return(NA)
  l_md <- list()
  l_md$gs <- gam(logOR ~ 
                   s(Uefeito,bs="cr") + 
                   s(Uefeito, SiteCode, bs="fs",xt=list(bs="cr")) + 
                   s(SiteCode,bs="re"),
                 data=dfmd,method = "REML")
  l_md$gi <- gam(logOR ~ 
                   s(Uefeito,bs="cr") + 
                   s(Uefeito, by=SiteCode, bs="cr") + 
                   s(SiteCode,bs="re"),
                 data=dfmd,method = "REML")
  return(l_md)
}
l_md_logOR <- df_logOR %>% 
  mutate(SiteCode=factor(SiteCode)) %>% 
  split(.,df_logOR$contraste) %>% 
  lapply(.,f_ajuste)
saveRDS(l_md_logOR,file="dados/Rdata/l_md_logOR.rds")
```
```{r 2a parte: apenas a referência correspondente, echo=FALSE,eval=FALSE}
df_md <- df_logOR %>% select(-(pristine:denominator),-matches("(^k|^p)")) %>% 
  rename(logOR = itself)
f_gam <- \(dfi){
  l_md <- list()
  l_md$`com efeito por paisagem` <- gam(logOR ~
        s(Uefeito,bs="cr") + 
        s(data_year,bs="cr") +
        s(lat,long,bs="tp") +
        s(SiteCode,bs="re") + s(Uefeito, SiteCode, bs="fs",xt=list(bs="cr")),
      data=dfi,method = "REML")
  l_md$`com efeito de paisagem` <- gam(logOR ~
        s(Uefeito,bs="cr") + 
        s(data_year,bs="cr") +
        s(lat,long,bs="tp") +
        s(SiteCode,bs="re"),
      data=dfi,method = "REML")
  l_md$`sem efeito de paisagem` <- gam(logOR ~
        s(data_year,bs="cr") +
        s(lat,long,bs="tp") +
        s(SiteCode,bs="re"),
      data=dfi,method = "REML")
  return(l_md)
}
l_md_logOR <- df_md %>% 
  mutate(SiteCode=factor(SiteCode)) %>% 
  split(.,df_md$contraste) %>% 
  lapply(.,f_gam)
saveRDS(l_md_logOR,file="dados/Rdata/l_md_logOR_itself.rds")
```
```{r inclusão de GAMM GI sensu Peterson et al. 2019}
df_md <- df_logOR %>% select(-(pristine:denominator),-matches("(^k|^p)")) %>% 
  rename(logOR = itself)
f_gam <- \(dfi){
 gam(logOR ~
       s(Uefeito,bs="cr") + 
       s(data_year,bs="cr") +
       s(lat,long,bs="tp") +
       s(SiteCode,bs="re") + s(Uefeito, by=SiteCode, bs="cr"),
     data=dfi,method = "REML")
}
l_md_logOR_gi <- df_md %>% 
  mutate(SiteCode=factor(SiteCode)) %>% 
  split(.,df_md$contraste) %>% 
  lapply(.,f_gam)
saveRDS(l_md_logOR_gi,file="dados/Rdata/l_md_logOR_itself_gi.rds")
```
```{r}
l_md_logOR <- readRDS(file="dados/Rdata/l_md_logOR_itself.rds")
l_md_logOR_gi <- readRDS(file="dados/Rdata/l_md_logOR_itself_gi.rds")
l_md_logOR_cgi <- lapply(names(l_md_logOR),\(li){
  l_md <- l_md_logOR[[li]]
  l_md$`com efeito por paisagem 2` <- l_md_logOR_gi[[li]]
  return(l_md)
})
names(l_md_logOR_cgi) <- names(l_md_logOR)
saveRDS(l_md_logOR_cgi,file="dados/Rdata/l_md_logOR_cgi.rds")
```



## 1a fase de comparações: qual estrutura aleatória usar? e é necessário considerar a paisagem?

Para todos os contrastes, o GAMM mais plausível era aquele 'com efeito por paisagem' (tabela anterior). Todos eles apresentam o p-valor no teste de Moran muito maior do que 0·05% e a estatística de Moran I não é maior do que 0.15 em módulo. A deviance explicada dos modelos mais plausíveis varia entre 0.41 e 0.69. A seguir o diagnóstico dos modelos mais plausíveis.

```{r 1a tabela de selacao, eval=TRUE}
# l_md.logOR <- readRDS("dados/Rdata/l_md_logOR_itself.rds")
l_md_logOR <- readRDS(file="./dados/Rdata/l_md_logOR_cgi.rds")
#
source("source/2samples_testes.R")
source("source/general_tools.R")
source("source/GAMMtools.R")
source("source/fig_tools.R")
df_tabsel_logOR <- ldply(l_md_logOR,f_TabSelGAMM,.id="pair")
write_csv(df_tabsel_logOR,file="dados/csv/df_tabelaSelecao_logOR_cgi.csv")
#
df_tabelaSelecao <- read_csv(file="dados/csv/df_tabelaSelecao_logOR_cgi.csv")
f_SML.gamm <- \(df){md <- l_md_logOR[[df$pair[1]]][[df$modelo[[1]]]]}
l_md_1alike <- dlply(df_tabelaSelecao,"pair",f_SML.gamm)
saveRDS(l_md_1alike,file="dados/Rdata/l_md_logOR_itself_1alike.rds")
######
knitr::kable(
  df_tabelaSelecao,
  caption="Tabela de seleção dos GAMMs da 1a fase de comparações"
  )
```

### Diagnóstico dos modelos mais plausíveis

#### Contemp-ideal

```{r diagnostico contemp-ideal,eval=TRUE}
l_md_1alike <- readRDS(file="dados/Rdata/l_md_logOR_itself_1alike.rds")
v_pattern_gi <- " \\+ s\\(SiteCode, bs \\= \"re\"\\) \\+ s\\(Uefeito, by \\= SiteCode\\)"
md <- l_md_1alike[["contemp-ideal"]]
print(k.check(md))
print(summary(md))
formals(f_extract_smoothers_f_formula)$pregex_rm <- v_pattern_gi
v_draw <- formula(md)[3] %>% f_extract_smoothers_f_formula %>% 
  gsub(", l",",l",.)
print("k.check:")
print(k.check(md))
print("summary:")
print(summary(md))
print(gratia::appraise(md))
print(gratia::draw(md,select = v_draw,residuals=TRUE))
```

1] "s(Uefeito)"   "s(data_year)" "s(lat, long)"
#### Contemp-Non frag.

```{r diagnostico non-frag,eval=TRUE}
md <- l_md_1alike[["contemp-non_frag"]]
print(k.check(md))
print(summary(md))
p <- gratia::appraise(md)
print(p)
p <- gratia::draw(md)
print(p)
```

#### Non frag. - prístino

```{r diagnostico non frag- prístino,eval=TRUE}
md <- l_md_1alike[["non_frag-ideal"]]
print(k.check(md))
print(summary(md))
p <- gratia::appraise(md)
print(p)
p <- gratia::draw(md)
print(p)
```



## 2a fase de comparações: existe concurvidade entre o efeito fixo da paisagem e covariáveis? é necessário considerar todas as covariáveis?

```{r tabelas dos modelos da 2a fase,eval=TRUE}
library(knitr)
df <- data.frame(
  modelo = c("mais plausível 1a fase", "sem ano", "sem coord", "sem cov","mgcv::s"),
  `efeito em U` = c("1", "1", "1","1","s(bs='cr')"),
  `ano dados` = c("1","0", "1", "0","s(bs='cr')"),
  `coord. geo.` = c("1", "1", "0","0","s(bs='tp')"),
  `intecep. por sítio` = c("1", "1", "1","1","s(bs='re')"),
  `efeito em U por sítio` = c("1", "1","1","1","s(bs='fs',xt=list(bs='cr'))")
)
knitr::kable(df, 
             caption = "Características dos GAMM na 2a fase de comparações\n method='REML'")
```

```{r ajuste dos modelos da 2a fase de comparações,eval=FALSE}
# df_md <- df_logOR %>% select(-(pristine:denominator),-matches("(^k|^p)")) %>% 
#   rename(logOR = itself)
l_md_1alike <- readRDS(file="dados/Rdata/l_md_logOR_itself_1alike.rds")
l_md_1alike %>% names
f_gam_update <- \(mdgam){
  f_ref <- formula(mdgam)
  original_data <- mdgam$model
  f_gam <- \(fi){
    gam(formula=fi,data=original_data,method = "REML")
  }
  l_md <- list()
  l_md$`sem ano` <- update.formula(f_ref, . ~ . - s(data_year, bs = "cr"))
  l_md$`sem coord` <- update.formula(f_ref, . ~ . - s(lat, long, bs = "tp"))
  l_md$`sem cov` <- update.formula(l_md$`sem coord`, . ~ . - s(data_year, bs = "cr"))
  l_md <- lapply(l_md,f_gam)
  l_md$cheio <- mdgam
  return(l_md)
}
l_md_logOR_aud <- lapply(l_md_1alike,f_gam_update)
saveRDS(l_md_logOR_aud,file="dados/Rdata/l_md_logOR_aud.rds")
```

```{r tabela de selecao 2a fase de comparacoes,eval=TRUE}
l_md_logOR_aud <- readRDS(file="dados/Rdata/l_md_logOR_aud.rds")
if(!file.exists("dados/csv/df_tabelaSelecao_logOR_aud.csv")){
  df_tabsel_logOR_aud <- ldply(l_md_logOR_aud,f_TabSelGAMM,.id="pair")
  write_csv(df_tabsel_logOR_aud,
            file="dados/csv/df_tabelaSelecao_logOR_aud.csv")
}else{
  df_tabsel_logOR_aud <- 
    read_csv(file="dados/csv/df_tabelaSelecao_logOR_aud.csv")
}
# df_tabelaSelecao <- read_csv(file="dados/csv/df_tabelaSelecao_logOR_aud.csv")
knitr::kable(df_tabsel_logOR_aud, 
             caption = "Tabela de seleção da 2a fase de comparações")
```

# Model averaging da predição a posteriori 

__1o predição para cada modelo__

```{r}
f_lapply <- \(ldf){
  f_PI <- \(gamm){
    lpi <- list(
      with_random = list("apenas fixo" = FALSE,
                         "aleatório e fixo" = TRUE),
      to_exclude = list("apenas fixo"= c("s(Uefeito,SiteCode)",
                                         "s(SiteCode)",
                                         "s(lat,long)",
                                         "s(data_year)"),
                        "aleatório e fixo" = c("s(lat,long)",
                                               "s(data_year)"))
    )
    adply(c("apenas fixo","aleatório e fixo"),1,\(i){
      f_calcPI2(gamm=gamm,
                with_random = lpi$with_random[[i]],
                to_exclude = lpi$to_exclude[[i]])
    },.id = NULL)
  }
  ldply(ldf,f_PI,.id="gamm")
}
l_df <- lapply(l_md_logOR_aud,f_lapply)
saveRDS(l_df,file="./dados/Rdata/rds/l_df_pred_logORfinal.rds")
```



```{r}
gamm <- l_md_logOR_aud[[1]][[1]]
to_exclude <- 
dfmd <- md$gamm
f_newdata <- \(dfmd, with_random=TRUE,len_newdt = 150){
  n_0cols <- names(dfmd) %>% gsub("logOR|Uefeito|SiteCode","",.)
  n_cols <- names(dfmd) %>% grep("logOR|Uefeito|SiteCode",.,value=TRUE)
  dfmd[,!names(dfmd)%in%n_cols] <- 0
  if(with_random){
    return(dfmd)
  }else{
    v_range <- dfmd$Uefeito %>% range
    df_pred <- data.frame(
      Uefeito = seq(v_range[1],v_range[2],length.out=len_newdt),
      SiteCode = "SPigua1"
      )
    df_return <- 
    cbind()
  }
    
    
}
```




<!-- # Apêndice -->

<!-- ## Congruência com a SAD observada nos contrafactuais de paisagens e taxa U -->

```{r}
# df_adSAD
```


